<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Registers · Yao.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/man/registers/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/RegisterBasics/">Register Basics</a></li><li><a class="toctext" href="../../tutorial/BlockBasics/">Block Basics</a></li><li><a class="toctext" href="../../tutorial/Diff/">Automatic Differentiation</a></li><li><a class="toctext" href="../../tutorial/BinaryBasics/">Binary Basics</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../tutorial/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../tutorial/QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="toctext" href="../../tutorial/Grover/">Grover Search and Quantum Inference</a></li><li><a class="toctext" href="../../tutorial/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../yao/">Yao</a></li><li><a class="toctext" href="../interfaces/">Interfaces</a></li><li class="current"><a class="toctext" href>Registers</a><ul class="internal"><li><a class="toctext" href="#Storage-1">Storage</a></li><li><a class="toctext" href="#Operations-1">Operations</a></li><li><a class="toctext" href="#Registers-2">Registers</a></li></ul></li><li><a class="toctext" href="../blocks/">Blocks System</a></li><li><a class="toctext" href="../intrinsics/">Intrinsics</a></li><li><a class="toctext" href="../boost/">Boost</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li><a class="toctext" href="../../dev/extending-blocks/">Extending Blocks</a></li><li><a class="toctext" href="../../dev/benchmark/">Benchmark with ProjectQ</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>Registers</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/registers.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Registers</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Registers-1" href="#Registers-1">Registers</a></h1><p>Quantum circuits process quantum states. A quantum state being processing by a quantum circuit will be stored on a quantum register. In <strong>Yao</strong> we provide several types for registers. The default type for registers is the <a href="#Yao.Registers.DefaultRegister"><code>Yao.Registers.DefaultRegister</code></a>.</p><p>You can directly use factory method <a href="#Yao.Registers.register"><code>register</code></a></p><h2><a class="nav-anchor" id="Storage-1" href="#Storage-1">Storage</a></h2><h4><a class="nav-anchor" id="LDT-format-1" href="#LDT-format-1">LDT format</a></h4><p>Concepturely, a wave function <span>$|\psi\rangle$</span> can be represented in a low dimentional tensor (LDT) format of order-3, L(f, r, b).</p><ul><li>f: focused (i.e. operational) dimensions</li><li>r: remaining dimensions</li><li>b: batch dimension.</li></ul><p>For simplicity, let&#39;s ignore batch dimension for the momentum, we have</p><div>\[|\psi\rangle = \sum\limits_{x,y} L(x, y, .) |j\rangle|i\rangle\]</div><p>Given a configuration <code>x</code> (in operational space), we want get the i-th bit using <code>(x&lt;&lt;i) &amp; 0x1</code>, which means putting the small end the qubit with smaller index. In this representation <code>L(x)</code> will get return <span>$\langle x|\psi\rangle$</span>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p><strong>Why not the other convension</strong>: Using the convention of putting 1st bit on the big end will need to know the total number of qubits <code>n</code> in order to know such positional information.</p></div></div><h4><a class="nav-anchor" id="HDT-format-1" href="#HDT-format-1">HDT format</a></h4><p>Julia storage is column major, if we reshape the wave function to a shape of <span>$2\times2\times ... \times2$</span> and get the HDT (high dimensional tensor) format representation H, we can use H(<span>$x_1, x_2, ..., x_3$</span>) to get <span>$\langle x|\psi\rangle$</span>.</p><h2><a class="nav-anchor" id="Operations-1" href="#Operations-1">Operations</a></h2><h4><a class="nav-anchor" id="Kronecker-product-of-operators-1" href="#Kronecker-product-of-operators-1">Kronecker product of operators</a></h4><p>In order to put small bits on little end, the Kronecker product is <span>$O = o_n \otimes \ldots \otimes o_2 \otimes o_1$</span> where the subscripts are qubit indices.</p><h4><a class="nav-anchor" id="Measurements-1" href="#Measurements-1">Measurements</a></h4><p>Measure means <code>sample</code> and <code>projection</code>.</p><h5><a class="nav-anchor" id="Sample-1" href="#Sample-1">Sample</a></h5><p>Suppose we want to measure operational subspace, we can first get</p><div>\[p(x) = \|\langle x|\psi\rangle\|^2 = \sum\limits_{y} \|L(x, y, .)\|^2.\]</div><p>Then we sample an <span>$a\sim p(x)$</span>. If we just sample and don&#39;t really measure (change wave function), its over.</p><h5><a class="nav-anchor" id="Projection-1" href="#Projection-1">Projection</a></h5><div>\[|\psi\rangle&#39; = \sum_y L(a, y, .)/\sqrt{p(a)} |a\rangle |y\rangle\]</div><p>Good! then we can just remove the operational qubit space since <code>x</code> and <code>y</code> spaces are totally decoupled and <code>x</code> is known as in state <code>a</code>, then we get</p><div>\[|\psi\rangle&#39;_r = \sum_y l(0, y, .) |y\rangle\]</div><p>where <code>l = L(a:a, :, :)/sqrt(p(a))</code>.</p><h2><a class="nav-anchor" id="Registers-2" href="#Registers-2">Registers</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.AbstractRegister" href="#Yao.Registers.AbstractRegister"><code>Yao.Registers.AbstractRegister</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">AbstractRegister{B, T}</code></pre><p>abstract type that registers will subtype from. <code>B</code> is the batch size, <code>T</code> is the data type.</p><p><strong>Required Properties</strong></p><table><tr><th>Property</th><th>Description</th><th>default</th></tr><tr><td><code>viewbatch(reg,i)</code></td><td>get the view of slice in batch dimension.</td><td></td></tr><tr><td><code>nqubits(reg)</code></td><td>get the total number of qubits.</td><td></td></tr><tr><td><code>nactive(reg)</code></td><td>get the number of active qubits.</td><td></td></tr><tr><td><code>state(reg)</code></td><td>get the state of this register. It always return the matrix stored inside.</td><td></td></tr><tr><td>(optional)</td><td></td><td></td></tr><tr><td><code>nremain(reg)</code></td><td>get the number of remained qubits.</td><td>nqubits - nactive</td></tr><tr><td><code>datatype(reg)</code></td><td>get the element type Julia should use to represent amplitude)</td><td><code>T</code></td></tr><tr><td><code>nbatch(reg)</code></td><td>get the number of batch.</td><td><code>B</code></td></tr><tr><td><code>length(reg)</code></td><td>alias of <code>nbatch</code>, for interfacing.</td><td><code>B</code></td></tr></table><p><strong>Required Methods</strong></p><p><strong>Multiply</strong></p><pre><code class="language-none">*(op, reg)</code></pre><p>define how operator <code>op</code> act on this register. This is quite useful when there is a special approach to apply an operator on this register. (e.g a register with no batch, or a register with a MPS state, etc.)</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>be careful, generally, operators can only be applied to a register, thus we should only overload this operation and do not overload <code>*(reg, op)</code>.</p></div></div><p><strong>Pack Address</strong></p><p>pack <code>addrs</code> together to the first k-dimensions.</p><p><strong>Example</strong></p><p>Given a register with dimension <code>[2, 3, 1, 5, 4]</code>, we pack <code>[5, 4]</code> to the first 2 dimensions. We will get <code>[5, 4, 2, 3, 1]</code>.</p><p><strong>Focus Address</strong></p><pre><code class="language-none">focus!(reg, range)</code></pre><p>merge address in <code>range</code> together as one dimension (the active space).</p><p><strong>Example</strong></p><p>Given a register with dimension <code>(2^4)x3</code> and address [1, 2, 3, 4], we focus address <code>[3, 4]</code>, will pack <code>[3, 4]</code> together and merge them as the active space. Then we will have a register with size <code>2^2x(2^2x3)</code>, and address <code>[3, 4, 1, 2]</code>.</p><p><strong>Initializers</strong></p><p>Initializers are functions that provide specific quantum states, e.g zero states, random states, GHZ states and etc.</p><pre><code class="language-none">register(::Type{RT}, raw, nbatch)</code></pre><p>an general initializer for input raw state array.</p><pre><code class="language-none">register(::Val{InitMethod}, ::Type{RT}, ::Type{T}, n, nbatch)</code></pre><p>init register type <code>RT</code> with <code>InitMethod</code> type (e.g <code>Val{:zero}</code>) with element type <code>T</code> and total number qubits <code>n</code> with <code>nbatch</code>. This will be auto-binded to some shortcuts like <code>zero_state</code>, <code>rand_state</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.DefaultRegister" href="#Yao.Registers.DefaultRegister"><code>Yao.Registers.DefaultRegister</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DefaultRegister{B, T} &lt;: AbstractRegister{B, T}</code></pre><p>Default type for a quantum register. It contains a dense array that represents a batched quantum state with batch size <code>B</code> of type <code>T</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.DensityMatrix" href="#Yao.Registers.DensityMatrix"><code>Yao.Registers.DensityMatrix</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">DensityMatrix{B, T, MT&lt;:AbstractArray{T, 3}}
DensityMatrix(state) -&gt; DensityMatrix</code></pre><p>Density Matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.@bit_str-Tuple{Any}" href="#Yao.Registers.@bit_str-Tuple{Any}"><code>Yao.Registers.@bit_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-none">@bit_str -&gt; QuBitStr</code></pre><p>Construct a bit string. such as <code>bit&quot;0000&quot;</code>. The bit strings also supports string concat. Just use it like normal strings.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Intrinsics.hypercubic-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}} where B" href="#Yao.Intrinsics.hypercubic-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}} where B"><code>Yao.Intrinsics.hypercubic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">hypercubic(r::DefaultRegister) -&gt; AbstractArray</code></pre><p>Return the hypercubic form (high dimensional tensor) of this register, only active qubits are considered.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.addbit!" href="#Yao.Registers.addbit!"><code>Yao.Registers.addbit!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">addbit!(r::AbstractRegister, n::Int) -&gt; AbstractRegister
addbit!(n::Int) -&gt; Function</code></pre><p>addbit the register by n bits in state |0&gt;. i.e. |psi&gt; -&gt; |000&gt; ⊗ |psi&gt;, addbit bits have higher indices. If only an integer is provided, then perform lazy evaluation.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.density_matrix" href="#Yao.Registers.density_matrix"><code>Yao.Registers.density_matrix</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">density_matrix(register)</code></pre><p>Returns the density matrix of this register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.fidelity" href="#Yao.Registers.fidelity"><code>Yao.Registers.fidelity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">fidelity(reg1::AbstractRegister, reg2::AbstractRegister) -&gt; Vector</code></pre><p>Return the fidelity between two states.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.focus!" href="#Yao.Registers.focus!"><code>Yao.Registers.focus!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">focus!(reg::DefaultRegister, bits::Ints) -&gt; DefaultRegister
focus!(locs::Int...) -&gt; Function</code></pre><p>Focus register on specified active bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.focus!-Tuple{Any,DefaultRegister,Any}" href="#Yao.Registers.focus!-Tuple{Any,DefaultRegister,Any}"><code>Yao.Registers.focus!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">focus!(func, reg::DefaultRegister, locs) -&gt; DefaultRegister</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.invorder!" href="#Yao.Registers.invorder!"><code>Yao.Registers.invorder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">invorder!(reg::AbstractRegister) -&gt; AbstractRegister</code></pre><p>Inverse the order of lines inplace.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.isnormalized" href="#Yao.Registers.isnormalized"><code>Yao.Registers.isnormalized</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">isnormalized(reg::AbstractRegister) -&gt; Bool</code></pre><p>Return true if a register is normalized else false.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure" href="#Yao.Registers.measure"><code>Yao.Registers.measure</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">measure(register, [n=1]) -&gt; Vector</code></pre><p>measure active qubits for <code>n</code> times.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure!-Union{Tuple{AbstractRegister{B,T} where T}, Tuple{B}} where B" href="#Yao.Registers.measure!-Union{Tuple{AbstractRegister{B,T} where T}, Tuple{B}} where B"><code>Yao.Registers.measure!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">measure!(reg::AbstractRegister) -&gt; Int</code></pre><p>measure and collapse to result state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure_remove!-Union{Tuple{AbstractRegister{B,T} where T}, Tuple{B}} where B" href="#Yao.Registers.measure_remove!-Union{Tuple{AbstractRegister{B,T} where T}, Tuple{B}} where B"><code>Yao.Registers.measure_remove!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">measure_remove!(register) -&gt; Int</code></pre><p>measure the active qubits of this register and remove them.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.measure_reset!-Union{Tuple{AbstractRegister{B,T} where T}, Tuple{B}} where B" href="#Yao.Registers.measure_reset!-Union{Tuple{AbstractRegister{B,T} where T}, Tuple{B}} where B"><code>Yao.Registers.measure_reset!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">measure_and_reset!(reg::AbstractRegister, [mbits]; val=0) -&gt; Int</code></pre><p>measure and set the register to specific value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.oneto-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}, Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T,Int64}} where B" href="#Yao.Registers.oneto-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}, Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T,Int64}} where B"><code>Yao.Registers.oneto</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">oneto({reg::DefaultRegister}, n::Int=nqubits(reg)) -&gt; DefaultRegister</code></pre><p>Return a register with first 1:n bits activated, <code>reg</code> here can be lazy.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.probs" href="#Yao.Registers.probs"><code>Yao.Registers.probs</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">probs(r::AbstractRegister)</code></pre><p>Returns the probability distribution in computation basis <span>$|&lt;x|ψ&gt;|^2$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.probs-Union{Tuple{DensityMatrix{B,T,MT} where MT&lt;:AbstractArray{T,3}}, Tuple{T}, Tuple{B}} where T where B" href="#Yao.Registers.probs-Union{Tuple{DensityMatrix{B,T,MT} where MT&lt;:AbstractArray{T,3}}, Tuple{T}, Tuple{B}} where T where B"><code>Yao.Registers.probs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">probs(dm::DensityMatrix{B, T}) where {B,T}</code></pre><p>Return probability from density matrix.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.product_state-Union{Tuple{T}, Tuple{Type{T},Int64,Integer}, Tuple{Type{T},Int64,Integer,Int64}} where T" href="#Yao.Registers.product_state-Union{Tuple{T}, Tuple{Type{T},Int64,Integer}, Tuple{Type{T},Int64,Integer,Int64}} where T"><code>Yao.Registers.product_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">product_state([::Type{T}], n::Int, config::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre><p>a product state on given configuration <code>config</code>, e.g. product_state(ComplexF64, 5, 0) will give a zero state on a 5 qubit register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.rand_state-Union{Tuple{T}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Int64}} where T" href="#Yao.Registers.rand_state-Union{Tuple{T}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Int64}} where T"><code>Yao.Registers.rand_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rand_state([::Type{T}], n::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre><p>here, random complex numbers are generated using <code>randn(ComplexF64)</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.rank3-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}} where B" href="#Yao.Registers.rank3-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}} where B"><code>Yao.Registers.rank3</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">rank3(reg::DefaultRegister) -&gt; Array{T, 3}</code></pre><p>Return the rank 3 tensor representation of state, the 3 dimensions are (activated space, remaining space, batch dimension).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.register" href="#Yao.Registers.register"><code>Yao.Registers.register</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">register([type], bit_str, [nbatch=1]) -&gt; DefaultRegister</code></pre><p>Returns a <a href="#Yao.Registers.DefaultRegister"><code>DefaultRegister</code></a> by inputing a bit string, e.g</p><pre><code class="language-">using Yao
register(bit&quot;0000&quot;)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.register-Tuple{AbstractArray{T,2} where T}" href="#Yao.Registers.register-Tuple{AbstractArray{T,2} where T}"><code>Yao.Registers.register</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">register(raw) -&gt; DefaultRegister</code></pre><p>Returns a <a href="#Yao.Registers.DefaultRegister"><code>DefaultRegister</code></a> from a raw dense array (<code>Vector</code> or <code>Matrix</code>).</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.relax!" href="#Yao.Registers.relax!"><code>Yao.Registers.relax!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">relax!(reg::DefaultRegister; nbit::Int=nqubits(reg)) -&gt; DefaultRegister
relax!(reg::DefaultRegister, bits::Ints; nbit::Int=nqubits(reg)) -&gt; DefaultRegister
relax!(bits::Ints...; nbit::Int=-1) -&gt; Function</code></pre><p>Inverse transformation of focus, with nbit is the number of active bits of target register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.relaxedvec-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}} where B" href="#Yao.Registers.relaxedvec-Union{Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T}, Tuple{B}} where B"><code>Yao.Registers.relaxedvec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">relaxedvec(r::DefaultRegister) -&gt; AbstractArray</code></pre><p>Return a matrix (vector) for B&gt;1 (B=1) as a vector representation of state, with all qubits activated.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.reorder!" href="#Yao.Registers.reorder!"><code>Yao.Registers.reorder!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reorder!(reg::AbstractRegister, order) -&gt; AbstractRegister
reorder!(orders::Int...) -&gt; Function    # currified</code></pre><p>Reorder the lines of qubits, it also works for array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.reset!" href="#Yao.Registers.reset!"><code>Yao.Registers.reset!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">reset!(reg::AbstractRegister, val::Integer=0) -&gt; AbstractRegister</code></pre><p><code>reset!</code> reg to default value.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.select!-Union{Tuple{B}, Tuple{AbstractRegister{B,T} where T,Any}} where B" href="#Yao.Registers.select!-Union{Tuple{B}, Tuple{AbstractRegister{B,T} where T,Any}} where B"><code>Yao.Registers.select!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">select!(reg::AbstractRegister, b::Integer) -&gt; AbstractRegister
select!(b::Integer) -&gt; Function</code></pre><p>select specific component of qubit, the inplace version, the currified version will return a Function.</p><p>e.g. <code>select!(reg, 0b110)</code> will select the subspace with (focused) configuration <code>110</code>. After selection, the focused qubit space is 0, so you may want call <code>relax!</code> manually.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.select-Union{Tuple{B}, Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T,Any}} where B" href="#Yao.Registers.select-Union{Tuple{B}, Tuple{DefaultRegister{B,T,MT} where MT&lt;:AbstractArray{T,2} where T,Any}} where B"><code>Yao.Registers.select</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">select(reg::AbstractRegister, b::Integer) -&gt; AbstractRegister</code></pre><p>the non-inplace version of <a href="#Yao.Registers.select!-Union{Tuple{B}, Tuple{AbstractRegister{B,T} where T,Any}} where B"><code>select!</code></a> function.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.state" href="#Yao.Registers.state"><code>Yao.Registers.state</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">state(reg) -&gt; AbstractMatrix</code></pre><p>get the state of this register. It always return the matrix stored inside.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.statevec-Tuple{DefaultRegister}" href="#Yao.Registers.statevec-Tuple{DefaultRegister}"><code>Yao.Registers.statevec</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">statevec(r::DefaultRegister) -&gt; AbstractArray</code></pre><p>Return a state matrix/vector by droping the last dimension of size 1.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.tracedist" href="#Yao.Registers.tracedist"><code>Yao.Registers.tracedist</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">tracedist(reg1::AbstractRegister, reg2::AbstractRegister) -&gt; Vector
tracedist(reg1::DensityMatrix, reg2::DensityMatrix) -&gt; Vector</code></pre><p>trace distance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.tracedist-Union{Tuple{B}, Tuple{DensityMatrix{B,T,MT} where MT&lt;:AbstractArray{T,3} where T,DensityMatrix{B,T,MT} where MT&lt;:AbstractArray{T,3} where T}} where B" href="#Yao.Registers.tracedist-Union{Tuple{B}, Tuple{DensityMatrix{B,T,MT} where MT&lt;:AbstractArray{T,3} where T,DensityMatrix{B,T,MT} where MT&lt;:AbstractArray{T,3} where T}} where B"><code>Yao.Registers.tracedist</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">tracedist(dm1::DensityMatrix{B}, dm2::DensityMatrix{B}) -&gt; Vector</code></pre><p>Return trace distance between two density matrices.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.uniform_state-Union{Tuple{T}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Int64}} where T" href="#Yao.Registers.uniform_state-Union{Tuple{T}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Int64}} where T"><code>Yao.Registers.uniform_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">uniform_state([::Type{T}], n::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre><p>uniform state, the state after applying H gates on |0&gt; state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.viewbatch" href="#Yao.Registers.viewbatch"><code>Yao.Registers.viewbatch</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">viewbatch(r::AbstractRegister, i::Int) -&gt; AbstractRegister{1}</code></pre><p>Return a view of a slice from batch dimension.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.zero_state-Union{Tuple{T}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Int64}} where T" href="#Yao.Registers.zero_state-Union{Tuple{T}, Tuple{Type{T},Int64}, Tuple{Type{T},Int64,Int64}} where T"><code>Yao.Registers.zero_state</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-none">zero_state([::Type{T}], n::Int, nbatch::Int=1) -&gt; DefaultRegister</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.ρ" href="#Yao.Registers.ρ"><code>Yao.Registers.ρ</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">ρ(register)</code></pre><p>Returns the density matrix of this register.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.nactive" href="#Yao.nactive"><code>Yao.nactive</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">nactive(x::AbstractRegister) -&gt; Int</code></pre><p>Return the number of active qubits.</p><p>note!!!</p><pre><code class="language-none">Operatiors always apply on active qubits.</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.QuBitStr" href="#Yao.Registers.QuBitStr"><code>Yao.Registers.QuBitStr</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-none">QuBitStr</code></pre><p>String literal for qubits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.join" href="#Base.join"><code>Base.join</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">join(reg1::AbstractRegister, reg2::AbstractRegister) -&gt; Register</code></pre><p>Merge two registers together with kronecker tensor product.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.repeat" href="#Base.repeat"><code>Base.repeat</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">repeat(reg::AbstractRegister{B}, n::Int) -&gt; AbstractRegister</code></pre><p>Repeat register in batch dimension for <code>n</code> times.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-none">normalize!(r::AbstractRegister) -&gt; AbstractRegister</code></pre><p>Return the register with normalized state.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Yao.Registers.shapeorder-Tuple{Tuple{Vararg{T,N}} where T where N,Array{Int64,1}}" href="#Yao.Registers.shapeorder-Tuple{Tuple{Vararg{T,N}} where T where N,Array{Int64,1}}"><code>Yao.Registers.shapeorder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><p>Get the compact shape and order for permutedims.</p></div></div></section><footer><hr/><a class="previous" href="../interfaces/"><span class="direction">Previous</span><span class="title">Interfaces</span></a><a class="next" href="../blocks/"><span class="direction">Next</span><span class="title">Blocks System</span></a></footer></article></body></html>

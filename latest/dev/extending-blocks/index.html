<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Extending Blocks · Yao.jl</title><script>(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-89508993-1', 'auto');
ga('send', 'pageview');
</script><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/dev/extending-blocks/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.png" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Tutorial</span><ul><li><a class="toctext" href="../../tutorial/RegisterBasics/">Register Basics</a></li><li><a class="toctext" href="../../tutorial/BlockBasics/">Block Basics</a></li><li><a class="toctext" href="../../tutorial/Diff/">Automatic Differentiation</a></li><li><a class="toctext" href="../../tutorial/BinaryBasics/">Binary Basics</a></li></ul></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../tutorial/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../tutorial/QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="toctext" href="../../tutorial/Grover/">Grover Search and Quantum Inference</a></li><li><a class="toctext" href="../../tutorial/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../../man/yao/">Yao</a></li><li><a class="toctext" href="../../man/interfaces/">Interfaces</a></li><li><a class="toctext" href="../../man/registers/">Registers</a></li><li><a class="toctext" href="../../man/blocks/">Blocks System</a></li><li><a class="toctext" href="../../man/intrinsics/">Intrinsics</a></li><li><a class="toctext" href="../../man/boost/">Boost</a></li></ul></li><li><span class="toctext">Developer Documentation</span><ul><li class="current"><a class="toctext" href>Extending Blocks</a><ul class="internal"><li><a class="toctext" href="#Extending-constant-gate-1">Extending constant gate</a></li><li><a class="toctext" href="#Extending-Primitive-Block-with-parameters-1">Extending Primitive Block with parameters</a></li><li><a class="toctext" href="#Extending-Composite-Blocks-1">Extending Composite Blocks</a></li><li><a class="toctext" href="#Custom-Pretty-Printing-1">Custom Pretty Printing</a></li><li><a class="toctext" href="#Adding-Operator-Traits-to-Your-Blocks-1">Adding Operator Traits to Your Blocks</a></li><li><a class="toctext" href="#Adding-Tags-to-Your-Blocks-1">Adding Tags to Your Blocks</a></li></ul></li><li><a class="toctext" href="../benchmark/">Benchmark with ProjectQ</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Developer Documentation</li><li><a href>Extending Blocks</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/dev/extending-blocks.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Extending Blocks</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Extending-Blocks-1" href="#Extending-Blocks-1">Extending Blocks</a></h1><h2><a class="nav-anchor" id="Extending-constant-gate-1" href="#Extending-constant-gate-1">Extending constant gate</a></h2><p>We prepared a macro for you about constant gates like <a href="../../man/interfaces/#Yao.Blocks.X"><code>X</code></a>, <a href="../../man/interfaces/#Yao.Blocks.Y"><code>Y</code></a>, <a href="../../man/interfaces/#Yao.Blocks.Z"><code>Z</code></a>.</p><p>Simply use <a href="../../man/blocks/#Yao.Blocks.ConstGateTools.@const_gate-Tuple{Any}"><code>@const_gate</code></a>.</p><h2><a class="nav-anchor" id="Extending-Primitive-Block-with-parameters-1" href="#Extending-Primitive-Block-with-parameters-1">Extending Primitive Block with parameters</a></h2><p><strong>First</strong>, define your own block type by subtyping <a href="../../man/blocks/#Yao.Blocks.PrimitiveBlock"><code>PrimitiveBlock</code></a>. And import methods you will need to overload</p><div><pre><code class="language-julia">using Yao, Yao.Blocks
import Yao.Blocks: mat, dispatch!, parameters # this is the mimimal methods you will need to overload

mutable struct NewPrimitive{T} &lt;: PrimitiveBlock{1, T}
   theta::T
end</code></pre></div><p><strong>Second</strong> define its matrix form.</p><div><pre><code class="language-julia">mat(g::NewPrimitive{T}) where T = Complex{T}[sin(g.theta) 0; cos(g.theta) 0]</code></pre><pre><code class="language-none">mat (generic function with 80 methods)</code></pre></div><p><strong>Yao</strong> will use this matrix to do the simulation by default. However, if you know how to directly apply your block to a quantum register, you can also overload <a href="../../man/blocks/#Yao.Blocks.apply!"><code>apply!</code></a> to make your simulation become more efficient. But this is not required.</p><pre><code class="language-julia">import Yao.Blocks: apply!
apply!(r::AbstractRegister, x::NewPrimitive) = # some efficient way to simulate this block</code></pre><p><strong>Third</strong> If your block contains parameters, declare which member it is with <a href="../../man/blocks/#Yao.Blocks.dispatch!-Tuple{AbstractBlock,Any}"><code>dispatch!</code></a> and how to get them by <a href="../../man/blocks/#Yao.Blocks.parameters"><code>parameters</code></a></p><div><pre><code class="language-julia">dispatch!(g::NewPrimitive, theta) = (g.theta = theta; g)
parameters(x::NewPrimitive) = x.theta</code></pre><pre><code class="language-none">parameters (generic function with 3 methods)</code></pre></div><p>The prototype of <code>dispatch!</code> is simple, just directly write the parameters as your function argument. e.g</p><pre><code class="language-julia">mutable struct MultiParam{N, T} &lt;: PrimitiveBlock{N, Complex{T}}
  theta::T
  phi::T
end</code></pre><p>just write:</p><pre><code class="language-julia">dispatch!(x::MultiParam, theta, phi) = (x.theta = theta; x.phi = phi; x)</code></pre><p>or maybe your block contains a vector of parameters:</p><pre><code class="language-julia">mutable struct VecParam{N, T} &lt;: PrimitiveBlock{N, T}
  params::Vector{T}
end</code></pre><p>just write:</p><pre><code class="language-julia">dispatch!(x::VecParam, params) = (x.params .= params; x)</code></pre><p>be careful, the assignment should be in-placed with <code>.=</code> rather than <code>=</code>.</p><p>If the number of parameters in your new block is fixed, we recommend you to declare this with a type trait <a href="../../man/blocks/#Yao.Blocks.nparameters-Tuple{AbstractBlock}"><code>nparameters</code></a>:</p><div><pre><code class="language-julia">import Yao.Blocks: nparameters
nparameters(::Type{&lt;:NewPrimitive}) = 1</code></pre><pre><code class="language-none">nparameters (generic function with 2 methods)</code></pre></div><p>But it is OK if you do not define this trait, <strong>Yao</strong> will find out how many parameters you have dynamically.</p><p><strong>Fourth</strong> If you want to enable cache of this new block, you have to define your own cache<em>key. usually just use your parameters as the key if you want to cache the matrix form of different parameters, which will accelerate your simulation with a cost of larger memory allocation. You can simply define it with [`cache</em>key`](@ref)</p><div><pre><code class="language-julia">import Yao.Blocks: cache_key
cache_key(x::NewPrimitive) = x.theta</code></pre><pre><code class="language-none">cache_key (generic function with 16 methods)</code></pre></div><h2><a class="nav-anchor" id="Extending-Composite-Blocks-1" href="#Extending-Composite-Blocks-1">Extending Composite Blocks</a></h2><p>Composite blocks are blocks that are able to contain other blocks. To define a new composite block you only need to define your new type as a subtype of <a href="../../man/blocks/#Yao.Blocks.CompositeBlock"><code>CompositeBlock</code></a>, and define a new method called <a href="../../man/blocks/#Yao.Blocks.subblocks"><code>subblocks</code></a> which will provide an iterator that iterates the blocks contained by this composite block.</p><h2><a class="nav-anchor" id="Custom-Pretty-Printing-1" href="#Custom-Pretty-Printing-1">Custom Pretty Printing</a></h2><p>The whole quantum circuit is represented as a tree in the block system. Therefore, we print a block as a tree. To define your own syntax to print, simply overloads the <a href="../../man/blocks/#Yao.Blocks.print_block-Tuple{IO,Any}"><code>print_block</code></a> method. Then it will appears in the block tree syntax automatically.</p><pre><code class="language-julia">print_block(io::IO, block::MyBlockType)</code></pre><h2><a class="nav-anchor" id="Adding-Operator-Traits-to-Your-Blocks-1" href="#Adding-Operator-Traits-to-Your-Blocks-1">Adding Operator Traits to Your Blocks</a></h2><p>A gate <code>G</code> can have following traits</p><ul><li><a href="../../man/blocks/#Yao.Intrinsics.isunitary"><code>isunitary</code></a> - <span>$G^\dagger G = \mathbb{1}$</span></li><li><a href="../../man/blocks/#Yao.Intrinsics.isreflexive"><code>isreflexive</code></a> - <span>$GG = \mathbb{1}$</span></li><li><a href="../../man/intrinsics/#LinearAlgebra.ishermitian-Tuple{Any}"><code>ishermitian</code></a> - <span>$G^\dagger = G$</span></li></ul><p>If <code>G</code> is a <a href="../../man/blocks/#Yao.Blocks.MatrixBlock"><code>MatrixBlock</code></a>, these traits can fall back to using <a href="../../man/blocks/#Yao.Blocks.mat"><code>mat</code></a> method albiet not efficient. If you can know these traits of a gate clearly, you can define them by hand to improve performance.</p><p>These traits are useful, e.g. a <a href="../../man/blocks/#Yao.Blocks.RotationGate"><code>RotationGate</code></a> defines an SU(2) rotation, which requires its generator both hermitian a reflexive so that <span>$R_G(\theta) = \cos\frac{\theta}{2} - i\sin\frac{\theta}{2} G$</span>, so that you can use <span>$R_{\rm X}$</span> and <span>$R_{\rm CNOT}$</span> but not <span>$R_{\rm R_X(0.3)}$</span>.</p><h2><a class="nav-anchor" id="Adding-Tags-to-Your-Blocks-1" href="#Adding-Tags-to-Your-Blocks-1">Adding Tags to Your Blocks</a></h2><p>A tag refers to</p><ul><li><p><a href="../../man/blocks/#Yao.Blocks.Daggered"><code>Daggered</code></a> - <span>$G^\dagger$</span>   We use <code>Base.adjoint(G)</code> to generate a daggered block.</p><ul><li>If a block is hermitian, do nothing,</li><li>For many blocks, e.g. <code>Rx(0.3)</code>, we can still define some rule like <code>Base.adjoint(r::RotationBlock) = (res = copy(r); res.theta = -r.theta; res)</code>,</li><li>if even simple rule does not exist, its <a href="../../man/blocks/#Yao.Blocks.mat"><code>mat</code></a> function will fall back to <code>mat(G)&#39;</code>.</li></ul></li><li><p><a href="../../man/blocks/#Yao.Blocks.CachedBlock"><code>CachedBlock</code></a> - the matrix of this block under current parameter will be stored in cache server for future use.</p><p><code>G |&gt; cache</code> can be useful when you are trying to compile a block into a reuseable matrix, to use cache, you should define <a href="../../man/blocks/#Yao.Blocks.cache_key"><code>cache_key</code></a>.</p></li></ul><footer><hr/><a class="previous" href="../../man/boost/"><span class="direction">Previous</span><span class="title">Boost</span></a><a class="next" href="../benchmark/"><span class="direction">Next</span><span class="title">Benchmark with ProjectQ</span></a></footer></article></body></html>

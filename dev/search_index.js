var documenterSearchIndex = {"docs":
[{"location":"man/blocks.html#Blocks","page":"Blocks","title":"Blocks","text":"Blocks are the basic building blocks of a quantum circuit in Yao. It simply means a quantum operator, thus, all the blocks have matrices in principal and one can get its matrix by mat. The basic blocks required to build an arbitrary quantum circuit is defined in the component package YaoBlocks.\n\nBlock Tree serves as an intermediate representation for Yao to analysis, optimize the circuit, then it will be lowered to instructions like for simulations, blocks will be lowered to instruct! calls.\n\nThe structure of blocks is the same with a small type system, it consists of two basic kinds of blocks: CompositeBlock (like composite types), and PrimitiveBlock (like primitive types). By combining these two kinds of blocks together, we'll be able to construct a quantum circuit and represent it in a tree data structure.","category":"section"},{"location":"man/blocks.html#Primitive-Blocks","page":"Blocks","title":"Primitive Blocks","text":"Primitive blocks are subtypes of PrimitiveBlock, they are the leaf nodes in a block tree, thus primitive types do not have subtypes.\n\nWe provide the following primitive blocks:","category":"section"},{"location":"man/blocks.html#Composite-Blocks","page":"Blocks","title":"Composite Blocks","text":"Composite blocks are subtypes of CompositeBlock, they are the composition of blocks.\n\nWe provide the following composite blocks:","category":"section"},{"location":"man/blocks.html#Operations-on-Blocks","page":"Blocks","title":"Operations on Blocks","text":"","category":"section"},{"location":"man/blocks.html#Error-and-Exceptions","page":"Blocks","title":"Error and Exceptions","text":"","category":"section"},{"location":"man/blocks.html#Extending-Blocks","page":"Blocks","title":"Extending Blocks","text":"Blocks are defined as a sub-type system inside Julia, you could extend it by defining new Julia types by subtyping abstract types we provide. But we also provide some handy tools to help you create your own blocks.","category":"section"},{"location":"man/blocks.html#Define-Custom-Constant-Blocks","page":"Blocks","title":"Define Custom Constant Blocks","text":"Constant blocks are used quite often and in numerical simulation we would expect it to be a real constant in the program, which means it won't allocate new memory when we try to get its matrix for several times, and it won't change with parameters.\n\nIn Yao, you can simply define a constant block with @const_gate, with the corresponding matrix:\n\nusing YaoBlocks, BitBasis # hide\n@const_gate Rand = rand(ComplexF64, 4, 4)\n\nThis will automatically create a type RandGate{T} and a constant binding Rand to the instance of RandGate{ComplexF64}, and it will also bind a Julia constant for the given matrix, so when you call mat(Rand), no allocation will happen.\n\n@allocated mat(Rand)\n\nIf you want to use other data type like ComplexF32, you could directly call Rand(ComplexF32), which will create a new instance with data type ComplexF32.\n\nRand(ComplexF32)\n\nBut remember this won't bind the matrix, it only binds the matrix you give\n\n@allocated mat(Rand(ComplexF32))\n\nso if you want to make the matrix call mat for ComplexF32 to have zero allocation as well, you need to do it explicitly.\n\n@const_gate Rand::ComplexF32","category":"section"},{"location":"man/blocks.html#Define-Custom-Blocks","page":"Blocks","title":"Define Custom Blocks","text":"Primitive blocks are the most basic block to build a quantum circuit, if a primitive block has a certain structure, like containing tweakable parameters, it cannot be defined as a constant, thus create a new type by subtyping PrimitiveBlock is necessary\n\nusing YaoBlocks\n\nmutable struct PhaseGate{T <: Real} <: PrimitiveBlock{1}\n    theta::T\nend\n\nIf your insterested block is a composition of other blocks, you should define a CompositeBlock, e.g\n\nstruct ChainBlock{N} <: CompositeBlock{N}\n    blocks::Vector{AbstractBlock{N}}\nend\n\nBesides types, there are several interfaces you could define for a block, but don't worry, they should just error if it doesn't work.","category":"section"},{"location":"man/blocks.html#Define-the-matrix","page":"Blocks","title":"Define the matrix","text":"The matrix form of a block is the minimal requirement to make a custom block functional, defining it is super simple, e.g for phase gate:\n\nmat(::Type{T}, gate::PhaseGate) where T = exp(T(im * gate.theta)) * Matrix{Complex{T}}(I, 2, 2)\n\nOr for composite blocks, you could just calculate the matrix by call mat on its subblocks.\n\nmat(::Type{T}, c::ChainBlock) where T = prod(x->mat(T, x), reverse(c.blocks))\n\nThe rest will just work, but might be slow since you didn't define any specification for this certain block.","category":"section"},{"location":"man/blocks.html#Define-how-blocks-are-applied-to-registers","page":"Blocks","title":"Define how blocks are applied to registers","text":"Although, having its matrix is already enough for applying a block to register, we could improve the performance or dispatch to other actions by overloading apply! interface, e.g we can use specialized instruction to make X gate (a builtin gate defined @const_gate) faster:\n\nfunction apply!(r::ArrayReg, x::XGate)\n    nactive(r) == 1 || throw(QubitMismatchError(\"register size $(nactive(r)) mismatch with block size $N\"))\n    instruct!(matvec(r.state), Val(:X), (1, ))\n    return r\nend\n\nIn Yao, this interface allows us to provide more aggressive specialization on different patterns of quantum circuits to accelerate the simulation etc.","category":"section"},{"location":"man/blocks.html#Define-Parameters","page":"Blocks","title":"Define Parameters","text":"If you want to use some member of the block to be parameters, you need to declare them explicitly\n\nniparams(::Type{<:PhaseGate}) = 1\ngetiparams(x::PhaseGate) = x.theta\nsetiparams!(r::PhaseGate, param::Real) = (r.theta = param; r)","category":"section"},{"location":"man/blocks.html#Define-Adjoint","page":"Blocks","title":"Define Adjoint","text":"Since blocks are actually quantum operators, it makes sense to call their adjoint as well. We provide Daggered for general purpose, but some blocks may have more specific transformation rules for adjoints, e.g\n\nBase.adjoint(x::PhaseGate) = PhaseGate(-x.theta)","category":"section"},{"location":"man/blocks.html#Define-Cache-Keys","page":"Blocks","title":"Define Cache Keys","text":"To enable cache, you should define cache_key, e.g for phase gate, we only cares about its phase, instead of the whole instance\n\ncache_key(gate::PhaseGate) = gate.theta","category":"section"},{"location":"man/blocks.html#APIs","page":"Blocks","title":"APIs","text":"","category":"section"},{"location":"man/blocks.html#YaoAPI.AbstractBlock","page":"Blocks","title":"YaoAPI.AbstractBlock","text":"AbstractBlock{D}\n\nAbstract type for quantum circuit blocks. while D is the number level in each qudit.\n\nRequired Methods\n\napply!.\nmat.\noccupied_locs.\nprint_block\n\nOptional Methods\n\ncontent\nchcontent\nsubblocks.\nchsubblocks.\nBase.hash\nBase.:(==)\nnlevel.\ngetiparams.\nsetiparams!.\nparameters.\nnparameters.\niparams_eltype.\nparameters_eltype.\ndispatch!.\nrender_params.\napply_back!.\nmat_back!.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoAPI.PrimitiveBlock","page":"Blocks","title":"YaoAPI.PrimitiveBlock","text":"PrimitiveBlock{D} <: AbstractBlock{D}\n\nAbstract type that all primitive block will subtype from. A primitive block is a concrete block who can not be decomposed into other blocks. All composite block can be decomposed into several primitive blocks.\n\nnote: Note\nsubtype for primitive block with parameter should implement hash and == method to enable key value cache.\n\nRequired Methods\n\napply!\nmat\nprint_block\nBase.hash\nBase.:(==)\n\nOptional Methods\n\nnlevel.\ngetiparams.\nsetiparams!.\nparameters.\nnparameters.\niparams_eltype.\nparameters_eltype.\ndispatch!.\nrender_params.\napply_back!.\nmat_back!.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoAPI.CompositeBlock","page":"Blocks","title":"YaoAPI.CompositeBlock","text":"CompositeBlock{D} <: AbstractBlock{D}\n\nAbstract supertype which composite blocks will inherit from. Composite blocks are blocks composited from other AbstractBlocks, thus it is a AbstractBlock as well.\n\nRequired Methods\n\napply!\nmat\noccupied_locs.\nsubblocks.\nchsubblocks.\n\nOptional Methods\n\nnlevel.\ngetiparams.\nsetiparams!.\nparameters.\nnparameters.\niparams_eltype.\nparameters_eltype.\ndispatch!.\nrender_params.\napply_back!.\nmat_back!.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.GeneralMatrixBlock","page":"Blocks","title":"YaoBlocks.GeneralMatrixBlock","text":"GeneralMatrixBlock{D, MT} <: PrimitiveBlock{D}\nGeneralMatrixBlock{D}(m, n, A, tag=\"matblock(...)\")\nGeneralMatrixBlock(A; nlevel=2, tag=\"matblock(...)\")\n\nGeneral matrix gate wraps a matrix operator to quantum gates. This is the most general form of a quantum gate.\n\nArguments\n\nm and n are the number of dits in row and column.\nA is a matrix.\ntag is the printed information.\nD and nlevel are the number of levels in each qudit.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.IdentityGate","page":"Blocks","title":"YaoBlocks.IdentityGate","text":"IdentityGate{D} <: TrivialGate{D}\n\nThe identity gate.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Measure","page":"Blocks","title":"YaoBlocks.Measure","text":"Measure{D,K, OT, LT, PT, RNG} <: PrimitiveBlock{D}\nMeasure(n::Int; rng=Random.GLOBAL_RNG, operator=ComputationalBasis(), locs=1:n, resetto=nothing, remove=false, nlevel=2, error_prob=0.0)\n\nMeasurement block.\n\nFields\n\nn::Int: number of qubits.\nrng::RNG: random number generator.\noperator::OT: operator to measure, by default it is ComputationalBasis().\nlocations::LT: locations to measure, by default it is 1:n.\npostprocess::PT: postprocess to apply to the measurement result, e.g. ResetTo to reset the measured qubits to a specific state.\nerror_prob::Float64: error probability, by default it is 0.0. This is only supported for 2-level systems, and the operator must be ComputationalBasis or a single qubit operator.\nresults::Any: measurement results, by default it is undef.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Measure-Union{Tuple{Int64}, Tuple{RNG}, Tuple{OT}} where {OT, RNG}","page":"Blocks","title":"YaoBlocks.Measure","text":"Measure(n::Int; rng=Random.GLOBAL_RNG, operator=ComputationalBasis(), locs=AllLocs(), resetto=nothing, remove=false, error_prob=0.0)\n\nCreate a Measure block with number of qudits n.\n\nExamples\n\nYou can create a Measure block on given basis (default is the computational basis).\n\njulia> Measure(4)\nMeasure(4)\n\nOr you could specify which qudits you are going to measure\n\njulia> Measure(4; locs=1:3)\nMeasure(4;locs=(1, 2, 3))\n\nby default this will collapse the current register to measure results.\n\njulia> r = normalize!(arrayreg(bit\"000\") + arrayreg(bit\"111\"))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> state(r)\n8×1 Matrix{ComplexF64}:\n 0.7071067811865475 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n                0.0 + 0.0im\n 0.7071067811865475 + 0.0im\n\njulia> r |> Measure(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> state(r)\n8×1 Matrix{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n\nBut you can also specify the target bit configuration you want to collapse to with keyword resetto.\n\n```jldoctest; setup=:(using Yao) julia> m = Measure(4; resetto=bit\"0101\") Measure(4;postprocess=ResetTo{BitStr{4,Int64}}(0101 ₍₂₎))\n\njulia> m.postprocess ResetTo{BitStr{4,Int64}}(0101 ₍₂₎)```\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.PhaseGate","page":"Blocks","title":"YaoBlocks.PhaseGate","text":"PhaseGate\n\nGlobal phase gate.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Projector","page":"Blocks","title":"YaoBlocks.Projector","text":"struct Projector{D, T, AT<:(AbstractArrayReg{D, T})} <: PrimitiveBlock{D}\n\nProjection operator to target state psi.\n\nDefinition\n\nprojector(s) defines the following operator.\n\ns  ss\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.ReflectGate","page":"Blocks","title":"YaoBlocks.ReflectGate","text":"ReflectGate{D, T, Tt, AT<:AbstractArrayReg{D, T}} = TimeEvolution{D,Tt,Projector{D,T,AT}}\n\nLet |v⟩ be a quantum state vector, a reflection gate is a unitary operator that defined as the following operation.\n\nv  1 - (1-exp(-iθ)) vv\n\nWhen θ = π, it defines a standard reflection gate 1-2vv.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.RotationGate","page":"Blocks","title":"YaoBlocks.RotationGate","text":"RotationGate{D,T,GT<:AbstractBlock{D}} <: PrimitiveBlock{D}\n\nRotationGate, with GT both hermitian and isreflexive.\n\nDefinition\n\nExpression rot(G, θ) defines the following gate\n\ncos fractheta2I - i sin fractheta2 G\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.ShiftGate","page":"Blocks","title":"YaoBlocks.ShiftGate","text":"ShiftGate <: PrimitiveBlock\n\nPhase shift gate.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.TimeEvolution","page":"Blocks","title":"YaoBlocks.TimeEvolution","text":"TimeEvolution{D, TT, GT} <: PrimitiveBlock{D}\n\nTimeEvolution, where GT is block type. input matrix should be hermitian.\n\nnote: Note\nTimeEvolution contructor check hermicity of the input block by default, but sometimes it can be slow. Turn off the check manually by specifying optional parameter check_hermicity = false.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.ConstGate.@const_gate","page":"Blocks","title":"YaoBlocks.ConstGate.@const_gate","text":"@const_gate <gate name> = <expr>\n@const_gate <gate name>::<type> = <expr>\n@const_gate <gate>::<type>\n\nThis macro simplify the definition of a constant gate. It will automatically bind the matrix form to a constant which will reduce memory allocation in the runtime.\n\nExamples\n\n@const_gate X = ComplexF64[0 1;1 0]\n\nor\n\n@const_gate X::ComplexF64 = [0 1;1 0]\n\nYou can bind new element types by simply re-declare with a type annotation.\n\n@const_gate X::ComplexF32\n\n\n\n\n\n","category":"macro"},{"location":"man/blocks.html#YaoBlocks.AbstractAdd","page":"Blocks","title":"YaoBlocks.AbstractAdd","text":"AbstractAdd{D} <: CompositeBlock{D}\n\nThe abstract add interface, aimed to support Hamiltonian types.\n\nRequired Interfaces\n\nchsubblocks\nsubblocks\n\nProvides\n\nunsafe_apply! and its backward\nmat and its backward\nadjoint\noccupied_locs\ngetindex over dit strings\nishermitian\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Add","page":"Blocks","title":"YaoBlocks.Add","text":"Add{D} <: AbstractAdd{D}\nAdd(blocks::AbstractBlock...) -> Add\n\nType for block addition.\n\njulia> X + X\nnqubits: 1\n+\n├─ X\n└─ X\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.CachedBlock","page":"Blocks","title":"YaoBlocks.CachedBlock","text":"CachedBlock{ST, BT, D} <: TagBlock{BT, D}\n\nA label type that tags an instance of type BT. It forwards every methods of the block it contains, except mat and apply!, it will cache the matrix form whenever the program has.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.ChainBlock","page":"Blocks","title":"YaoBlocks.ChainBlock","text":"ChainBlock{D} <: CompositeBlock{D}\n\nChainBlock is a basic construct tool to create user defined blocks horizontically. It is a Vector like composite type.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.ControlBlock","page":"Blocks","title":"YaoBlocks.ControlBlock","text":"A control block is a composite block that applies a block when the control qubits are all ones.\n\nnote: Note\nIf control qubit index is negative, it means the inverse control, i.e., the block is applied when the control qubit is zero.\n\nFields\n\nn::Int64\nctrl_locs::NTuple{C, Int64} where C\nctrl_config::NTuple{C, Int64} where C\ncontent::AbstractBlock\nlocs::NTuple{M, Int64} where M\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Daggered","page":"Blocks","title":"YaoBlocks.Daggered","text":"Daggered{BT, D} <: TagBlock{BT,D}\n\nWrapper block allowing to execute the inverse of a block of quantum circuit.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Daggered-Union{Tuple{BT}, Tuple{D}} where {D, BT<:AbstractBlock{D}}","page":"Blocks","title":"YaoBlocks.Daggered","text":"Daggered(block)\n\nCreate a Daggered block. Let G be a input block, G' or Daggered(block) in code represents G^dagger.\n\nExamples\n\nThe inverse QFT is not hermitian, thus it will be tagged with a Daggered block.\n\njulia> A(i, j) = control(i, j=>shift(2π/(1<<(i-j+1))));\n\njulia> B(n, i) = chain(n, i==j ? put(i=>H) : A(j, i) for j in i:n);\n\njulia> qft(n) = chain(B(n, i) for i in 1:n);\n\njulia> struct QFT <: PrimitiveBlock{2} n::Int end\n\njulia> YaoBlocks.nqudits(q::QFT) = q.n\n\n\njulia> circuit(q::QFT) = qft(nqubits(q));\n\njulia> YaoBlocks.mat(x::QFT) = mat(circuit(x));\n\njulia> QFT(2)'\n [†]QFT\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.KronBlock","page":"Blocks","title":"YaoBlocks.KronBlock","text":"KronBlock{D,M,MT<:NTuple{M,Any}} <: CompositeBlock{D}\n\ncomposite block that combine blocks by kronecker product.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.OnLevels","page":"Blocks","title":"YaoBlocks.OnLevels","text":"OnLevels{D, Ds, T <: AbstractBlock{Ds}} <: TagBlock{T, D}\n\nDefine a gate that is applied to a subset of levels.\n\nFields\n\ngate: the gate to be applied.\nlevels: the levels to apply the gate to.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.PSwap","page":"Blocks","title":"YaoBlocks.PSwap","text":"PSwap = PutBlock{2,2,RotationGate{2,T,G}} where {G<:ConstGate.SWAPGate}\nPSwap(n::Int, locs::Tuple{Int,Int}, θ::Real)\n\nParametrized swap gate that swaps two qubits with a phase, defined as\n\nrm SWAP(θ) = e^-iθrm SWAP2\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.PutBlock","page":"Blocks","title":"YaoBlocks.PutBlock","text":"PutBlock{D,C,GT<:AbstractBlock} <: AbstractContainer{GT,D}\n\nType for putting a block at given locations.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.RepeatedBlock","page":"Blocks","title":"YaoBlocks.RepeatedBlock","text":"RepeatedBlock{D,C,GT<:AbstractBlock} <: AbstractContainer{GT,D}\n\nRepeat the same block on given locations.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Scale","page":"Blocks","title":"YaoBlocks.Scale","text":"Scale{S <: Union{Number, Val}, D, BT <: AbstractBlock{D}} <: TagBlock{BT, D}\nScale(factor, block)\n\nMultiply a block with a scalar factor, which can be a number or a Val. If the factor is a number, it is regarded as a parameter that can be changed dynamically. If the factor is a Val, it is regarded as a constant.\n\nExamples\n\njulia> 2 * X\n[scale: 2] X\n\njulia> im * Z\n[+im] Z\n\njulia> -im * Z\n[-im] Z\n\njulia> -Z\n[-] Z\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Subroutine","page":"Blocks","title":"YaoBlocks.Subroutine","text":"Subroutine{D, BT <: AbstractBlock, C} <: AbstractContainer{BT, D}\n\nSubroutine node on given locations. This allows you to shoehorn a smaller circuit to a larger one.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoBlocks.Swap","page":"Blocks","title":"YaoBlocks.Swap","text":"Swap = PutBlock{2,2,G} where {G<:ConstGate.SWAPGate}\nSwap(n::Int, locs::Tuple{Int,Int})\n\nSwap gate, which swaps two qubits.\n\n\n\n\n\n","category":"type"},{"location":"man/blocks.html#YaoAPI.unsafe_apply!","page":"Blocks","title":"YaoAPI.unsafe_apply!","text":"unsafe_apply!(r, block)\n\nSimilar to apply!, but will not check the size of the register and block, this is mainly used for overloading new blocks, use at your own risk.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.apply!","page":"Blocks","title":"YaoAPI.apply!","text":"apply!(register, block)\n\nApply a block (of quantum circuit) to a quantum register.\n\nnote: Note\nto overload apply! for a new block, please overload the unsafe_apply! function with same interface. Then the apply! interface will do the size checks on inputs automatically.\n\nExamples\n\njulia> r = zero_state(2)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> apply!(r, put(2, 1=>X))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\njulia> measure(r;nshots=10)\n10-element Vector{DitStr{2, 2, Int64}}:\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n 01 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.apply","page":"Blocks","title":"YaoBlocks.apply","text":"apply(register, block)\n\nThe non-inplace version of applying a block (of quantum circuit) to a quantum register. Check apply! for the faster inplace version.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.niparams","page":"Blocks","title":"YaoAPI.niparams","text":"niparam(block) -> Int\n\nReturn number of intrinsic parameters in block. See also nparameters.\n\nExamples\n\njulia> niparams(Rx(0.1))\n1\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.getiparams","page":"Blocks","title":"YaoAPI.getiparams","text":"getiparams(block)\n\nReturns the intrinsic parameters of node block, default is an empty tuple.\n\nExamples\n\njulia> getiparams(Rx(0.1))\n0.1\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.render_params","page":"Blocks","title":"YaoAPI.render_params","text":"render_params(r::AbstractBlock, params)\n\nThis function renders the input parameter to a consumable type to r. params can be a number or a symbol like :zero and :random.\n\nExamples\n\njulia> collect(render_params(Rx(0.1), :zero))\n1-element Vector{Float64}:\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.nparameters","page":"Blocks","title":"YaoAPI.nparameters","text":"nparameters(block) -> Int\n\nReturn number of parameters in block. See also niparams.\n\nExamples\n\njulia> nparameters(chain(Rx(0.1), Rz(0.2)))\n2\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.occupied_locs","page":"Blocks","title":"YaoAPI.occupied_locs","text":"occupied_locs(x)\n\nReturn a tuple of occupied locations of x.\n\nExamples\n\njulia> occupied_locs(kron(5, 1=>X, 3=>X))\n(1, 3)\n\njulia> occupied_locs(kron(5, 1=>X, 3=>I2))\n(1,)\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.print_block","page":"Blocks","title":"YaoAPI.print_block","text":"print_block(io, block)\n\nDefine how blocks are printed as text in one line.\n\nExamples\n\njulia> print_block(stdout, X)\nX\n\njulia> print_block(stdout, put(2, 1=>X))\nput on (1)\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.apply_back!","page":"Blocks","title":"YaoAPI.apply_back!","text":"apply_back!((ψ, ∂L/∂ψ*), circuit::AbstractBlock, collector) -> AbstractRegister\n\nback propagate and calculate the gradient ∂L/∂θ = 2Re(∂L/∂ψ⋅∂ψ/∂θ), given ∂L/∂ψ. ψ is the output register, ∂L/∂ψ* should also be register type.\n\nNote: gradients are stored in Diff blocks, it can be access by either diffblock.grad or gradient(circuit). Note2: now apply_back! returns the inversed gradient!\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.mat_back!","page":"Blocks","title":"YaoAPI.mat_back!","text":"mat_back!(T, rb::AbstractBlock, adjy, collector)\n\nBack propagate the matrix gradients.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#Base.:|>-Tuple{AbstractRegister, AbstractBlock}","page":"Blocks","title":"Base.:|>","text":"|>(register, circuit) -> register\n\nApply a quantum circuits to register, which modifies the register directly.\n\nExample\n\njulia> arrayreg(bit\"0\") |> X |> Y\n\nwarning: Warning\n|> is equivalent to apply!, which means it has side effects. You need to use apply if you do not want to change it in-place.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#Base.kron-Tuple{Int64, Vararg{Pair{<:Any, <:AbstractBlock}}}","page":"Blocks","title":"Base.kron","text":"kron(n, locs_and_blocks::Pair{<:Any, <:AbstractBlock}...) -> KronBlock\n\nReturns a n-qudit KronBlock. The inputs contains a list of location-block pairs, where a location can be an integer or a range. It is conceptually a chain of put block without address conflicts, but it has a richer type information that can be useful for various purposes such as more efficient mat function.\n\nLet I be a 2times 2 identity matrix, G and H be two 2times 2 matrix, the matrix representation of kron(n, i=>G, j=>H) (assume j  i) is defined as\n\nI^otimes n-j otimes H otimes I^otimes j-i-1 otimes G otimes I^i-1\n\nFor multiple locations, the expression can be complicated.\n\nExamples\n\nUse kron to construct a KronBlock, it will put an X gate on the 1st qubit, and a Y gate on the 3rd qubit.\n\njulia> kron(4, 1=>X, 3=>Y)\nnqubits: 4\nkron\n├─ 1=>X\n└─ 3=>Y\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#Base.kron-Tuple{Vararg{AbstractBlock}}","page":"Blocks","title":"Base.kron","text":"kron(blocks::AbstractBlock...)\nkron(n, itr)\n\nReturn a KronBlock, with total number of qubits n, and blocks should use all the locations on n wires in quantum circuits.\n\nExamples\n\nYou can use kronecker product to composite small blocks to a large blocks.\n\njulia> kron(X, Y, Z, Z)\nnqubits: 4\nkron\n├─ 1=>X\n├─ 2=>Y\n├─ 3=>Z\n└─ 4=>Z\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#Base.kron-Tuple{Vararg{Pair{<:Any, <:AbstractBlock}}}","page":"Blocks","title":"Base.kron","text":"kron(blocks...) -> f(n)\nkron(itr) -> f(n)\n\nReturn a lambda, which will take the total number of qubits as input.\n\nExamples\n\nIf you don't know the number of qubit yet, or you are just too lazy, it is fine.\n\njulia> kron(put(1=>X) for _ in 1:2)\n(n -> kron(n, ((n  ->  put(n, 1 => X)), (n  ->  put(n, 1 => X)))...))\n\njulia> kron(X for _ in 1:2)\nnqubits: 2\nkron\n├─ 1=>X\n└─ 2=>X\n\njulia> kron(1=>X, 3=>Y)\n(n -> kron(n, (1 => X, 3 => Y)...))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#Base.repeat-Tuple{AbstractBlock, Any}","page":"Blocks","title":"Base.repeat","text":"repeat(x::AbstractBlock, locs)\n\nLazy curried version of repeat.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#Base.repeat-Tuple{Int64, AbstractBlock, Vararg{Int64}}","page":"Blocks","title":"Base.repeat","text":"repeat(n, subblock::AbstractBlock[, locs]) -> RepeatedBlock{n}\n\nCreate a n-qudit RepeatedBlock block, which is conceptually a [kron] block with all gates being the same. If locs is provided, repeat on locs, otherwise repeat on all locations. Let G be a 2times 2 matrix, the matrix representation of repeat(n, X) is\n\nX^otimes n\n\nThe RepeatedBlock can be used to accelerate repeated applying certain gate types: X, Y, Z, S, T, Sdag, and Tdag.\n\nExamples\n\nThis will create a repeat block which puts 4 X gates on each location.\n\njulia> repeat(4, X)\nnqubits: 4\nrepeat on (1, 2, 3, 4)\n└─ X\n\nYou can also specify the location\n\njulia> repeat(4, X, (1, 2))\nnqubits: 4\nrepeat on (1, 2)\n└─ X\n\nBut repeat won't copy the gate, thus, if it is a gate with parameter, e.g a phase(0.1), the parameter will change simultaneously.\n\njulia> g = repeat(4, phase(0.1))\nnqubits: 4\nrepeat on (1, 2, 3, 4)\n└─ phase(0.1)\n\njulia> g.content\nphase(0.1)\n\njulia> g.content.theta = 0.2\n0.2\n\njulia> g\nnqubits: 4\nrepeat on (1, 2, 3, 4)\n└─ phase(0.2)\n\nRepeat over certain gates will provide speed up.\n\njulia> reg = rand_state(20);\n\njulia> @time apply!(reg, repeat(20, X));\n  0.002252 seconds (5 allocations: 656 bytes)\n\njulia> @time apply!(reg, chain([put(20, i=>X) for i=1:20]));\n  0.049362 seconds (82.48 k allocations: 4.694 MiB, 47.11% compilation time)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#LinearAlgebra.ishermitian-Tuple{Any}","page":"Blocks","title":"LinearAlgebra.ishermitian","text":"ishermitian(op::AbstractBlock) -> Bool\n\nReturns true if op is hermitian.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.chcontent-Tuple{AbstractContainer, Any}","page":"Blocks","title":"YaoAPI.chcontent","text":"chcontent(x, blk)\n\nCreate a similar block of x and change its content to blk.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.chsubblocks-Tuple{AbstractBlock, Any}","page":"Blocks","title":"YaoAPI.chsubblocks","text":"chsubblocks(composite_block, itr)\n\nChange the sub-blocks of a CompositeBlock with given iterator itr.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.content-Tuple{AbstractContainer}","page":"Blocks","title":"YaoAPI.content","text":"content(x)\n\nReturns the content of x.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.dispatch!-Tuple{Union{Nothing, Function}, AbstractBlock, Any}","page":"Blocks","title":"YaoAPI.dispatch!","text":"dispatch!(x::AbstractBlock, collection)\n\nDispatch parameters in collection to block tree x.\n\nnote: Note\nit will try to dispatch the parameters in collection first.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.expect-Tuple{AbstractBlock, AbstractRegister}","page":"Blocks","title":"YaoAPI.expect","text":"expect(op::AbstractBlock, reg) -> Real\nexpect(op::AbstractBlock, reg => circuit) -> Real\nexpect(op::AbstractBlock, density_matrix) -> Real\n\nGet the expectation value of an operator, the second parameter can be a register reg or a pair of input register and circuit reg => circuit.\n\nexpect'(op::AbstractBlock, reg=>circuit) -> Pair expect'(op::AbstractBlock, reg) -> AbstracRegister\n\nObtain the gradient with respect to registers and circuit parameters. For pair input, the second return value is a pair of gψ=>gparams, with gψ the gradient of input state and gparams the gradients of circuit parameters. For register input, the return value is a register.\n\nnote: Note\nFor batched register, expect(op, reg=>circuit) returns a vector of size number of batch as output. However, one can not differentiate over a vector loss, so expect'(op, reg=>circuit) accumulates the gradient over batch, rather than returning a batched gradient of parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.getiparams-Tuple{AbstractBlock}","page":"Blocks","title":"YaoAPI.getiparams","text":"getiparams(block)\n\nReturns the intrinsic parameters of node block, default is an empty tuple.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.iparams_eltype-Tuple{AbstractBlock}","page":"Blocks","title":"YaoAPI.iparams_eltype","text":"iparams_eltype(block)\n\nReturn the element type of getiparams.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.mat-Tuple{AbstractBlock}","page":"Blocks","title":"YaoAPI.mat","text":"mat([T=ComplexF64], blk)\n\nReturns the matrix form of given block.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.mat-Tuple{GeneralMatrixBlock}","page":"Blocks","title":"YaoAPI.mat","text":"mat(A::GeneralMatrixBlock)\n\nReturn the matrix of general matrix block.\n\nwarn: Warn\nInstead of converting it to the default data type ComplexF64, this will return its contained matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.operator_fidelity-Tuple{AbstractBlock, AbstractBlock}","page":"Blocks","title":"YaoAPI.operator_fidelity","text":"operator_fidelity(b1::AbstractBlock, b2::AbstractBlock) -> Number\n\nOperator fidelity defined as\n\nF^2 = frac1dleftrm Tr(b1^dagger b2)right\n\nHere, d is the size of the Hilbert space. Note this quantity is independant to global phase. See arXiv: 0803.2940v2, Equation (2) for reference.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.parameters-Tuple{AbstractBlock}","page":"Blocks","title":"YaoAPI.parameters","text":"parameters(block)\n\nReturns all the parameters contained in block tree with given root block.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.parameters_eltype-Tuple{AbstractBlock}","page":"Blocks","title":"YaoAPI.parameters_eltype","text":"parameters_eltype(x)\n\nReturn the element type of parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoAPI.setiparams!","page":"Blocks","title":"YaoAPI.setiparams!","text":"setiparams!([f], block, itr)\nsetiparams!([f], block, params...)\n\nSet the parameters of block. When f is provided, set parameters of block to the value in collection mapped by f. iter can be an iterator or a symbol, the symbol can be :zero, :random.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoAPI.subblocks-Tuple{AbstractBlock}","page":"Blocks","title":"YaoAPI.subblocks","text":"subblocks(x)\n\nReturns an iterator of the sub-blocks of a composite block. Default is empty.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.Rx-Tuple{Any}","page":"Blocks","title":"YaoBlocks.Rx","text":"Rx(theta)\n\nReturn a RotationGate on X axis.\n\nExample\n\njulia> Rx(0.1)\nrot(X, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.Ry-Tuple{Any}","page":"Blocks","title":"YaoBlocks.Ry","text":"Ry(theta)\n\nReturn a RotationGate on Y axis.\n\nExample\n\njulia> Ry(0.1)\nrot(Y, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.Rz-Tuple{Any}","page":"Blocks","title":"YaoBlocks.Rz","text":"Rz(theta)\n\nReturn a RotationGate on Z axis.\n\nExample\n\njulia> Rz(0.1)\nrot(Z, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.apply-Union{Tuple{D}, Tuple{AbstractRegister{D}, Any}} where D","page":"Blocks","title":"YaoBlocks.apply","text":"apply(register, block)\n\nThe non-inplace version of applying a block (of quantum circuit) to a quantum register. Check apply! for the faster inplace version.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.applymatrix-Tuple{Any, AbstractBlock}","page":"Blocks","title":"YaoBlocks.applymatrix","text":"applymatrix(g::AbstractBlock) -> Matrix\n\nTransform the apply! function of specific block to dense matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.cache","page":"Blocks","title":"YaoBlocks.cache","text":"cache(x[, level=1; recursive=false])\n\nCreate a CachedBlock with given block x, which will cache the matrix of x for the first time it calls mat, and use the cached matrix in the following calculations.\n\nExamples\n\njulia> cache(control(3, 1, 2=>X))\nnqubits: 3\n[cached] control(1)\n   └─ (2,) X\n\n\njulia> chain(cache(control(3, 1, 2=>X)), repeat(H))\nnqubits: 3\nchain\n├─ [cached] control(1)\n│     └─ (2,) X\n└─ repeat on (1, 2, 3)\n   └─ H\n\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.cache_key-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.cache_key","text":"cache_key(block)\n\nReturns the key that identify the matrix cache of this block. By default, we use the returns of parameters as its key.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.cache_type-Tuple{Type{<:AbstractBlock}}","page":"Blocks","title":"YaoBlocks.cache_type","text":"cache_type(::Type) -> DataType\n\nReturn the element type that a CacheFragment will use.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.chain-Tuple{Int64}","page":"Blocks","title":"YaoBlocks.chain","text":"chain(n)\n\nReturn an empty ChainBlock which can be used like a list of blocks.\n\nExamples\n\njulia> chain(2)\nnqubits: 2\nchain\n\n\njulia> chain(2; nlevel=3)\nnqudits: 2\nchain\n\n\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.chain-Tuple{}","page":"Blocks","title":"YaoBlocks.chain","text":"chain()\n\nReturn an lambda n->chain(n).\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.chain-Union{Tuple{Vararg{AbstractBlock{D}}}, Tuple{D}} where D","page":"Blocks","title":"YaoBlocks.chain","text":"chain(blocks...) -> ChainBlock\nchain(n) -> ChainBlock\n\nReturn a ChainBlock which chains a list of blocks with the same number of qudits. Let G_i be a sequence of n-qudit blocks, the matrix representation of block chain(G_1, G_2, ..., G_m) is\n\nG_m G_m-1ldots G_1\n\nIt is almost equivalent to matrix multiplication except the order is reversed. We make its order different from regular matrix multiplication because quantum circuits can be represented more naturally in this form.\n\nExamples\n\njulia> chain(X, Y, Z)\nnqubits: 1\nchain\n├─ X\n├─ Y\n└─ Z\n\njulia> chain(2, put(1=>X), put(2=>Y), cnot(2, 1))\nnqubits: 2\nchain\n├─ put on (1)\n│  └─ X\n├─ put on (2)\n│  └─ Y\n└─ control(2)\n   └─ (1,) X\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.chmeasureoperator-Union{Tuple{D}, Tuple{Measure{D, K} where K, AbstractBlock}} where D","page":"Blocks","title":"YaoBlocks.chmeasureoperator","text":"chmeasureoperator(m::Measure, op::AbstractBlock)\n\nchange the measuring operator. It will also discard existing measuring results.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.cleanup-Tuple{EntryTable}","page":"Blocks","title":"YaoBlocks.cleanup","text":"cleanup(entries::EntryTable; zero_threshold=0.0)\n\nClean up the entry table by 1) sort entries, 2) merge items and 3) clean up zeros. Any value with amplitude ≤ zero_threshold will be regarded as zero.\n\njulia> et = EntryTable([bit\"000\",bit\"011\",bit\"101\",bit\"101\",bit\"011\",bit\"110\",bit\"110\",bit\"011\",], [1.0 + 0.0im,-1, 1,1,1,-1,1,1,-1])\nEntryTable{DitStr{2, 3, Int64}, ComplexF64}:\n  000 ₍₂₎   1.0 + 0.0im\n  011 ₍₂₎   -1.0 + 0.0im\n  101 ₍₂₎   1.0 + 0.0im\n  101 ₍₂₎   1.0 + 0.0im\n  011 ₍₂₎   1.0 + 0.0im\n  110 ₍₂₎   -1.0 + 0.0im\n  110 ₍₂₎   1.0 + 0.0im\n  011 ₍₂₎   1.0 + 0.0im\n\n\njulia> cleanup(et)\nEntryTable{DitStr{2, 3, Int64}, ComplexF64}:\n  000 ₍₂₎   1.0 + 0.0im\n  011 ₍₂₎   1.0 + 0.0im\n  101 ₍₂₎   2.0 + 0.0im\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.cnot-Tuple{Int64, Any, Int64}","page":"Blocks","title":"YaoBlocks.cnot","text":"cnot([n, ]ctrl_locs, location)\n\nReturn a speical ControlBlock, aka CNOT gate with number of active qubits n and locs of control qubits ctrl_locs, and location of X gate.\n\nExamples\n\njulia> cnot(3, (2, 3), 1)\nnqubits: 3\ncontrol(2, 3)\n└─ (1,) X\n\njulia> cnot(2, 1)\n(n -> cnot(n, 2, 1))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.collect_blocks-Union{Tuple{T}, Tuple{Type{T}, AbstractBlock}} where T<:AbstractBlock","page":"Blocks","title":"YaoBlocks.collect_blocks","text":"collect_blocks(block_type, root)\n\nReturn a ChainBlock with all block of block_type in root.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.control-Tuple{Any, Pair}","page":"Blocks","title":"YaoBlocks.control","text":"control(ctrl_locs, target) -> f(n)\n\nReturn a lambda that takes the number of total active qubits as input. See also control.\n\nExamples\n\njulia> control((2, 3), 1=>X)\n(n -> control(n, (2, 3), 1 => X))\n\njulia> control(2, 1=>X)\n(n -> control(n, 2, 1 => X))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.control-Tuple{Int64, Any, Pair}","page":"Blocks","title":"YaoBlocks.control","text":"control(n, ctrl_locs, locations => subblock)\n\nReturn a n-qubit ControlBlock, where the control locations ctrl_locs and the subblock locations in the third argument can be an integer, a tuple or a range, and the size of the subblock should match the length of locations. Let I be the 2 times 2 identity matrix, G be a 2 times 2 subblock, P_0=0ranglelangle 0 and P_1=1ranglelangle 1 be two single qubit projection operators to subspace 0rangle and 1rangle, i and j be two integers that ij. The matrix representation of control(n, i, j=>G) is\n\nbeginalign\nI^otimes n-i P_0 otimes I^otimes i-j-1 otimes Iotimes I^otimes j-1\n+\n I^otimes n-i P_1 otimes I^otimes i-j-1 otimes Gotimes I^otimes j-1\nendalign\n\nThe multi-controlled multi-qubit controlled block is more complicated, it means apply the gate when control qubits are all ones. Each control location can take a negative sign to represent the inverse control, meaning only when this qubit is 0, the controlled gate is applied.\n\nExamples\n\njulia> control(4, (1, 2), 3=>X)\nnqubits: 4\ncontrol(1, 2)\n└─ (3,) X\n\njulia> control(4, 1, 3=>X)\nnqubits: 4\ncontrol(1)\n└─ (3,) X\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.cunmat","page":"Blocks","title":"YaoBlocks.cunmat","text":"cunmat(nbit::Int, cbits::NTuple{C, Int}, cvals::NTuple{C, Int}, U0::AbstractMatrix, locs::NTuple{M, Int}) where {C, M} -> AbstractMatrix\n\ncontrol-unitary matrix\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.cz-Tuple{Int64, Any, Int64}","page":"Blocks","title":"YaoBlocks.cz","text":"cz([n, ]ctrl_locs, location)\n\nReturn a special ControlBlock, aka CZ gate with number of active qubits n and locs of control qubits ctrl_locs, and location of Z gate. See also cnot.\n\nExamples\n\njulia> cz(2, 1, 2)\nnqubits: 2\ncontrol(1)\n└─ (2,) Z\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.decode_sign-Union{Tuple{NTuple{N, Int64}}, Tuple{N}} where N","page":"Blocks","title":"YaoBlocks.decode_sign","text":"decode_sign(ctrls...)\n\nDecode signs into control sequence on control or inversed control.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.dispatch-Tuple{Union{Nothing, Function}, AbstractBlock, Any}","page":"Blocks","title":"YaoBlocks.dispatch","text":"dispatch(x::AbstractBlock, collection)\n\nDispatch parameters in collection to block tree x, the generic non-inplace version.\n\nnote: Note\nit will try to dispatch the parameters in collection first.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.dump_gate","page":"Blocks","title":"YaoBlocks.dump_gate","text":"dump_gate(blk::AbstractBlock) -> Expr\n\nconvert a gate to a YaoScript expression for serization. The fallback is GateTypeName(fields...)\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.eigenbasis-Union{Tuple{AbstractBlock{D}}, Tuple{D}} where D","page":"Blocks","title":"YaoBlocks.eigenbasis","text":"eigenbasis(op::AbstractBlock)\n\nReturn the eigenvalue and eigenvectors of target operator. By applying eigenvector' to target state, one can swith the basis to the eigenbasis of this operator. However, eigenvalues does not have a specific form.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.gate_expr-Union{Tuple{G}, Tuple{Val{G}, Any, Any}} where G","page":"Blocks","title":"YaoBlocks.gate_expr","text":"gate_expr(::Val{G}, args, info)\n\nObtain the gate constructior from its YaoScript expression. G is a symbol for the gate type, the default constructor is G(args...). info contains the informations about the number of qubit and Yao version.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.getcol-Tuple{LuxurySparse.SDSparseMatrixCSC, Int64}","page":"Blocks","title":"YaoBlocks.getcol","text":"getcol(csc::SDparseMatrixCSC, icol::Int) -> (View, View)\n\nget specific col of a CSC matrix, returns a slice of (rowval, nzval)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.igate-Tuple{Int64}","page":"Blocks","title":"YaoBlocks.igate","text":"igate(n::Int; nlevel=2)\n\nThe constructor for IdentityGate. Let I_d be a d times d identity matrix, igate(n; nlevel=d) is defined as I_d^otimes n.\n\nExamples\n\njulia> igate(2)\nigate(2)\n\njulia> igate(2; nlevel=3)\nigate(2;nlevel=3)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.isclean-Tuple{EntryTable}","page":"Blocks","title":"YaoBlocks.isclean","text":"isclean(entries::EntryTable; zero_threshold=0.0)\n\nReturn true if the entries are ordered, unique and amplitudes are nonzero. Any value with amplitude ≤ zero_threshold will be regarded as zero.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.isnoisy-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.isnoisy","text":"isnoisy(block::AbstractBlock)\n\nCheck if a circuit contains any noisy channel.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.map_address","page":"Blocks","title":"YaoBlocks.map_address","text":"map_address(block::AbstractBlock, info::AddressInfo) -> AbstractBlock\n\nmap the locations in block to target locations.\n\nExample\n\nmap_address can be used to embed a sub-circuit to a larger one.\n\njulia> c = chain(5, repeat(H, 1:5), put(2=>X), kron(1=>X, 3=>Y))\nnqubits: 5\nchain\n├─ repeat on (1, 2, 3, 4, 5)\n│  └─ H\n├─ put on (2)\n│  └─ X\n└─ kron\n   ├─ 1=>X\n   └─ 3=>Y\n\n\njulia> map_address(c, AddressInfo(10, [6,7,8,9,10]))\nnqubits: 10\nchain\n├─ repeat on (6, 7, 8, 9, 10)\n│  └─ H\n├─ put on (7)\n│  └─ X\n└─ kron\n   ├─ 6=>X\n   └─ 8=>Y\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.matblock-Tuple{AbstractMatrix}","page":"Blocks","title":"YaoBlocks.matblock","text":"matblock(mat_or_block; nlevel=2, tag=\"matblock(...)\")\n\nCreate a GeneralMatrixBlock with a matrix m.\n\nExamples\n\njulia> matblock(ComplexF64[0 1;1 0])\nmatblock(...)\n\n!!!warn\n\nInstead of converting it to the default data type `ComplexF64`,\nthis will return its contained matrix when calling `mat`.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.noisy_simulation-Tuple{ArrayReg, AbstractBlock}","page":"Blocks","title":"YaoBlocks.noisy_simulation","text":"noisy_simulation(reg::ArrayReg, circuit::AbstractBlock)\n\nSimulate a circuit with noise.\n\nArguments\n\nreg::ArrayReg: the initial state of the system.\ncircuit::AbstractBlock: the circuit to simulate.\n\nReturns\n\nDensityMatrix: the final state of the system.\n\nExamples\n\nAdd noise after each single-qubit gate and simulate the circuit.\n\njulia> circ = Optimise.replace_block(chain(2, put(1=>X), control(2, 1=>X))) do block\n           n = nqubits(block)\n           if block isa PutBlock && length(block.locs) == 1\n               return chain(block, put(n, block.locs => quantum_channel(BitFlipError(0.1))))  # add noise after each single-qubit gate\n           elseif block isa ControlBlock && length(block.ctrl_locs) == 1 && length(block.locs) == 1\n               return chain(block, put(n, (block.ctrl_locs..., block.locs...) => kron(quantum_channel(BitFlipError(0.1)), quantum_channel(BitFlipError(0.1)))))  # add noise after each control gate\n           else\n               return block\n           end\n       end\nnqubits: 2\nchain\n├─ chain\n│  ├─ put on (1)\n│  │  └─ X\n│  └─ put on (1)\n│     └─ mixed_unitary_channel\n│        ├─ [0.9] I2\n│        └─ [0.1] X\n└─ chain\n   ├─ control(2)\n   │  └─ (1,) X\n   └─ put on (2, 1)\n      └─ mixed_unitary_channel\n         ├─ [0.81] kron\n         │  ├─ 1=>I2\n         │  └─ 2=>I2\n         ├─ [0.09000000000000001] kron\n         │  ├─ 1=>I2\n         │  └─ 2=>X\n         ├─ [0.09000000000000001] kron\n         │  ├─ 1=>X\n         │  └─ 2=>I2\n         └─ [0.010000000000000002] kron\n            ├─ 1=>X\n            └─ 2=>X\n\njulia> noisy_simulation(zero_state(2), circ)\nDensityMatrix{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.num_nonzero","page":"Blocks","title":"YaoBlocks.num_nonzero","text":"num_nonzero(nbits, nctrls, U, [N])\n\nReturn number of nonzero entries of the matrix form of control-U gate. nbits is the number of qubits, and nctrls is the number of control qubits.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.parameters!-Tuple{Any, AbstractBlock}","page":"Blocks","title":"YaoBlocks.parameters!","text":"parameters!(out, block)\n\nAppend all the parameters contained in block tree with given root block to out.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.parameters_range-Tuple{AbstractBlock}","page":"Blocks","title":"YaoBlocks.parameters_range","text":"parameters_range(block)\n\nReturn the range of real parameters present in block.\n\nnote: Note\nIt may not be the case that length(parameters_range(block)) == nparameters(block).\n\nExample\n\njulia> YaoBlocks.parameters_range(RotationGate(X, 0.1))\n1-element Vector{Tuple{Float64, Float64}}:\n (0.0, 6.283185307179586)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.parse_block","page":"Blocks","title":"YaoBlocks.parse_block","text":"parse_block(n, ex)\n\nThis function parse the julia object ex to a quantum block, it defines the syntax of high level interfaces. ex can be a function takes number of qubits n as input or it can be a pair.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.paulipropagation2yao-Tuple","page":"Blocks","title":"YaoBlocks.paulipropagation2yao","text":"paulipropagation2yao(n::Int, circ::AbstractVector{Gate}, thetas::AbstractVector)\npaulipropagation2yao(pc::PauliCircuit)\n\nConvert a Pauli propagation circuit to a Yao circuit. You must using PauliPropagation before using this function.\n\nArguments\n\nn::Int: Number of qubits.\ncirc::AbstractVector{Gate}: Pauli propagation circuit.\nthetas::AbstractVector: Vector of parameters.\n\nOr:\n\npc::PauliCircuit: A PauliCircuit intermediate representation.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.phase-Tuple{Real}","page":"Blocks","title":"YaoBlocks.phase","text":"phase(theta)\n\nReturns a global phase gate. Defined with following matrix form:\n\ne^iθ I\n\nExamples\n\nYou can create a global phase gate with a phase (a real number).\n\njulia> phase(0.1)\nphase(0.1)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.popdispatch!-Tuple{AbstractBlock, Vector}","page":"Blocks","title":"YaoBlocks.popdispatch!","text":"popdispatch!(block, list)\n\nPop the first nparameters parameters of list, then dispatch them to the block tree block. See also dispatch!.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.popdispatch!-Tuple{Function, AbstractBlock, Vector}","page":"Blocks","title":"YaoBlocks.popdispatch!","text":"popdispatch!(f, block, list)\n\nPop the first nparameters parameters of list, map them with a function f, then dispatch them to the block tree block. See also dispatch!.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.postwalk-Tuple{Union{Function, Type}, AbstractBlock}","page":"Blocks","title":"YaoBlocks.postwalk","text":"postwalk(f, src::AbstractBlock)\n\nWalk the tree and call f after the children are visited.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.prewalk-Tuple{Union{Function, Type}, AbstractBlock}","page":"Blocks","title":"YaoBlocks.prewalk","text":"prewalk(f, src::AbstractBlock)\n\nWalk the tree and call f once the node is visited.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.print_annotation-Tuple{IO, Vararg{Any, 4}}","page":"Blocks","title":"YaoBlocks.print_annotation","text":"print_annotation(io, root, node, child, k)\n\nPrint the annotation of k-th child of node, aka the k-th element of subblocks(node).\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.print_prefix-Tuple{IO, Any, Any, Any}","page":"Blocks","title":"YaoBlocks.print_prefix","text":"print_prefix(io, depth, charset, active_levels)\n\nprint prefix of a tree node in a single line.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.print_subtypetree","page":"Blocks","title":"YaoBlocks.print_subtypetree","text":"print_subtypetree(::Type[, level=1, indent=4])\n\nPrint subtype tree, level specify the depth of the tree.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.print_title-Tuple{IO, AbstractBlock}","page":"Blocks","title":"YaoBlocks.print_title","text":"print_title(io, block)\n\nPrint the title of given block of an AbstractBlock.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.print_tree","page":"Blocks","title":"YaoBlocks.print_tree","text":"print_tree(io, root, node[, depth=1, active_levels=()]; kwargs...)\n\nPrint the block tree.\n\nKeywords\n\nmaxdepth: max tree depth to print\ncharset: default is ('├','└','│','─'). See also YaoBlocks.BlockTreeCharSet.\ntitle: control whether to print the title, true or false, default is true\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.print_tree-Tuple{Any}","page":"Blocks","title":"YaoBlocks.print_tree","text":"print_tree([io=stdout], root)\n\nPrint the block tree.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.projection-Tuple{AbstractMatrix, AbstractMatrix}","page":"Blocks","title":"YaoBlocks.projection","text":"projection(y::AbstractMatrix, op::AbstractMatrix) -> typeof(y)\n\nProject op to sparse matrix with same sparsity as y.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.projector-Tuple{AbstractArrayReg}","page":"Blocks","title":"YaoBlocks.projector","text":"projector(v::AbstractArrayReg) -> Projector\n\n\nCreate a Projector with an quantum state vector v.\n\nExample\n\njulia> projector(rand_state(3))\n|s⟩⟨s|, nqudits = 3\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.projector-Tuple{Any}","page":"Blocks","title":"YaoBlocks.projector","text":"projector(x)\n\nReturn projector on 0 or projector on 1.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.pswap-Tuple{Int64, Int64, Int64, Real}","page":"Blocks","title":"YaoBlocks.pswap","text":"pswap(n::Int, i::Int, j::Int, α::Real)\npswap(i::Int, j::Int, α::Real) -> f(n)\n\nparametrized swap gate.\n\nExamples\n\njulia> pswap(2, 1, 2, 0.1)\nnqubits: 2\nput on (1, 2)\n└─ rot(SWAP, 0.1)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.put-Tuple{Pair}","page":"Blocks","title":"YaoBlocks.put","text":"put(pair) -> f(n)\n\nLazy curried version of put.\n\nExamples\n\njulia> put(1=>X)\n(n -> put(n, 1 => X))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.put-Union{Tuple{M}, Tuple{Int64, Pair{NTuple{M, Int64}, <:AbstractBlock}}} where M","page":"Blocks","title":"YaoBlocks.put","text":"put(n::Int, locations => subblock) => PutBlock\n\nCreate a n-qudit PutBlock. The second argument is a pair of locations and subblock, where the locations can be a tuple, an integer or a range and the subblock size should match the length of locations. Let I be a 2times 2 identity matrix and G be a 2times 2 matrix, the matrix representation of put(n, i=>G) is defined as\n\nI^otimes n-i otimes G otimes I^otimes i-1\n\nFor multiple locations, the expression can be complicated,  which corresponds to the matrix representation of multi-qubit gate applied on n-qubit space in quantum computing.\n\nExamples\n\njulia> put(4, 1=>X)\nnqubits: 4\nput on (1)\n└─ X\n\nIf you want to put a multi-qubit gate on specific locations, you need to write down all possible locations.\n\njulia> put(4, (1, 3)=>kron(X, Y))\nnqubits: 4\nput on (1, 3)\n└─ kron\n   ├─ 1=>X\n   └─ 2=>Y\n\nThe outter locations creates a scope which make it seems to be a contiguous two qubits for the block inside PutBlock.\n\ntips: Tips\nIt is better to use subroutine instead of put for large blocks, since put will use the matrix of its contents directly instead of making use of what's in it. put is more efficient for small blocks.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.quantum_channel","page":"Blocks","title":"YaoBlocks.quantum_channel","text":"quantum_channel(error::AbstractErrorType)\n\nConvert an error type to a quantum channel. The output type can be KrausChannel, MixedUnitaryChannel.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.rand_hermitian-Tuple{Int64}","page":"Blocks","title":"YaoBlocks.rand_hermitian","text":"rand_hermitian([T=ComplexF64], N::Int) -> Matrix\n\nCreate a random hermitian matrix.\n\njulia> ishermitian(rand_hermitian(2))\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.rand_unitary-Tuple{Int64}","page":"Blocks","title":"YaoBlocks.rand_unitary","text":"rand_unitary([T=ComplexF64], N::Int) -> Matrix\n\nCreate a random unitary matrix.\n\nExamples\n\njulia> isunitary(rand_unitary(2))\ntrue\n\njulia> eltype(rand_unitary(ComplexF32, 2))\nComplexF32 (alias for Complex{Float32})\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.reflect","page":"Blocks","title":"YaoBlocks.reflect","text":"reflect(\n    v::AbstractArrayReg\n) -> ReflectGate{D, T, Irrational{:π}, AT} where {D, T, AT<:(AbstractArrayReg{D, T})}\nreflect(\n    v::AbstractArrayReg,\n    θ::Real\n) -> ReflectGate{_A, T, Tt, AT} where {_A, Tt<:Real, T, AT<:(AbstractArrayReg{_A, T})}\n\n\nCreate a ReflectGate with respect to an quantum state vector v.\n\nExample\n\njulia> reflect(rand_state(3))\nTime Evolution Δt = π, tol = 1.0e-7\n|s⟩⟨s|, nqudits = 3\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.rmlines-Tuple{Expr}","page":"Blocks","title":"YaoBlocks.rmlines","text":"rmlines(ex)\n\nRemove LineNumberNode from an Expr.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.rot-Tuple{AbstractBlock, Any}","page":"Blocks","title":"YaoBlocks.rot","text":"rot(U, theta)\n\nReturn a RotationGate on U axis.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.sandwich-Tuple{AbstractArrayReg, AbstractBlock, AbstractArrayReg}","page":"Blocks","title":"YaoBlocks.sandwich","text":"sandwich(bra::AbstractRegister, op::AbstractBlock, ket::AbstracRegister) -> Complex\n\nCompute the sandwich function ⟨bra|op|ket⟩.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.setcol!-Tuple{SparseMatrixCSC, Int64, AbstractVector, Any}","page":"Blocks","title":"YaoBlocks.setcol!","text":"setcol!(csc::SparseMatrixCSC, icol::Int, rowval::AbstractVector, nzval) -> SparseMatrixCSC\n\nset specific col of a CSC matrix\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.setiparams","page":"Blocks","title":"YaoBlocks.setiparams","text":"setiparams([f], block, itr)\nsetiparams([f], block, params...)\n\nSet the parameters of block, the non-inplace version. When f is provided, set parameters of block to the value in collection mapped by f. iter can be an iterator or a symbol, the symbol can be :zero, :random.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.shift-Tuple{Any}","page":"Blocks","title":"YaoBlocks.shift","text":"shift(θ)\n\nCreate a ShiftGate with phase θ.\n\nbeginpmatrix\n1  0\n0  e^itheta\nendpmatrix\n\nExamples\n\njulia> shift(0.1)\nshift(0.1)\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.simple_commute_eachother-Union{Tuple{Vector{<:AbstractBlock{D}}}, Tuple{D}} where D","page":"Blocks","title":"YaoBlocks.simple_commute_eachother","text":"Return true if operators commute to each other.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.sprand_hermitian-Tuple{Int64, Any}","page":"Blocks","title":"YaoBlocks.sprand_hermitian","text":"sprand_hermitian([T=ComplexF64], N, density)\n\nCreate a sparse random hermitian matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.sprand_unitary-Tuple{Int64, Real}","page":"Blocks","title":"YaoBlocks.sprand_unitary","text":"sprand_unitary([T=ComplexF64], N::Int, density) -> SparseMatrixCSC\n\nCreate a random sparse unitary matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.subroutine-Tuple{AbstractBlock, Any}","page":"Blocks","title":"YaoBlocks.subroutine","text":"subroutine(block, locs) -> f(n)\n\nLazy curried version of subroutine.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.subroutine-Tuple{Int64, AbstractBlock, Any}","page":"Blocks","title":"YaoBlocks.subroutine","text":"subroutine(n, block, locs)\n\nCreate a n-qudit Subroutine block, where the subblock is a subprogram of size m, and locs is a tuple or range of length m. It runs a quantum subprogram with smaller size on a subset of locations. While its mathematical definition is the same as the put block, while it is more suited for running a larger chunk of circuit.\n\nExamples\n\nSubroutine is equivalent to put a block on given position mathematically, but more efficient and convenient for large blocks.\n\njulia> r = rand_state(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> apply!(copy(r), subroutine(X, 1)) ≈ apply!(copy(r), put(1=>X))\ntrue\n\nIt works for in-contigious locs as well\n\njulia> r = rand_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> cc = subroutine(4, kron(X, Y), (1, 3))\nnqubits: 4\nSubroutine: (1, 3)\n└─ kron\n   ├─ 1=>X\n   └─ 2=>Y\n\njulia> pp = chain(4, put(1=>X), put(3=>Y))\nnqubits: 4\nchain\n├─ put on (1)\n│  └─ X\n└─ put on (3)\n   └─ Y\n\njulia> apply!(copy(r), cc) ≈ apply!(copy(r), pp)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.swap-Tuple{Int64, Int64, Int64}","page":"Blocks","title":"YaoBlocks.swap","text":"swap(n, loc1, loc2)\n\nCreate a n-qubit Swap gate which swap loc1 and loc2.\n\nExamples\n\njulia> swap(4, 1, 2)\nnqubits: 4\nput on (1, 2)\n└─ SWAP\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.swap-Tuple{Int64, Int64}","page":"Blocks","title":"YaoBlocks.swap","text":"swap(loc1, loc2) -> f(n)\n\nCreate a lambda that takes the total number of active qubits as input. Lazy curried version of swap(n, loc1, loc2). See also Swap.\n\nExamples\n\njulia> swap(1, 2)\n(n -> swap(n, 1, 2))\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.time_evolve-Tuple{AbstractBlock, Any}","page":"Blocks","title":"YaoBlocks.time_evolve","text":"time_evolve(H, dt[; tol=1e-7, check_hermicity=true])\n\nCreate a TimeEvolution block with Hamiltonian H and time step dt. The TimeEvolution block will use Krylove based expv to calculate time propagation. TimeEvolution block can also be used for imaginary time evolution if dt is complex. Let H be a hamiltonian and t be a time, the matrix representation of time_evolve(H, t) is e^-iHt.\n\nArguments\n\nH the hamiltonian represented as an AbstractBlock.\ndt: the evolution duration (start time is zero).\n\nKeyword Arguments\n\ntol::Real=1e-7: error tolerance.\ncheck_hermicity=true: check hermicity or not.\n\nExamples\n\njulia> time_evolve(kron(2, 1=>X, 2=>X), 0.1)\nTime Evolution Δt = 0.1, tol = 1.0e-7\nkron\n├─ 1=>X\n└─ 2=>X\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.u1ij!","page":"Blocks","title":"YaoBlocks.u1ij!","text":"u1ij!(target, i, j, a, b, c, d)\n\nsingle u1 matrix into a target matrix.\n\nnote: Note\nFor coo, we take an additional parameter     * ptr: starting position to store new data.\n\n\n\n\n\n","category":"function"},{"location":"man/blocks.html#YaoBlocks.unmat-Tuple{Val{2}, Int64, AbstractMatrix, NTuple{N, T} where {N, T}}","page":"Blocks","title":"YaoBlocks.unmat","text":"unmat(::Val{D}, nbit::Int, U::AbstractMatrix, locs::NTuple) -> AbstractMatrix\n\nReturn the matrix representation of putting matrix at locs.\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.yao2paulipropagation-Tuple","page":"Blocks","title":"YaoBlocks.yao2paulipropagation","text":"yao2paulipropagation(circ::ChainBlock; observable)\n\nConvert a Yao circuit to a Pauli propagation circuit representation. You must using PauliPropagation before using this function.\n\nArguments\n\ncirc::ChainBlock: Yao circuit in the form of a chain of basic gates.\n\nKeyword Arguments\n\nobservable: A Yao block specifying the observable to measure (required). Must be a sum of Pauli strings, e.g. kron(5, 2=>X, 3=>X) + 2.0 * kron(5, 1=>Z). Will be converted to a PauliSum.\n\nReturns\n\nPauliPropagationCircuit: An intermediate representation that can be evaluated with propagate(pc).\n\n\n\n\n\n","category":"method"},{"location":"man/blocks.html#YaoBlocks.@yao_str-Tuple{String}","page":"Blocks","title":"YaoBlocks.@yao_str","text":"@yao_str\nyao\"...\"\n\nThe mark up language for quantum circuit.\n\n\n\n\n\n","category":"macro"},{"location":"man/plot.html#Quantum-Circuit-Visualization","page":"Quantum Circuit Visualization","title":"Quantum Circuit Visualization","text":"YaoPlots is the Quantum circuit visualization component for Yao.","category":"section"},{"location":"man/plot.html#Examples","page":"Quantum Circuit Visualization","title":"Examples","text":"","category":"section"},{"location":"man/plot.html#Example-1:-Visualize-a-QBIR-define-in-Yao","page":"Quantum Circuit Visualization","title":"Example 1: Visualize a QBIR define in Yao","text":"using Yao.EasyBuild, YaoPlots\n\n# show a qft circuit\nvizcircuit(qft_circuit(5))\n\nIf you are using a Pluto/Jupyter notebook, Atom/VSCode editor, you should see the above image in your plotting panel.","category":"section"},{"location":"man/plot.html#Example-2:-Visualize-a-single-qubit","page":"Quantum Circuit Visualization","title":"Example 2: Visualize a single qubit","text":"using YaoPlots, Yao\n\nreg = zero_state(1) |> Rx(π/8) |> Rx(π/8)\nrho = density_matrix(ghz_state(2), 1)\n\nbloch_sphere(\"|ψ⟩\"=>reg, \"ρ\"=>rho; show_projection_lines=true)\n\nSee more examples.","category":"section"},{"location":"man/plot.html#Adjusting-the-plot-attributes","page":"Quantum Circuit Visualization","title":"Adjusting the plot attributes","text":"Various attributes of the visualizations can be altered.  The plot can be modified, if we change the following attributes\n\nYaoPlots.CircuitStyles.linecolor[] for line color, default value being \"#000000\" (black color)\nYaoPlots.CircuitStyles.gate_bgcolor[] for background color of square blocks, the default value being \"#FFFFFF\" (white color)\nYaoPlots.CircuitStyles.textcolor[] for text color, default value being \"#000000\nYaoPlots.CircuitStyles.lw[] for line width, default value being 1 (pt)\nYaoPlots.CircuitStyles.textsize[] for text size, default value being 16 (pt)\nYaoPlots.CircuitStyles.paramtextsize[] for parameter text size, for parameterized gates, default value being 10 (pt)\n\nFor example,\n\nusing YaoPlots, Yao\nYaoPlots.CircuitStyles.linecolor[] = \"pink\" \nYaoPlots.CircuitStyles.gate_bgcolor[] = \"yellow\" \nYaoPlots.CircuitStyles.textcolor[] = \"#000080\" # the navy blue color\nYaoPlots.CircuitStyles.fontfamily[] = \"JuliaMono\"\nYaoPlots.CircuitStyles.lw[] = 2.5\nYaoPlots.CircuitStyles.textsize[] = 13\nYaoPlots.CircuitStyles.paramtextsize[] = 8\n\t\t\nvizcircuit(chain(3, put(1=>X), repeat(3, H), put(2=>Y), repeat(3, Rx(π/2))))","category":"section"},{"location":"man/plot.html#Circuit-Visualization","page":"Quantum Circuit Visualization","title":"Circuit Visualization","text":"","category":"section"},{"location":"man/plot.html#Bloch-Sphere-Visualization","page":"Quantum Circuit Visualization","title":"Bloch Sphere Visualization","text":"","category":"section"},{"location":"man/plot.html#Themes","page":"Quantum Circuit Visualization","title":"Themes","text":"","category":"section"},{"location":"man/plot.html#YaoPlots.vizcircuit","page":"Quantum Circuit Visualization","title":"YaoPlots.vizcircuit","text":"vizcircuit(circuit; w_depth=0.85, w_line=0.75, format=:svg, filename=nothing,\n    show_ending_bar=false, starting_texts=nothing, starting_offset=-0.3,\n    ending_texts=nothing, ending_offset=0.3, padding=10)\n\nVisualize a Yao quantum circuit.\n\nKeyword Arguments\n\nw_depth is the circuit column width.\nw_line is the circuit row width.\nformat can be :svg, :png or :pdf.\nfilename can be \"*.svg\", \"*.png\", \"*.pdf\" or nothing (not saving to a file).\nstarting_texts and ending_texts are texts shown before and after the circuit.\nstarting_offset and end_offset are offsets (real values) for starting and ending texts.\nshow_ending_bar is a boolean switch to show ending bar.\npadding is the padding between the circuit and the canvas, in pixels.\n\nStyles\n\nTo change the gates styles like colors and lines, please modify the constants in submodule CircuitStyles. They are defined as:\n\nCircuitStyles.unit = Ref(60)                      # number of points in a unit\nCircuitStyles.r = Ref(0.2)                        # size of nodes\nCircuitStyles.lw = Ref(1.0)                       # line width\nCircuitStyles.textsize = Ref(16.0)                # text size\nCircuitStyles.paramtextsize = Ref(10.0)           # text size (longer texts)\nCircuitStyles.fontfamily = Ref(\"JuliaMono\")       # font family\nCircuitStyles.linecolor = Ref(\"#000000\")          # line color\nCircuitStyles.gate_bgcolor = Ref(\"transparent\")   # gate background color\nCircuitStyles.textcolor = Ref(\"#000000\")          # text color\n\n\n\n\n\n","category":"function"},{"location":"man/plot.html#YaoPlots.plot","page":"Quantum Circuit Visualization","title":"YaoPlots.plot","text":"An alias of vizcircuit\n\n\n\n\n\n","category":"function"},{"location":"man/plot.html#YaoPlots.CircuitStyles","page":"Quantum Circuit Visualization","title":"YaoPlots.CircuitStyles","text":"CircuitStyles\n\nA module to define the styles of the circuit visualization. To change the styles, please modify the variables in this module, e.g.\n\njulia> using YaoPlots\n\njulia> YaoPlots.CircuitStyles.unit[] = 40\n40\n\nStyle variables\n\nSizes\n\nunit is the number of pixels in a unit.\nr is the size of nodes.\nlw is the line width.\n\nTexts\n\ntextsize is the text size.\nparamtextsize is the text size for longer texts.\nfontfamily is the font family.\n\nColors\n\nlinecolor is the line color.\ngate_bgcolor is the gate background color.\ntextcolor is the text color.\n\n\n\n\n\n","category":"module"},{"location":"man/plot.html#YaoPlots.bloch_sphere","page":"Quantum Circuit Visualization","title":"YaoPlots.bloch_sphere","text":"bloch_sphere(\n    states...;\n    textsize,\n    color,\n    drawing_size,\n    offset_x,\n    offset_y,\n    filename,\n    format,\n    fontfamily,\n    background_color,\n    lw,\n    eye_point,\n    extra_kwargs...\n) -> Luxor.Drawing\n\n\nDraw a bloch sphere, with the inputs being a list of string => state pairs, where the string is a label for the state and a state can be a complex vector of size 2, a Yao register or DensityMatrix. If you want to get a raw drawing, use draw_bloch_sphere instead.\n\nKeyword Arguments\n\nNote: The default values can be specified in submodule BlochStyles.\n\ntextsize: the size of the text\ncolor: the color of the drawing\ndrawing_size: the size of the drawing\noffset_x: the offset of the drawing in x direction\noffset_y: the offset of the drawing in y direction\nfilename: the filename of the output file, if not specified, a temporary file will be used\nformat: the format of the output file, if not specified, the format will be inferred from the filename\nfontfamily: the font family of the text\nbackground_color: the background color of the drawing\nlw: the line width of the drawing\neye_point: the eye point of the drawing\nextra_kwargs: extra keyword arguments passed to draw_bloch_sphere\ndot_size: the size of the dot\nball_size: the size of the ball\nshow_projection_lines: whether to show the projection lines\nshow_angle_texts: whether to show the angle texts\nshow_line: whether to show the line\nshow01: whether to show the 0 and 1 states\ncolors: the colors of the states\naxes_lw: the line width of the axes\naxes_textsize: the size of the axes texts\naxes_colors: the colors of the axes\naxes_texts: the texts of the axes\n\nExamples\n\njulia> using YaoPlots, YaoArrayRegister\n\njulia> bloch_sphere(\"|ψ⟩\"=>rand_state(1), \"ρ\"=>density_matrix(rand_state(2), 1));\n\n\n\n\n\n","category":"function"},{"location":"man/plot.html#YaoPlots.BlochStyles","page":"Quantum Circuit Visualization","title":"YaoPlots.BlochStyles","text":"BlochStyles\n\nThe module to define the default styles for bloch sphere drawing. To change the default styles, you can modify the values in this module, e.g.\n\nusing YaoPlots\nYaoPlots.BlochStyles.lw[] = 2.0\n\nStyle variables\n\nGeneric\n\nlw: the line width of the drawing\ntextsize: the size of the text\nfontfamily: the font family of the text\nbackground_color: the background color of the drawing\ncolor: the color of the drawing\n\nSphere\n\nball_size: the size of the ball\ndot_size: the size of the dot\neye_point: the eye point of the drawing\n\nAxis\n\naxes_lw: the line width of the axes\naxes_colors: the colors of the axes\naxes_texts: the texts of the axes, default to [\"x\", \"y\", \"z\"]\n\nState display\n\nshow_projection_lines: whether to show the projection lines\nshow_angle_texts: whether to show the angle texts\nshow_line: whether to show the line\nshow01: whether to show the 0 and 1 states\n\n\n\n\n\n","category":"module"},{"location":"man/plot.html#YaoPlots.darktheme!","page":"Quantum Circuit Visualization","title":"YaoPlots.darktheme!","text":"darktheme!()\n\nChange the default theme to dark.\n\n\n\n\n\n","category":"function"},{"location":"man/plot.html#YaoPlots.lighttheme!","page":"Quantum Circuit Visualization","title":"YaoPlots.lighttheme!","text":"lighttheme!()\n\nChange the default theme to light.\n\n\n\n\n\n","category":"function"},{"location":"man/yao2einsum.html#Tensor-Network-Backend","page":"Tensor Network Backend","title":"Tensor Network Backend","text":"Simulating quantum circuits using tensor networks is a powerful approach that has been extensively studied in quantum computing literature[Markov2008][Pan2022]. The YaoToEinsum package provides a convenient and efficient way to convert Yao circuits into tensor networks, enabling advanced analysis, optimization, and simulation of quantum circuits.","category":"section"},{"location":"man/yao2einsum.html#Overview","page":"Tensor Network Backend","title":"Overview","text":"Tensor networks represent quantum circuits as collections of interconnected tensors, where quantum gates become tensors and quantum states are represented as tensor contractions. This representation offers several advantages:\n\nScalability: Efficient simulation of certain quantum circuits\nFlexibility: Easy manipulation and analysis of quantum operations\nOptimization: Advanced contraction order optimization for better performance","category":"section"},{"location":"man/yao2einsum.html#Basic-Usage","page":"Tensor Network Backend","title":"Basic Usage","text":"","category":"section"},{"location":"man/yao2einsum.html#Converting-Circuits-to-Tensor-Networks","page":"Tensor Network Backend","title":"Converting Circuits to Tensor Networks","text":"The primary function for circuit conversion is:\n\nusing Yao, LuxorGraphPlot\n\nyao2einsum(circuit; initial_state=Dict(), final_state=Dict(), optimizer=TreeSA())\n\nThis function transforms a Yao circuit into a tensor network represented in Einstein summation (einsum) notation, returning a TensorNetwork object.\n\nParameters:\n\ninitial_state: Dictionary specifying the initial quantum state. Unspecified qubits remain as open indices\nfinal_state: Dictionary specifying the final measurement state. Unspecified qubits remain as open indices  \noptimizer: Contraction order optimization algorithm. Default is TreeSA() developed in [Kalachev2021][Liu2023]. For more optimization algorithms, see OMEinsumContractionOrders.jl","category":"section"},{"location":"man/yao2einsum.html#Tutorial:-Quantum-Fourier-Transform-Example","page":"Tensor Network Backend","title":"Tutorial: Quantum Fourier Transform Example","text":"In this tutorial, we demonstrate how to convert a Quantum Fourier Transform (QFT) circuit to a tensor network and use it for several common tasks:\n\nObtaining the matrix representation of the circuit\nComputing probability amplitudes of specific states\nComputing expectation values of observables\nSimulating noisy circuits with density matrices","category":"section"},{"location":"man/yao2einsum.html#Step-1:-Create-the-Circuit","page":"Tensor Network Backend","title":"Step 1: Create the Circuit","text":"First, let's create a 10-qubit Quantum Fourier Transform circuit:\n\nusing Yao, LuxorGraphPlot\nusing Yao.EasyBuild: qft_circuit\n\nn = 4\ncircuit = qft_circuit(n)  # Create a QFT circuit for n qubits","category":"section"},{"location":"man/yao2einsum.html#Case-1:-Matrix-Representation","page":"Tensor Network Backend","title":"Case 1: Matrix Representation","text":"Now we convert the circuit to a tensor network representation:\n\nnetwork = Yao.yao2einsum(circuit)  # Convert circuit to tensor network\nviznet(network)  # Visualize the network structure\n\nThis creates a tensor network where each quantum gate becomes a tensor node, and the connections represent shared indices between tensors.\n\nWe can contract the tensor network to obtain the full matrix representation of the circuit:\n\n# Contract the network and reshape to get the unitary matrix\nmatrix_from_network = reshape(Yao.contract(network), 1<<n, 1<<n)\nmatrix_from_yao = Yao.mat(circuit)\n\n# Verify they are equivalent\nmatrix_from_network ≈ matrix_from_yao","category":"section"},{"location":"man/yao2einsum.html#Case-2:-Computing-Probability-Amplitudes","page":"Tensor Network Backend","title":"Case 2: Computing Probability Amplitudes","text":"For many applications, we're interested in specific probability amplitudes rather than the full matrix. Here we compute the probability amplitude for measuring all qubits in the |0⟩ state after applying the QFT to the |0⟩ state:\n\n# Create a network with fixed initial and final states\nnetwork_with_states = Yao.yao2einsum(circuit;\n    initial_state=Dict([i=>0 for i=1:n]),  # Start in |00...0⟩\n    final_state=Dict([i=>0 for i=1:n]),    # Measure in |00...0⟩ basis\n    optimizer=Yao.YaoToEinsum.TreeSA()\n)\nviznet(network_with_states)\n\n# Contract the network to get the amplitude\namplitude_from_network = Yao.contract(network_with_states)[]\n\n# Compare with direct Yao computation\ninitial_state = Yao.zero_state(n)\nfinal_state = initial_state |> circuit\namplitude_from_yao = (Yao.zero_state(n)' * final_state)[]\n\namplitude_from_network ≈ amplitude_from_yao","category":"section"},{"location":"man/yao2einsum.html#Case-3:-Computing-Observable-Expectation-Values","page":"Tensor Network Backend","title":"Case 3: Computing Observable Expectation Values","text":"Tensor networks are particularly useful for computing expectation values of observables. Here we compute the expectation value of a Pauli-Z operator on the first qubit after applying the QFT:\n\n# Define the observable (Pauli-Y on first qubit)\nobservable = put(n, 1=>Y)\n\n# Create tensor network for expectation value computation\n# We need to use the `DensityMatrixMode` to sandwich the circuit between the initial state and the observable\nnetwork_obs = Yao.yao2einsum(circuit;\n    initial_state=Dict(1=>0, 2=>1, 3=>1, 4=>1),  # Start in |0111⟩\n    observable = observable,     # Measure expectation value\n    mode = DensityMatrixMode()\n)\nviznet(network_obs)\n\nContract to get the expectation value\n\nres_network = real(Yao.contract(network_obs)[])\n\nCompare with direct Yao computation\n\nstate_after_circuit = product_state(bit\"1110\") |> circuit\nres_exact = real(expect(observable, state_after_circuit))","category":"section"},{"location":"man/yao2einsum.html#Case-4:-Noisy-Circuit-Simulation","page":"Tensor Network Backend","title":"Case 4: Noisy Circuit Simulation","text":"YaoToEinsum supports simulation of noisy quantum circuits using different representations. We demonstrate both density matrix and Pauli basis modes for simulating decoherence:\n\n# Create a simpler circuit for noisy simulation\nn_small = 3\nγ = 0.1  # damping parameter\n\n# Create amplitude damping channels\ndamping_channel = quantum_channel(AmplitudeDampingError(γ))\n\n# Build noisy circuit: gate followed by noise on the same qubits\nnoisy_circuit = chain(n_small,\n    put(1=>X), put(1=>damping_channel),\n    put(2=>H), put(2=>damping_channel), \n    cnot(1,2), put(1=>damping_channel), put(2=>damping_channel),\n    put(3=>Z), put(3=>damping_channel)\n)","category":"section"},{"location":"man/yao2einsum.html#Density-Matrix-Mode","page":"Tensor Network Backend","title":"Density Matrix Mode","text":"Simulate using density matrix representation\n\nnetwork_dm = Yao.yao2einsum(noisy_circuit; \n    mode=DensityMatrixMode(),\n    initial_state=Dict([i=>0 for i=1:n_small]),\n    observable=put(n_small, 1=>Z)\n)\nviznet(network_dm)\n\nContract to get the final density matrix\n\nres_network = contract(network_dm)[]\n\nCompare with direct Yao simulation\n\ninitial_dm = density_matrix(zero_state(n_small))\nres_exact = expect(put(n_small, 1=>Z), apply(initial_dm, noisy_circuit))","category":"section"},{"location":"man/yao2einsum.html#Pauli-Basis-Mode","page":"Tensor Network Backend","title":"Pauli Basis Mode","text":"Simulate using Pauli basis representation\n\nnetwork_pauli = Yao.yao2einsum(noisy_circuit;\n    mode=PauliBasisMode(),\n    initial_state=Dict([i=>0 for i=1:n_small]),\n    observable=put(n_small, 1=>Z)\n)\nviznet(network_pauli)\n\nContract to get Pauli coefficients and verify the result\n\nres_pauli = Yao.contract(network_pauli)","category":"section"},{"location":"man/yao2einsum.html#API-Reference","page":"Tensor Network Backend","title":"API Reference","text":"The following functions and types are exported by YaoToEinsum:","category":"section"},{"location":"man/yao2einsum.html#References","page":"Tensor Network Backend","title":"References","text":"[Markov2008]: Markov, Igor L., and Yaoyun Shi. \"Simulating quantum computation by contracting tensor networks.\" SIAM Journal on Computing 38.3 (2008): 963-981.\n\n[Pan2022]: Pan, Feng, and Pan Zhang. \"Simulation of quantum circuits using the big-batch tensor network method.\" Physical Review Letters 128.3 (2022): 030501.\n\n[Kalachev2021]: Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. \"Recursive multi-tensor contraction for xeb verification of quantum circuits.\" arXiv preprint arXiv:2108.05665 (2021).\n\n[Liu2023]: Liu, Jin-Guo, et al. \"Computing solution space properties of combinatorial optimization problems via generic tensor networks.\" SIAM Journal on Scientific Computing 45.3 (2023): A1239-A1270.","category":"section"},{"location":"man/yao2einsum.html#YaoToEinsum.yao2einsum","page":"Tensor Network Backend","title":"YaoToEinsum.yao2einsum","text":"yao2einsum(circuit; initial_state=Dict(), final_state=Dict(), optimizer=TreeSA(), mode=VectorMode(), observable=nothing, slicer=nothing)\n\nTransform a Yao circuit to a generalized tensor network (einsum) notation. The return value is a TensorNetwork instance that corresponds to the following tensor network:\n\n1). If mode is VectorMode(), the tensor network will be like:\n\n<initial_state| ─── circuit ─── |final_state>\n\n2). If the mode is DensityMatrixMode(), the tensor network will be like:\n\n<final_state| ─── circuit ─── |initial_state><initial_state| ─── circuit ─── |final_state>\n\nwhere the circuit may contain noise channels.\n\n3). In the DensityMatrixMode(), if observable is specified, compute tr(rho, observable) instead.\n\n┌── circuit ─── |initial_state><initial_state| ─── circuit ─── observable ──┐\n└───────────────────────────────────────────────────────────────────────────┘\n\n4). PauliBasisMode() is similar to the DensityMatrixMode() mode, but the basis will be rotated to the Pauli basis.\n\nArguments\n\nmode is the mapping mode, which can be DensityMatrixMode(), PauliBasisMode(), or VectorMode().\ncircuit is a Yao block as the input.\ninitial_state and final_state are dictionaries to specify the initial states and final states (taking conjugate).\nIn the first interface, a state is specified as an integer, e.g. Dict(1=>1, 2=>1, 3=>0, 4=>1) specifies a product state |1⟩⊗|1⟩⊗|0⟩⊗|1⟩.\nIn the second interface, a state is specified as an ArrayReg, e.g. Dict(1=>rand_state(1), 2=>rand_state(1)).\nobservable is a Yao block to specify the observable. If it is specified, the final state must be unspecified.\n\nIf any qubit in initial state or final state is not specified, it will be treated as a free leg in the tensor network.\n\noptimizer is the optimizer used to optimize the tensor network. The default is TreeSA().\nslicer is the slicer used to slice the tensor network and reduce the memory usage, e.g. to reduce the largest tensor rank to 30, use TreeSASlicer(score=OMEinsum.ScoreFunction(sc_target=30)).\n\nPlease check OMEinsumContractors.jl for more information.\n\njulia> using Yao\n\njulia> c = chain(3, put(3, 2=>X), put(3, 1=>Y), control(3, 1, 3=>Y))\nnqubits: 3\nchain\n├─ put on (2)\n│  └─ X\n├─ put on (1)\n│  └─ Y\n└─ control(1)\n   └─ (3,) Y\n\n\njulia> yao2einsum(c; initial_state=Dict(1=>0, 2=>1), final_state=Dict(1=>ArrayReg([0.6, 0.8im]), 2=>1))\nTensorNetwork\nTime complexity: 2^4.700439718141093\nSpace complexity: 2^2.0\nRead-write complexity: 2^6.0\n\n\n\n\n\n","category":"function"},{"location":"man/yao2einsum.html#YaoToEinsum.TensorNetwork","page":"Tensor Network Backend","title":"YaoToEinsum.TensorNetwork","text":"TensorNetwork\n\nA (generalized) tensor network representation of a quantum circuit.\n\nFields\n\ncode::AbstractEinsum: The einsum code.\ntensors::Vector: The tensors in the network.\nlabel_to_qubit::Dict{Int, Int}: Map from variable label to qubit index (negative for dual, absent for non-qubit)\n\n\n\n\n\n","category":"type"},{"location":"man/yao2einsum.html#OMEinsumContractionOrders.optimize_code","page":"Tensor Network Backend","title":"OMEinsumContractionOrders.optimize_code","text":"optimize_code(c::TensorNetwork, optimizer=TreeSA(); slicer=nothing)\n\nOptimize the code of the tensor network.\n\nArguments\n\nc::TensorNetwork: The tensor network.\noptimizer::Optimizer: The optimizer to use, default is OMEinsum.TreeSA().\n\nKeyword Arguments\n\nslicer: The slicer to use, default is nothing. It can be e.g. OMEinsum.TreeSASlicer(score=OMEinsum.ScoreFunction(sc_target=30)).\n\nFor more, please check OMEinsumContractionOrders documentation.\n\n\n\n\n\n","category":"function"},{"location":"man/yao2einsum.html#OMEinsumContractionOrders.contraction_complexity","page":"Tensor Network Backend","title":"OMEinsumContractionOrders.contraction_complexity","text":"contraction_complexity(c::TensorNetwork)\n\nReturn the contraction complexity of the tensor network.\n\n\n\n\n\n","category":"function"},{"location":"man/yao2einsum.html#YaoToEinsum.contract","page":"Tensor Network Backend","title":"YaoToEinsum.contract","text":"contract(c::TensorNetwork)\n\nContract the tensor network, and return the result tensor.\n\n\n\n\n\n","category":"function"},{"location":"man/symbolic.html#Symbolic-Computation","page":"Symbolic Computation","title":"Symbolic Computation","text":"The symbolic engine of Yao is based on SymEngine.jl. It allows one to define quantum circuits with symbolic parameters and perform symbolic computation on them. Two macro/functions play a key role in the symbolic computation:\n\n@vars for defining symbolic variables\nsubs for substituting symbolic variables with concrete values\n\nusing Yao\n@vars θ\ncircuit = chain(2, put(1=>H), put(2=>Ry(θ)))\nmat(circuit)\nnew_circuit = subs(circuit, θ=>π/2)\nmat(new_circuit)","category":"section"},{"location":"man/symbolic.html#API","page":"Symbolic Computation","title":"API","text":"The following functions are for working with symbolic states.","category":"section"},{"location":"man/symbolic.html#YaoSym.@ket_str","page":"Symbolic Computation","title":"YaoSym.@ket_str","text":"@ket_str\n\nCreate a ket register. See also @bra_str.\n\nExamples\n\na symbolic quantum state can be created simply by\n\njulia> ket\"110\" + 2ket\"111\"\n|110⟩ + 2.0|111⟩\n\nqubits can be partially actived by focus!\n\njulia> ket\"100\" + ket\"111\" |> focus!(1:2)\n|100⟩ + |111⟩\n\n\n\n\n\n","category":"macro"},{"location":"man/symbolic.html#YaoSym.@bra_str","page":"Symbolic Computation","title":"YaoSym.@bra_str","text":"@bra_str\n\nCreate a bra register. See also @ket_str.\n\nExamples\n\nSimilar to @ket_str literal, a symbolic quantum state can be created by\n\njulia> bra\"111\" + 2bra\"101\"\n2.0⟨101| + ⟨111|\n\njulia> bra\"111\" * (ket\"101\" + ket\"111\")\n1\n\n\n\n\n\n","category":"macro"},{"location":"man/symbolic.html#YaoSym.szero_state","page":"Symbolic Computation","title":"YaoSym.szero_state","text":"szero_state(n; nbatch=1)\n\nCreate a symbolic zero state, same as ket\"000\", but allows you use an integer.\n\n\n\n\n\n","category":"function"},{"location":"generated/examples/4.shor-algorithm/index.html","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"(Image: )","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#Shor","page":"Shor's Algorithm","title":"Shor's Algorithm","text":"","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#References","page":"Shor's Algorithm","title":"References","text":"Neilsen\nAn Insightful Blog\n\nThe main program of a Shor's algorithm can be summarized in several lines of code. For the theory part, please refer to the reference materials above. It factorizes an integer L, and returns one of the factors.\n\nusing Yao, BitBasis\nusing Yao.EasyBuild: qft_circuit","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#Number-theory-basic","page":"Shor's Algorithm","title":"Number theory basic","text":"Before entering the main program, let us define some useful functions in number theory.\n\nmodule NumberTheory\n\nexport Z_star, Eulerφ, continued_fraction, mod_inverse, rand_primeto, factor_a_power_b\nexport is_order, order_from_float, find_order\n\n\"\"\"\n    Z_star(N::Int) -> Vector\n\nreturns the Z* group elements of `N`, i.e. {x | gcd(x, N) == 1}\n\"\"\"\nZ_star(N::Int) = filter(i->gcd(i, N)==1, 0:N-1)\nEulerφ(N) = length(Z_star(N))\n\n\"\"\"\n    continued_fraction(ϕ, niter::Int) -> Rational\n\nobtain `s` and `r` from `ϕ` that satisfies `|s/r - ϕ| ≦ 1/2r²`\n\"\"\"\ncontinued_fraction(ϕ, niter::Int) = niter==0 || isinteger(ϕ) ? floor(Int, ϕ) : floor(Int, ϕ) + 1//continued_fraction(1/mod(ϕ, 1), niter-1)\ncontinued_fraction(ϕ::Rational, niter::Int) = niter==0 || ϕ.den==1 ? floor(Int, ϕ) : floor(Int, ϕ) + 1//continued_fraction(1/mod(ϕ, 1), niter-1)\n\n\"\"\"\n    mod_inverse(x::Int, N::Int) -> Int\n\nReturn `y` that `(x*y)%N == 1`, notice the `(x*y)%N` operations in Z* forms a group and this is the definition of inverse.\n\"\"\"\nfunction mod_inverse(x::Int, N::Int)\n    for i=1:N\n        (x*i)%N == 1 && return i\n    end\n    throw(ArgumentError(\"Can not find the inverse, $x is probably not in Z*($N)!\"))\nend\n\n\"\"\"\n    is_order(r, x, N) -> Bool\n\nReturns true if `r` is the order of `x`, i.e. `r` satisfies `x^r % N == 1`.\n\"\"\"\nis_order(r, x, N) = powermod(x, r, N) == 1\n\n\"\"\"\n    find_order(x::Int, N::Int) -> Int\n\nFind the order of `x` by brute force search.\n\"\"\"\nfunction find_order(x::Int, N::Int)\n    findfirst(r->is_order(r, x, N), 1:N)\nend\n\n\"\"\"\n    rand_primeto(N::Int) -> Int\n\nReturns a random number `2 ≦ x < N` that is prime to `N`.\n\"\"\"\nfunction rand_primeto(N::Int)\n    while true\n        x = rand(2:N-1)\n        d = gcd(x, N)\n        if d == 1\n            return x\n        end\n    end\nend\n\n\"\"\"\n    order_from_float(ϕ, x, L) -> Int\n\nEstimate the order of `x` to `L`, `r`, from a floating point number `ϕ ∼ s/r` using the continued fraction method.\n\"\"\"\nfunction order_from_float(ϕ, x, L)\n    k = 1\n    rnum = continued_fraction(ϕ, k)\n    while rnum.den < L && k < 100\n        r = rnum.den\n        if is_order(r, x, L)\n            return r\n        end\n        k += 1\n        rnum = continued_fraction(ϕ, k)\n    end\n    return nothing\nend\n\n\"\"\"\n    factor_a_power_b(N::Int) -> (Int, Int) or nothing\n\nFactorize `N` into the power form `a^b`.\n\"\"\"\nfunction factor_a_power_b(N::Int)\n    y = log2(N)\n    for b = 2:ceil(Int, y)\n        x = 2^(y/b)\n        u1 = floor(Int, x)\n        u1^b == N && return (u1, b)\n        (u1+1)^b == N && return (u1+1, b)\n    end\nend\n\nend\n\nMain.var\"##282\".NumberTheory","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#A-quantum-function-to-compute-mod","page":"Shor's Algorithm","title":"A quantum function to compute mod","text":"Before introducing the main program, let us customize a block for computing the classical function mod. In a more practical setup, it should be compiled to basic quantum gates. Here we just hack this function for simplicity.\n\n\"\"\"\n    KMod <: PrimitiveBlock{2}\n\nThe first `k` qubits are exponent, and the rest `n-k` are base `a`,\nit calculates `mod(a^k*x, L)`, notice `gcd(a, L)` should be 1.\n\"\"\"\nstruct KMod <: PrimitiveBlock{2}\n    n::Int\n    k::Int\n    a::Int\n    L::Int\n    function KMod(n, k, a, L)\n        @assert gcd(a, L) == 1 && L<=1<<(n-k)\n        new(n, k, a, L)\n    end\nend\n\nYao.nqudits(m::KMod) = m.n\n\nfunction bint2_reader(T, k::Int)\n    mask = bmask(T, 1:k)\n    return b -> (b&mask, b>>k)\nend\n\nfunction Yao.unsafe_apply!(reg::AbstractArrayReg, m::KMod)\n    nstate = zero(reg.state)\n\n    reader = bint2_reader(Int, m.k)\n    for b in 0:1<<m.n-1\n        k, i = reader(b)\n        _i = i >= m.L ? i : mod(i*powermod(m.a, k, m.L), m.L)\n        _b = k + _i<<m.k + 1\n        for j in 1:size(nstate,2)\n            @inbounds nstate[_b,j] = reg.state[b+1,j]\n        end\n    end\n    reg.state .= nstate\n    reg\nend\n\nfunction Yao.mat(::Type{T}, m::KMod) where {T}\n    perm = Vector{Int}(undef, 1<<m.n)\n    reader = bint2_reader(Int, m.k)\n    for b in 0:1<<m.n-1\n        k, i = reader(b)\n        _i = i >= m.L ? i : mod(i*powermod(m.a, k, m.L), m.L)\n        _b = k + _i<<m.k + 1\n        @inbounds perm[_b] = b+1\n    end\n    YaoBlocks.LuxurySparse.PermMatrix(perm, ones(T, 1<<m.n))\nend\n\nBase.adjoint(m::KMod) = KMod(m.n, m.k, mod_inverse(m.a, m.L), m.L)\nYao.print_block(io::IO, m::KMod) = print(io, \"Mod: $(m.a)^k*x % $(m.L) (nqubits = $(nqudits(m)), number of control bits = $(m.k))\")","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#Main-Program","page":"Shor's Algorithm","title":"Main Program","text":"Here, the input ver can be either Val(:quantum) or Val(:classical), where the classical version is for comparison.\n\nusing .NumberTheory\n\nfunction shor(L::Int, ver=Val(:quantum); maxtry=100)\n    L%2 == 0 && return 2\n\n    # find short cut solutions like `a^b`\n    res = NumberTheory.factor_a_power_b(L)\n    res !== nothing && return res[1]\n\n    for _ = 1:maxtry\n        # step 1\n        x = NumberTheory.rand_primeto(L)\n\n        # step 2\n        r = get_order(ver, x, L; )\n        if r%2 == 0 && powermod(x, r÷2, L) != L-1\n            # step 3\n            f1, f2 = gcd(powermod(x, r÷2, L)-1, L), gcd(powermod(x, r÷2, L)+1, L)\n            if f1!=1\n                return f1\n            elseif f2!=1\n                return f2\n            else\n                error(\"Algorithm Fail!\")\n            end\n        end\n    end\nend\n\nshor (generic function with 2 methods)\n\nExcept some shortcuts, in each try, the main program can be summarized in several steps\n\nrandomly pick a number that prime to the input numebr L, i.e. gcd(x, L) = 1.\n\nThe complexity of this algorithm is polynomial.\n\nget the order x, i.e. finding a number r that satisfies mod(x^r, L) = 1.\n\nIf r is even and x^(r÷2) is non-trivial, go on, otherwise start another try. Here, trivial means equal to L-1 (mod L).\n\nAccording to Theorem 5.2 in Neilsen book,\n\none of gcd(x^(r÷2)-1, L) and gcd(x^(r÷2)+1, L) must be a non-trivial (!=1) factor of L. Notice powermod(x, r÷2, L) must be -1 rather than 1, otherwise the order should be r/2 according to definition.\n\nThe only difference between classical and quantum version is the order finding algorithm.","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#Order-Finding","page":"Shor's Algorithm","title":"Order Finding","text":"We provided a classical order finding algorithm in NumberTheory, here we focus on the quantum version. The algorithm is consisted\n\nrun the circuit to get a bitstring,\ninterpret this bitstring in output register as a rational number s/r.\n\nTo achieve this, we first interpret it as a floating point number, then the continued fraction algorithm can find the best match for us.\n\nWhen using the quantum version, we have the flexibility to set key word arguments nshot, nbit (size of input data register) and ncbit (size of control register, or output register). nbit can be simply chosen as the minimum register size to store input, while ncbit can be estimated with the following function\n\n\"\"\"estimate the required size of the output register.\"\"\"\nestimate_ncbit(nbit::Int, ϵ::Real) = 2*nbit + 1 + ceil(Int,log2(2+1/2ϵ))\n\nget_order(::Val{:classical}, x::Int, L::Int; kwargs...) = NumberTheory.find_order(x, L)\nfunction get_order(::Val{:quantum}, x::Int, L::Int; nshots::Int=10,\n            nbit::Int=bit_length(L-1), ncbit::Int=estimate_ncbit(nbit, 0.25))\n    c = order_finding_circuit(x, L; nbit=nbit, ncbit=ncbit)\n    reg = join(product_state(nbit, 1), zero_state(ncbit))\n\n    res = measure(copy(reg) |> c; nshots=nshots)\n    for r in res\n        # split bit string b into lower bits `k` and higher bits `r`.\n        mask = bmask(1:ncbit)\n        k,i = r&mask, r>>ncbit\n        # get s/r\n        ϕ = bfloat(k)  #\n        ϕ == 0 && continue\n\n        # order_from_float: given a floating point number,\n        # return the closest rational number with bounded number of continued fraction steps.\n        order = NumberTheory.order_from_float(ϕ, x, L)\n        if order === nothing\n            continue\n        else\n            return order\n        end\n    end\n    return nothing\nend\n\nget_order (generic function with 2 methods)","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#The-circuit-used-for-finding-order","page":"Shor's Algorithm","title":"The circuit used for finding order","text":"\"\"\"\n    order_finding_circuit(x::Int, L::Int; nbit::Int=bit_length(L-1), ncbit::Int=estimate_ncbit(nbit, 0.25)) -> AbstractBlock\n\nReturns the circuit for finding the order of `x` to `L`,\nfeeding input `|1>⊗|0>` will get the resulting quantum register with the desired \"phase\" information.\n\"\"\"\nfunction order_finding_circuit(x::Int, L::Int; nbit::Int, ncbit::Int)\n    N = nbit+ncbit\n    chain(N, repeat(N, H, 1:ncbit), KMod(N, ncbit, x, L),\n        subroutine(N, qft_circuit(ncbit)', 1:ncbit))\nend\n\nMain.var\"##282\".order_finding_circuit\n\nThe circuit for order finding is consisted of three parts\n\nHadamard gates,\nKMod that computes a classical function mod(a^k*x, L).\n\nk is the integer stored in first K (or ncbit) qubits and the rest N-K qubits stores a. Notice it is not a basic gate, it should have been compiled to multiple gates, which is not implemented in Yao for the moment. To learn more about implementing arithmatics on a quantum circuit, please read this paper.\n\nInverse quantum fourier transformation.","category":"section"},{"location":"generated/examples/4.shor-algorithm/index.html#Run","page":"Shor's Algorithm","title":"Run","text":"Factorizing 15, you should see 3 or 5, please report a bug if it is not...\n\nshor(15, Val(:quantum))\n\n3\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/8.riemannian-gradient-flow/index.html","page":"Riemannian gradient flow optimizer","title":"Riemannian gradient flow optimizer","text":"(Image: )","category":"section"},{"location":"generated/examples/8.riemannian-gradient-flow/index.html#Riemannian-gradient-flow-optimizer","page":"Riemannian gradient flow optimizer","title":"Riemannian gradient flow optimizer","text":"In this tutorial we will present the Riemannian gradient descent algorithm described in Miao and Barthel (2021) and Wiersema and Killoran (2022) As opposed to most standard optimization algorithms that optimize parameters of variational quantum circuits, this algorithm optimizes a function directly over the special unitary group by following the gradient flow over the manifold. Let's start by importing the necessary packages.\n\nusing Yao, Yao.EasyBuild, Plots, Random\nusing KrylovKit: eigsolve\n\nVariational quantum eigensolver (VQE) is one of the most celebrated near-term quantum algorithms. In the usual setting, VQE tries to reach the ground state by minimizing the energy cost function\n\nmathcalL(theta) = textTrHU(theta)rho_0U^dagger(theta)\n\nwith respect to parameters theta which parameterize a quantum circuit U(theta), where rho_0 = psi_0ranglelanglepsi_0 is some initial state and H the Hamiltonian whose ground state we want to approximate. We can solve the optimization problem textmin_thetamathcalL(theta) by following the direction of the steepest descent in parameter space which is given by the gradient of the cost function, i.e. by considering the following gradient flow\n\ndottheta = -textgradmathcalL(theta)\n\nDiscretizing the equation above, we recover the well-known gradient descent algorithm\n\ntheta_k + 1 = theta_k - alphatextgradmathcalL(theta)\n\nwhere alpha is the learning rate. Let's demonstrate it on the example of finding the ground state of the transverse field Ising model.\n\nn = 8\nh = transverse_ising(n, 1.0)\nw, v = eigsolve(mat(h), 1, :SR, ishermitian=true)\n\nRandom.seed!(0)\ncircuit = dispatch!(variational_circuit(n, 100), :random);\nhistory = Float64[]\nfor i in 1:100\n    _, grad = expect'(h, zero_state(n) => circuit)\n    dispatch!(-, circuit, 0.01 * grad)\n    push!(history, real.(expect(h, zero_state(n)=>circuit)))\nend\n\nPlots.plot(history, legend=false)\nPlots.plot!(1:100, [w[1] for i=1:100])\nxlabel!(\"steps\")\nylabel!(\"energy\")\n\n<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQCAIAAAD9V4nPAAAABmJLR0QA/wD/AP+gvaeTAAAgAElEQVR4nO3dd3wU9b7/8e93dpNsNqT3Qgq9964UFSkexCAKeESOoliOR+TaC/7Uo3jt7Vz0elS4RzwgoFgPIopSpAaigCAlhC7phSULm+zs/P5YXWPc0Ex2dndezz987BR2Pjtu5r3f73xnRmqaJgAAMCpF7wIAANATQQgAMDSCEABgaAQhAMDQCEIAgKERhAAAQyMIAQCGRhACAAyNIAQAGBpBCAAwtIAMwnvuucflcjW2VFVVXxYDj9P8T0HzYbfrhUONXpp8z8tAvNeo1WotLy8PDw/3utRms0VGRvq4JKiq6nA4rFar3oUYjt1ut1gsihKQP2oDGocavTT5nuePBwBgaAQhAMDQCEIAgKERhAAAQyMIAQCGRhACAAyNIAQAGBpBCAAwtCAPQk2IHkucauDdMwAA4CNBHoRSiBNOsbeaJAQAeBfkQSiE6BEvvy8nCAEA3hkgCOPk9xUEIQDAOwMEIS1CAEDjjBCE4juCEADQiOAPwowI6dLEMbvedQAA/FLwB6GgdxQA0DhjBCHjZQAAjTBGENIiBAA0giAEABiaIYKwQ4w8WqOdqNO7DgCA/zFEEJqk6BQrt3GaEADwO4YIQkHvKACgEYYJQgaOAgC8MUwQ0iIEAHhjlCDsHi93VGpOl951AAD8jFGCMMIsMiLkbh5MCAD4LaMEoaB3FADgjYGCsHuc3Mp4GQDAbxkoCHvGS57HBABowEBB2CNefldGEAIAfsNAQZhqFWZFHKkhCwEAvzJQEIqfx8voXQQAwJ8YMAhpEQIAfmWsIGTgKACgAWMFIQNHAQANGCsI20bL4pPacR5MCAD4hbGC0CRFtzguogAA/MpYQSiE6Bkv8+kdBQD8wohBSIsQAOBhuCDslUCLEADwK8MFYedYud+m2Z161wEA8A+GC8JQRXSMkdu4mhAAIIQwYBAK93gZThMCAIQQhg1CLqsHALgZMQgZLwMA8DBiEHaPk7uqtFqX3nUAAPyAEYMw3CxaRcodlTQKAQCGDELBeBkAwC+MGoQJjJcBAAhh2CDsRYsQACCEMGwQ9kyQ2yo0lSgEAMMzaBBGhYi0CLm7miQEAKPzoyD86KOPrr/++osvvnjKlCmbN29u7s3ROwoAEH4VhHPnzh0wYMBjjz3WsWPHoUOH7tq1q1k3x/1lAABCCLPeBfzq448/dr8YMmTIsmXLli9f3qFDh+bbXM8E+d/fc1E9ABidH7UIPWprawsLC7Ozs5t1K70T5HflGk1CADA4n7YIi4uLjx071rACs7lLly7159x77705OTljxoxp7H1qa2sHDhyoKD+n+EUXXfT44497ltbU1Egpz1hMmBBRIWE/FNXktCANm4Cqqg6Hw+Wike1rdrvd6XR6/hzgM2d5qEGTO6c9b7FYzOYzJJ1Pg/DTTz994403GsyMiYn58ssvPZP//d///dVXX61cufI0f9ghISGvvfZaWFiYezI1NbVFixaepZqm1Z88jd4J6q6T4V1TOII0AVVVQ0JCrFar3oUYjqIoFouFIPS9sz/UoGk1+Z6Xmj/1Dr744otvvPHGypUrU1NTT7Oa1WotLy8PDw/3utRms0VGRp7N5v7+neuUU3uqr+l8asVvuVuEBKHv2e12glAXZ3+oQdNq8j3vR388r7766quvvrp8+fLTp2AT6hkveB4TABicHwXhww8/XFJS0rNnz7i4uLi4uPqn/ZpJr3i5hUsJAcDY/OjyCZvN5uMtpkdIsxSHa7SWEZzxBgCD8qMWoS76JMrNpTQKAcC4DB+ECQq9owBgZIYPwkS5mSAEAAMzehD2S5R5pf50BQkAwLeMHoSJFhFhlvttRCEAGJTRg1AwXgYAjI0gFL0TuJoQAIyLIBR9GS8DAAZGEIo+CXJLmeYiCgHAkAhCERcm4sNkwXGSEACMiCAUQog+iTKP8TIAYEgEoRCMlwEAAyMIhRCiTwLjZQDAoAhCIYTonSC/K9dUohAAjIcgFEKI6FCRbpW7qkhCADAcgvBn3H0bAIyJIPxZ7wRutAYARkQQ/ozxMgBgTAThz3onyO0VWp1L7zoAAL5FEP7MahbZkXJHJY1CADAWgvBX9I4CgAERhL/qk8j9ZQDAcAjCX/VJ4I6jAGA4BOGvusfJXVWaQ9W7DgCADxGEvwo3i3bR8vtyGoUAYCAE4W/0T5Ib6R0FACMhCH+jf6LcWEIQAoCBEIS/QYsQAIyGIPyNDjGywqGVndK7DgCArxCEvyGF6J0gN9EoBADDIAgb6p8oN5Zwy1EAMAqCsCFOEwKAoRCEDfVPVDaWaCQhABgEQdhQUriICZN7q4lCADAEgtCL/on0jgKAURCEXvRP4rJ6ADAKgtAL7i8DAMZBEHrRK0H+WKWddOpdBwCg+RGEXlhMomOM/L6CRiEABD+C0DtOEwKAQRCE3nFZPQAYBEHoHeNlAMAgCELv2kbL47Va8Um96wAANDOC0DspRJ9EmUfvKAAEO4KwUf0T5cZSHkMBAEGOIGxU/ySF04QAEPQIwkb1T5J5pZqLKASAoEYQNio+TCRY5C4eQwEAQY0gPJ1ByXJtEUEIAMGMIDydQclyHacJASCoEYSnMyhJrismCAEgmBGEp9M5Vpad0kpP6V0HAKDZEISno0jRL1GuL+ZqQgAIWgThGQxMVjhNCABBjCA8gwuS5VpOEwJA8CIIz2BAkvyuTHOoetcBAGgeBOEZRJhFu2j5XTmNQgAITn4XhKtXr54wYcKWLVv0LuRXFyRzEQUABC3/CsKamprp06evWLHip59+0ruWXw3ksnoACF7+FYQPPvjgtGnTYmNj9S7kNy5Ilt8WcQUFAAQnPwrC9evXb968+bbbbtO7kIayWsgQRRbaaBQCQBAy+3JjeXl5v5+ZnZ2dmJjocDhuu+22f//734py5myura0dOHCglNI9edFFFz3++OOepSdOnGiqgj36xoV+fbA2MYvBo41SVbW2tlZV2UW+dvLkybq6urP5w0HTao5DDc7GOe15i8USEhJy+nV8F4Sqqk6fPv338++///7c3NxHH300Nze3c+fOZ/NWISEhr732WlhYmHsyMzMzMjKy/goNJv+4Iemu/GrzTZGmpn3bYKKqqsPhsFqtehdiOCaTyWKxEIS6aPJDDc5S0+55qWl+0eP3pz/9af369e7X1dXVVqv1nnvuefTRR72ubLVay8vLw8PDvS612WxN/u3MK9WmrVG/v9KnDejAQhDqxW63E4S6aI5DDc5Gk+95fzmy/+c///G8btOmzUsvvXT55ZfrWE8DPeJloU2rrhXRoXqXAgBoUvyKPCshiuiVIDeW+kXrGQDQhPylRVhfQUGB3iV4MShJrit2jUjnNCEABBVahGdrULLC/WUAIPgQhGfrgmS5qVRTiUIACC4E4dmKDRPpVrm9giQEgKBCEJ6DIalydRFBCABBhSA8B4NTCEIACDYE4TkYmiJXH3ORhAAQTAjCc5AeIaNC5a4qohAAggdBeG6G0DsKAMGFIDw3g1Pk6mMEIQAED4Lw3AxNlatoEQJAECEIz02rSKkIwUN6ASBoEITnbHCKXEXvKAAEC4LwnA1JlWvoHQWAYEEQnjMGjgJAMPEehNdee+37779fV1fn42oCQocYaavTDteQhQAQDLwH4eHDh6+++urMzMyHHnpo//79Pq7Jz0khBqco9I4CQHDwHoSrV6/evHnz2LFjX3311TZt2lx66aWLFy+mgegxJIXThAAQJBo9R9i7d+833njjp59+ev3118vLyydMmJCZmfnAAw/QQBRCDGHgKAAEizMMlomKirr55ps3bNhw1113FRcXP/PMM23atJkwYcLevXt9U59/6hYnS05qJSf1rgMA8IedIQgLCgruv//+li1bvvTSS8OHD1+8ePHLL7+cl5fXr1+/4uJi35TohxQpBibLNUUuvQsBAPxR3oOwtrZ20aJFw4cPb9eu3VtvvTV58uTdu3cvX778qquuuuOOO7Zu3app2jfffOPjWv3KkBSFiygAIAiYvc7t1q3b7t27+/XrN2fOnIkTJ4aHh9dfGhUVlZ6efuLECZ9U6KeGpMhb19IiBICA5z0Ir7jiiokTJ/bq1auxf7Zjx45mKykw9E6Qhce1SoeIDdO7FADAH+A9CJ955hkf1xFwzIoYmCxXFblys7g7DwAEMO9BuHr16tra2t/PT0pKys7OjoqKauaqAsMlacqKo1pult51AAD+AO9BOGHChNMMCh0+fPhbb72VlWX0BLgkTU5eyWlCAAhs3rv13nzzzaSkpBtuuOHDDz9cs2bNokWLxo0bl52dvWTJkhdffHHbtm1jx451uYyeAT3iZekp7Sg3HQWAQCY1zctxfMiQIaNGjXrooYfqz5w2bVptbe2//vWvDRs2DBw4cO3atYMGDfJVnb9htVrLy8sbjGX1sNlskZGRvqnkqhVqbpac3IbThEJVVYfDYbVa9S7EcOx2u8ViURS+hL7my0MN6mvyPe/lj6eysnLNmjVXXnllg/lXXnnlJ598IoQYMGBAcnLyvn37mrCOAHVJmlzxEy1CAAhgXoJQVVUhxIEDBxrMP3DggHuRECI8PDwsjOsGxCVpcsVRghAAApiXIExISOjdu/ff/va3jRs3emZ+8cUXjzzyyMiRI4UQ5eXlR44cyc7O9lmVfqtdtBRC7K0mCwEgUHk/r/DOO+84HI4BAwakpKR07tw5Pj5+1KhRqampr776qhBi7969N91002kutzeU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1auX+yrLAQMGhIeHr1u3Tu+iglZaWprnCu7U1FSHw+FZVFpa+vnnn2/fvl3jEtXmUVZW9vnnn2/bts2zh7/99tuoqKh+/foJIbKysrp16/bFF1/oWmMwe/vtt0eNGuW5oNvlcn399dfffvttTU2NvoUFDSml10vgP/3006uuusr9evz48Z999pkQYvXq1QkJCb169RJCtGrVqlOnTsuXLz/XLQZPEB49ejQjI8MzmZ6efvToUR3rMQhVVWfNmnXTTTe5J00m0/79+19//fWRI0defPHFHBqanKIoBw8efP3110ePHj1s2DD3Y4D48vuMy+V65513pk6d6pkTGxv78ssvT58+vXXr1mvWrNGxtqB39OjR9PR092vPl7xJvvzBE4SqqkopPZNms9npdOpYjxFomnbbbbeZTKZHHnnEPeeBBx7YuHHjJ598UlBQYLPZXnjhBX0rDD733nvvpk2b3HvY4XA899xzgi+/Dy1btszhcIwZM8Y9mZOTU1hY+Mknn+Tn50+fPt3zixDNof733GQyub/kTfLlD54gTE1NLSkp8UwWFxenpaXpWI8RzJgx44cffvjkk088Axc9NyC2Wq25ubnfffedftUFJ88eDg8P9+zhBl/+oqIivvzNZM6cOVOmTAkJCXFPKoriOQpfc801e/bssdvt+lUX5FJTU0tLS92vPUf4JjnyB08QDh06dOPGjcePHxdCFBQUHDt27DzH0eLsPPjgg2vWrPnPf/4TGRnpdYX8/HzPZRVoDp49PGDAgMOHDxcWFgohqqqq8vLyeABLcygvL//ss89uuOEGr0vz8/Pj4+OtVquPqzKOiy66yHPye/ny5cOGDRNCDBw4cP/+/QcPHhRCVFRUbNmy5Ty+/MFzHWHHjh0vu+yyMWPGjB8//u2337799ttjY2P1LipozZs37+mnn7766qsfeOAB95x//OMfoaGhY8eO7dy5c2xs7Lfffrthw4a8vDx96ww+48aNa9++fXx8/Lp169asWbNp0yYhRHx8/K233jpu3LipU6cuXrw4Nze3bdu2elcahP71r3/16tWrU6dOnjkvvfTSjh072rdv/9NPP82ZM+fZZ5/Vsbxg8uijjxYVFdnt9meeeSY5OXnWrFkJCQkzZswYOHBgVFSUpmnz58/fuHGjECIpKWnatGm5ubnXX3/9woULr7766vN4JEhQPX2irq5u3rx5e/bs6dOnz/jx4+t3HKNpbd++ff369fXnTJ061Ww2r1y5ct26dSdOnMjKypo4cWJMTIxeFQarVatWrVu3zmazZWZmTpw40fNrT9O0xYsX5+fnd+jQYfLkyWZz8PzG9R+ff/55YmJi/SfhHThwYOnSpYcPH46NjR0xYkSPHj10LC+YLFq0qKqqyjM5adIk9+Xze/fuXbBggZTymmuuadOmjXupy+VatGjR999/36lTpz//+c/n8eUPqiAEAOBcBc85QgAAzgNBCAAwNIIQAGBoBCEAwNAIQgCAoRGEAABDIwgBAIZGEAIBYMOGDe+8847eVQDBiSAEAsD7779/9913610FEJwIQsDvlJaWVldXn+XKDoejqKjo1KlTja1QU1NT//b89dlstpKSEpfLdT5VAsGCIAT8haZpjz32WExMTFJSUkxMTExMzKxZs4QQt99+++zZs8vLy+Pi4uLi4jz3FK6oqJgyZUpsbGxqampUVNSkSZMqKyvdi3bt2hUXF/fuu++OHTs2KioqOTm5R48e33//vWdbH3zwQevWrd2LwsPDx44d6/vPC/gJ7swL+Iv58+c/+eSTL7744ogRI1RV3blzp/vpa3/9619LSkq+/PLLRYsWCSHc9xR2OBzDhw8vKyt7++23u3fvvnPnzhkzZlx55ZXffPONEEJV1crKyhkzZkyaNCk/P7+4uPiOO+4YOXLkzp074+PjDxw4cM011/zlL39ZsmRJeHj4gQMHVq5cqetHB3SlAfAPM2bMyMnJ8bro7rvvTkhIqD/nzTffFEJs3rzZM+fzzz8XQmzatEnTtB9++EEIMXToUM/S7du3SymffvppTdM++ugjIcTBgweb41MAAYeuUcBf9OzZc//+/ZMmTfrss89OnDhx+pWXL1+ekJBQWVn51S+cTqcQwh2BbuPHj/e87tKlS/v27d1PtO/SpUtISMiECRPmzp1bXFzcPJ8GCBh0jQL+YvLkySUlJa+99trChQvDwsJGjBjx/PPPt2vXzuvKxcXFVVVVEyZMqD8zNja2oqLCM5mSklJ/aWpq6uHDh4UQrVu3/vDDDx977LEbb7xRCNGnT58nnnhi5MiRTf+RgEBAixDwF4qi3HPPPYWFhbt3737uuefy8vJGjx6tNfLE0Ojo6IyMjIrfqX+VRVlZWf1/Ulpampqa6n79pz/9KS8vr6ioaP78+S6Xa+zYsXv37m2+jwb4M4IQ8Dvt2rW74447Hn744cLCQnfXZYsWLU6ePFl/naFDhx44cGDTpk2neZ9ly5Z5Xh84cGDXrl1dunSpv0JSUtKkSZPmzp1bW1ubn5/fpB8CCBgEIeAvnn322Xnz5h0+fNjlcu3bt+/999/PyMhITk4WQnTu3Lmmpubll1/euHGj+yqIadOmtW7desKECR9//HFlZWVFRcX69eunT5/u7vx0+/rrr59//vnjx4/v3r178uTJFovlpptuEkJ8/PHHzz777O7du2tra93jTk0mU/fu3fX64IDO9B6tA+BnM2fOjIiI8PxtduvWLS8vz73I6XTedtttKSkpUsqYmBj3zEOHDo0ePVpK6V7fZDINHjy4uLhY+2XU6CuvvNK1a1f30uTk5OXLl7v/4UcffZSUlOTZUHJy8jvvvKPLRwb8gdQaOQMBwPfq6ur27dt3/Pjx1NTUjIwMT8idRllZWWFhodVqzczMjIqKcs/csWNHly5dPv7448svv3zXrl12u71r166hoaGef6Vp2qFDh4qLi2NiYnJyckJCQprrIwF+j1GjgB8JCQnp0KHDOf2ThISEhISExpZKKTt27Oh1flZWVlZW1jmXCAQdzhECAAyNIASCUFpa2htvvMH4F+BscI4QAGBotAgBAIZGEAIADI0gBAAY2v8H6ueavpU+XhEAAAAASUVORK5CYII=\" />\n\nLet's now consider the energy cost function directly over the special unitary group mathcalL textSU(2^n) rightarrow mathbbR\n\nmathcalL(U) = textTrHUrho_0U^dagger\n\nTo minimize the cost function we can follow the Riemannian gradient flow defined through the following differential equation\n\ndotU = -textgradmathcalL(U) = Urho_0U^dagger HU\n\nDiscretizing the flow we get the following recursive update rule\n\nU_k + 1 = expalphaU_krho_0U^dagger_k HU_k = expalpharho_k HU_k\n\nwhere alpha is the appropriate learning rate and U_0 = I.\n\nWe can expand the commutator in the exponent in the basis of Pauli strings P^j\n\nrho_k H = frac12^nsum_j = 1^4^n - 1omega^j_kP^j\n\nwhere\n\nomega^j_k = textTrrho_k HP^j = textTrH P^jrho_k = langleH P^jrangle_rho_k\n\nIt turns out that omega^j_k can easily be evaluated with the help of a parameter shift rule\n\nomega^j_k = langleH P^jrangle_rho_k = -ilangle V^dagger_j(pi4)HV_j(pi4) - V^dagger_j(-pi4)HV_j(-pi4)rangle_rho_k\n\nwhere V_j(t) = exp-itP^j.\n\nNext, we write a function for generation of 2-local Pauli operators. We will restrict the Riemannian gradient to this subspace of the Lie algebra since otherwise the number of parameters to calculate would be 4^8 - 1 = 65535 which is too much for a reasonable runtime of the algorithm.\n\nfunction generate_2local_pauli_strings(n)\n    pauli_strings = []\n    for i = 1:n\n        push!(pauli_strings, kron(n, i => X))\n        push!(pauli_strings, kron(n, i => Y))\n        push!(pauli_strings, kron(n, i => Z))\n    end\n    for i = 1:n-1\n        for j = i+1:n\n            for P1 in [X, Y, Z]\n                for P2 in [X, Y, Z]\n                    push!(pauli_strings, kron(n, i => P1, j => P2))\n                end\n            end\n        end\n    end\n    pauli_strings\nend;\n\nNext we write functions for calculating the expansion coefficients and a single optimization step. We will absorb the factor of 12^n into the learning rate.\n\nfunction calculate_omegas(n, reg, h, pauli_strings)\n    iω = []\n    for P in pauli_strings\n        push!(iω, real(expect(h, reg => time_evolve(P, π/4)) - expect(h, reg => time_evolve(P, -π/4))))\n    end\n    iω\nend;\n\nfunction step_and_cost!(n, circuit, h, α, pauli_strings)\n    iω = calculate_omegas(n, zero_state(n) |> circuit, h, pauli_strings)\n\n    for (iωʲ, P) in zip(iω, pauli_strings)\n        if abs(iωʲ) > 1e-6 # we will only keep the ones that actually contribute\n            append!(circuit, chain(n, time_evolve(P, -α * iωʲ)))\n        end\n    end\n\n    real(expect(h, zero_state(n) => circuit))\nend;\n\nFinally, let's try it out. We initialize the state 0rangle and apply several optimization steps.\n\ncircuit = chain(n)\npauli_strings = generate_2local_pauli_strings(n)\nhistory = Float64[]\n\nfor i=1:100\n    cost = step_and_cost!(n, circuit, h, 0.01, pauli_strings)\n    push!(history, cost)\nend\n\nPlots.plot(history, legend=false)\nPlots.plot!(1:100, [w[1] for i=1:100])\nxlabel!(\"steps\")\nylabel!(\"energy\")\n\n<img src=\"/assets/images/Riemannian.png\" alt=\"Riemannian gradient flow\" width=\"600\"/>\n\nWhen we compare the final states achieved with the Riemannian gradient flow optimizer and with the standard VQE we can notice that the former has lower quality. This is because the Riemannian gradient flow optimizer has only a local view of the cost landscape while VQE can access these directions since the ansatz we used is universal. However, if we were able to calculate all of the 4^n - 1 projections, Riemannian gradient flow optimizer would be guaranteed to converge given the appropriate learning rate!\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"dev/index.html#Developer-Notes","page":"Developer Notes","title":"Developer Notes","text":"","category":"section"},{"location":"dev/index.html#Overview-of-the-Architecture","page":"Developer Notes","title":"Overview of the Architecture","text":"The following is an overview of the entire ecosystem, where Yao and CuYao are two meta-packages.\n\n(Image: stack)","category":"section"},{"location":"dev/index.html#The-role-of-QBIR","page":"Developer Notes","title":"The role of QBIR","text":"Currently the main functionality is built on the Quantum Block Intermediate Representation (QBIR). A quantum program is defined by QBIR and then interpreted to different targets, such as different simulation backend or matrix representation.\n\n(Image: framework)","category":"section"},{"location":"generated/examples/7.variation-quantum-eigen-solver/index.html","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"(Image: )","category":"section"},{"location":"generated/examples/7.variation-quantum-eigen-solver/index.html#Variational-Quantum-Eigen-Solver","page":"Variational Quantum Eigen Solver","title":"Variational Quantum Eigen Solver","text":"using Yao, Yao.AD, Yao.EasyBuild\n\nnumber of qubits\n\nn = 4\n\n4\n\ndepth\n\nd = 5\ncircuit = dispatch!(variational_circuit(n, d),:random)\n\ngatecount(circuit)\n\nnparameters(circuit)\n\nh = heisenberg(n)\n\nnqubits: 4\n+\n├─ +\n│  ├─ repeat on (1, 2)\n│  │  └─ X\n│  ├─ repeat on (1, 2)\n│  │  └─ Y\n│  └─ repeat on (1, 2)\n│     └─ Z\n├─ +\n│  ├─ repeat on (2, 3)\n│  │  └─ X\n│  ├─ repeat on (2, 3)\n│  │  └─ Y\n│  └─ repeat on (2, 3)\n│     └─ Z\n├─ +\n│  ├─ repeat on (3, 4)\n│  │  └─ X\n│  ├─ repeat on (3, 4)\n│  │  └─ Y\n│  └─ repeat on (3, 4)\n│     └─ Z\n└─ +\n   ├─ repeat on (1, 4)\n   │  └─ X\n   ├─ repeat on (1, 4)\n   │  └─ Y\n   └─ repeat on (1, 4)\n      └─ Z\n\n\npick the one you like either reverse-mode or forward mode grad = faithfulgrad(h, zerostate(n) => circuit; nshots=100)\n\nfor i in 1:1000\n      _, grad = expect'(h, zero_state(n) => circuit)\n      dispatch!(-, circuit, 1e-2 * grad)\n      println(\"Step $i, energy = $(real.(expect(h, zero_state(n)=>circuit)))\")\nend\n\nusing LinearAlgebra\nw, _ = eigen(Matrix(mat(h)))\n\nLinearAlgebra.Eigen{ComplexF64, Float64, Matrix{ComplexF64}, Vector{Float64}}\nvalues:\n16-element Vector{Float64}:\n -7.9999999999999964\n -4.0\n -3.9999999999999956\n -3.999999999999994\n -7.437659514860159e-32\n -4.426399962566284e-32\n  0.0\n  2.7369110631344083e-48\n  2.003298162163793e-32\n  3.552713678800501e-15\n  4.440892098500626e-15\n  3.9999999999999987\n  3.9999999999999996\n  4.0\n  4.0\n  4.0\nvectors:\n16×16 Matrix{ComplexF64}:\n      0.0+0.0im          0.0+0.0im           0.0+0.0im   0.0+0.0im           0.0+0.0im          0.0+0.0im        0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im        0.0+0.0im  1.0+0.0im   0.0+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im          -0.5+0.0im   0.0+0.0im      0.559869+0.0im      0.43191+0.0im        0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im          -0.5+0.0im        0.0+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.5+0.0im   0.0+0.0im   2.22045e-16+0.0im          0.0+0.0im        0.0+0.0im           0.0+0.0im      0.707107+0.0im           0.0+0.0im           0.0+0.0im          -0.5+0.0im        0.0+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n 0.288675+0.0im  9.56933e-17+0.0im   6.41024e-18+0.0im   0.0+0.0im      0.481733+0.0im    -0.624453+0.0im        0.0+0.0im     -0.211325+0.0im   1.34897e-17+0.0im           0.0+0.0im     -0.288675+0.0im  -6.41024e-18+0.0im  -0.408248+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im          -0.5+0.0im   0.0+0.0im     -0.559869+0.0im     -0.43191+0.0im        0.0+0.0im           0.0+0.0im   2.22045e-16+0.0im           0.0+0.0im           0.0+0.0im          -0.5+0.0im        0.0+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n -0.57735+0.0im     0.707107+0.0im  -1.30125e-33+0.0im   0.0+0.0im  -1.30736e-32+0.0im          0.0+0.0im        0.0+0.0im  -8.71576e-33+0.0im   3.06708e-33+0.0im           0.0+0.0im  -1.97795e-16+0.0im   1.30125e-33+0.0im  -0.408248+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n 0.288675+0.0im  9.56933e-17+0.0im  -2.39233e-17+0.0im   0.0+0.0im      -0.12908+0.0im     0.167322+0.0im        0.0+0.0im      0.788675+0.0im   2.77891e-17+0.0im           0.0+0.0im     -0.288675+0.0im   2.39233e-17+0.0im  -0.408248+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.0+0.0im  -0.5+0.0im           0.0+0.0im          0.0+0.0im   0.707107+0.0im           0.0+0.0im           0.0+0.0im  -4.71028e-16+0.0im           0.0+0.0im           0.0+0.0im        0.0+0.0im  0.0+0.0im  -0.5+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.5+0.0im   0.0+0.0im  -1.29477e-16+0.0im  6.29876e-17+0.0im        0.0+0.0im   6.06671e-17+0.0im     -0.707107+0.0im           0.0+0.0im           0.0+0.0im          -0.5+0.0im        0.0+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n 0.288675+0.0im  9.56933e-17+0.0im   1.75131e-17+0.0im   0.0+0.0im     -0.352653+0.0im     0.457131+0.0im        0.0+0.0im      -0.57735+0.0im  -4.12788e-17+0.0im           0.0+0.0im     -0.288675+0.0im  -1.75131e-17+0.0im  -0.408248+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n -0.57735+0.0im    -0.707107+0.0im   1.30125e-33+0.0im   0.0+0.0im   1.30736e-32+0.0im          0.0+0.0im        0.0+0.0im   8.71576e-33+0.0im  -3.06708e-33+0.0im           0.0+0.0im  -3.14995e-16+0.0im  -1.30125e-33+0.0im  -0.408248+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.0+0.0im   0.5+0.0im           0.0+0.0im          0.0+0.0im        0.0+0.0im           0.0+0.0im           0.0+0.0im     -0.707107+0.0im           0.0+0.0im           0.0+0.0im        0.0+0.0im  0.0+0.0im  -0.5+0.0im  0.0+0.0im\n 0.288675+0.0im          0.0+0.0im           0.0+0.0im   0.0+0.0im           0.0+0.0im          0.0+0.0im        0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im      0.866025+0.0im           0.0+0.0im  -0.408248+0.0im  0.0+0.0im   0.0+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.0+0.0im  -0.5+0.0im           0.0+0.0im          0.0+0.0im  -0.707107+0.0im           0.0+0.0im           0.0+0.0im  -4.71028e-16+0.0im           0.0+0.0im           0.0+0.0im        0.0+0.0im  0.0+0.0im  -0.5+0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.0+0.0im   0.5+0.0im           0.0+0.0im          0.0+0.0im        0.0+0.0im           0.0+0.0im           0.0+0.0im      0.707107+0.0im           0.0+0.0im           0.0+0.0im        0.0+0.0im  0.0+0.0im  -0.5-0.0im  0.0+0.0im\n      0.0+0.0im          0.0+0.0im           0.0+0.0im   0.0+0.0im           0.0+0.0im          0.0+0.0im        0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im           0.0+0.0im        0.0+0.0im  0.0+0.0im   0.0+0.0im  1.0+0.0im\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/5.shor-9-code/index.html","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"(Image: )","category":"section"},{"location":"generated/examples/5.shor-9-code/index.html#Shor's-9-qubit-code","page":"Shor's 9 qubit code","title":"Shor's 9 qubit code","text":"The well-known Shor's 9 qubit code can correct any single Pauli error, but it can also correct some other kinds of errors. Its circuit is shown as below (Image: shor-9-circuit) which can be constructed by the following code\n\nusing Yao\nusing SymEngine\n\nshor(E) = chain(9,\n    # encode circuit\n    cnot(1, 4), cnot(1, 7),\n    put(1=>H), put(4=>H), put(7=>H),\n    cnot(1,2), cnot(1,3), cnot(4,5), cnot(4,6), cnot(7,8), cnot(7,9),\n    E, # the error\n    # decode circuit\n    cnot(1,2), cnot(1,3), cnot((2, 3), 1),\n    cnot(4,5), cnot(4,6), cnot((5, 6), 4),\n    cnot(7,8), cnot(7,9), cnot((8, 9), 7),\n    put(1=>H), put(4=>H), put(7=>H), cnot(1, 4), cnot(1, 7), cnot((4, 7), 1)\n)\n\nshor (generic function with 1 method)\n\nNow we can check whether it can correct a given error by doing symbolic computation on an arbitrary 1-qubit pure quantum state α0 + β1 and a specific weight-9 error.\n\n@vars α β\ns = α * ket\"0\" + β * ket\"1\" |> append_qudits!(8)\nE = kron(1=>X, 2=>Z, 3=>Z, 4=>X, 5=>Z, 6=>Z, 7=>X, 8=>Z, 9=>Z);\ns |> shor(E) |> expand\n\nα|110110110⟩ + β|110110111⟩\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"benchmarks.html#Benchmarks","page":"Benchmarks","title":"Benchmarks","text":"","category":"section"},{"location":"benchmarks.html#Benchmark-Guard","page":"Benchmarks","title":"Benchmark Guard","text":"To ensure some PR do not contain performance regression, we defined package benchmarks with PkgBenchmark in each component package, you can run the benchmark suite and compare the performance between different version and commits.","category":"section"},{"location":"benchmarks.html#Benchmark-with-Other-Packages","page":"Benchmarks","title":"Benchmark with Other Packages","text":"We also provide benchmarks comparing to other packages, you can find a complete benchmark results here: quantum-benchmarks\n\na glance of Yao's benchmark comparing to other packages:\n\n(Image: relative-gate)\n\n(Image: relative-circuit)","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"(Image: )","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#example-ghz","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","text":"First, you have to use this package in Julia.\n\nusing Yao\n\nNow, we just define the circuit according to the circuit image below: (Image: ghz)\n\ncircuit = chain(\n    4,\n    put(1=>X),\n    repeat(H, 2:4),\n    control(2, 1=>X),\n    control(4, 3=>X),\n    control(3, 1=>X),\n    control(4, 3=>X),\n    repeat(H, 1:4),\n)\n\nnqubits: 4\nchain\n├─ put on (1)\n│  └─ X\n├─ repeat on (2, 3, 4)\n│  └─ H\n├─ control(2)\n│  └─ (1,) X\n├─ control(4)\n│  └─ (3,) X\n├─ control(3)\n│  └─ (1,) X\n├─ control(4)\n│  └─ (3,) X\n└─ repeat on (1, 2, 3, 4)\n   └─ H\n\n\nLet me explain what happens here.","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#Put-single-qubit-gate-X-to-location-1","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Put single qubit gate X to location 1","text":"we have an X gate applied to the first qubit. We need to tell Yao to put this gate on the first qubit by\n\nput(4, 1=>X)\n\nnqubits: 4\nput on (1)\n└─ X\n\nWe use Julia's Pair to denote the gate and its location in the circuit, for two-qubit gate, you could also use a tuple of locations:\n\nput(4, (1, 2)=>swap(2, 1, 2))\n\nnqubits: 4\nput on (1, 2)\n└─ put on (1, 2)\n   └─ SWAP\n\n\nBut, wait, why there's no 4 in the definition above? This is because all the functions in Yao that requires to input the number of qubits as its first arguement could be lazy (curried), and let other constructors to infer the total number of qubits later, e.g\n\nput(1=>X)\n\n(n -> put(n, 1 => X))\n\nwhich will return a lambda that ask for a single arguement n.\n\nput(1=>X)(4)\n\nnqubits: 4\nput on (1)\n└─ X","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#Apply-the-same-gate-on-different-locations","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Apply the same gate on different locations","text":"next we should put Hadmard gates on all locations except the 1st qubits.\n\nWe provide repeat to apply the same block repeatly, repeat can take an iterator of desired locations, and like put, we can also leave the total number of qubits there.\n\nrepeat(H, 2:4)\n\n(n -> repeat(n, H, 2:4...))","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#Define-control-gates","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Define control gates","text":"In Yao, we could define controlled gates by feeding a gate to control\n\ncontrol(4, 2, 1=>X)\n\nnqubits: 4\ncontrol(2)\n└─ (1,) X\n\nLike many others, you could leave the number of total qubits there, and infer it later.\n\ncontrol(2, 1=>X)\n\n(n -> control(n, 2, 1 => X))","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#Composite-each-part-together","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Composite each part together","text":"This will create a ControlBlock, the concept of block in Yao basically just means quantum operators, since the quantum circuit itself is a quantum operator, we could create a quantum circuit by composite each part of.\n\nHere, we use chain to chain each part together, a chain of quantum operators means to apply each operators one by one in the chain. This will create a ChainBlock.\n\ncircuit = chain(\n    4,\n    put(1=>X),\n    repeat(H, 2:4),\n    control(2, 1=>X),\n    control(4, 3=>X),\n    control(3, 1=>X),\n    control(4, 3=>X),\n    repeat(H, 1:4),\n)\n\nnqubits: 4\nchain\n├─ put on (1)\n│  └─ X\n├─ repeat on (2, 3, 4)\n│  └─ H\n├─ control(2)\n│  └─ (1,) X\n├─ control(4)\n│  └─ (3,) X\n├─ control(3)\n│  └─ (1,) X\n├─ control(4)\n│  └─ (3,) X\n└─ repeat on (1, 2, 3, 4)\n   └─ H\n\n\nYou can check the type of it with typeof\n\ntypeof(circuit)\n\nChainBlock{2}","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#Construct-GHZ-state-from-00...00","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Construct GHZ state from 00...00","text":"For simulation, we provide a builtin register type called ArrayReg, we will use the simulated register in this example.\n\nFirst, let's create 0000, you can create it with zero_state\n\nzero_state(4)\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\nOr we also provide bit string literals to create arbitrary eigen state\n\nArrayReg(bit\"0000\")\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\nThey will both create a register with Julia's builtin Array as storage.","category":"section"},{"location":"generated/examples/1.prepare-ghz-state/index.html#Feed-Registers-to-Circuits","page":"Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit","title":"Feed Registers to Circuits","text":"Circuits can be applied to registers with apply!\n\napply!(zero_state(4), circuit)\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\nor you can use pipe operator |>, when you want to chain several operations together, here we measure the state right after the circuit for 1000 times\n\nresults = zero_state(4) |> circuit |> r->measure(r, nshots=1000)\n\nusing StatsBase, Plots\n\nhist = fit(Histogram, Int.(results), 0:16)\nbar(hist.edges[1] .- 0.5, hist.weights, legend=:none)\n\n<img src=\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAlgAAAGQCAIAAAD9V4nPAAAABmJLR0QA/wD/AP+gvaeTAAAdYElEQVR4nO3deXRU5d3A8WfWLEzGLASyimxuECUkBBGQpWRpMViw9JWCC1sBCW3dWltP9dStLlXZToUKR5FyPNRolSr1AAokNpFFIQYriRLQkExCLXvWWe77x23nzYtAJswdJ/D7fv6a++Ty5BkmM9/cmZsZk6ZpCgAAqczhXgAAAOFECAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiWcP77Tdt2uTz+QoKCgyfua6+fuvn9Z3u5vV6LRbL+fdJiFB5IzI73Q3h5fF4rNYw/zzDKG6322azhXsVMIDX6zWbzSaTKdwLOZ8wP3CUl5drmhaKEK5YseLx9/aroVOCn8q6ZvY3DfWXXXZZ8FMhdNra2sxms9nMkxyXgtbWVkJ4aXC73VartZv/ktqtFxeslGtV9q3BT2NZNz/4SQAA3RO/PgMARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEC3QP6ivqKiorq72b06ZMkV/yzFN0956663q6urBgwdPnDjRv0N9fX1xcbGmaVOmTElPTzd20QAAGCXQEK5du3bjxo2DBw/WNydNmqSHcOHChR9++OGPfvSj+++/v7S09KmnnlJKffXVV9nZ2bfeeqvNZhsyZMjOnTv79+8foisAAEAwuvAWa1OmTHn88cc7jhw+fPjll18+cOBASkrK9OnTMzIyHnjggYSEhKVLl06cOHHFihVKKY/H88ILLyxfvtzghQMAYIQuvEb4xRdfrFq1asuWLV6vVx/ZunXrddddl5KSopTq37//FVdcUVpaqpTavHmz/2nSiRMnbtq0yehlAwBgjECPCGNiYjwez0cfffTcc885HI6tW7c6HI76+vqkpCT/PklJSfX19UqpjuPJycn64FnV19fv27evqalJ34yMjCwqKoqNjb3Aa9OBx+M16lQgTam2tra2tjZDZkOI8OkTl5K2tja73R7uVcAAbW1tXq/Xf/j03bPb7Z1+CFSgIXzkkUf0C263e8SIEcuWLfv1r39tNps1TfPvo2ma/v1MJpN/3OfznWcRVqs1KioqLi5O3zSbzTabzZDHMgM//sqkFI+w3Z/5v8K9EBiAm/KScVHcMbv8MUw2m238+PH79+9XSqWkpLhcLv+XXC6X/jRpSkpKQ0ODPtjQ0JCamnqu2Xr16pWYmPib3/ymywvvjMVi5P+7zWbj09G6Of026ub3NwSIe9wlw+v1dv/PIwz0UcPn8/kvlJaWDhw4UCk1fvz4ffv21dbWKqWqqqpqa2tvuukmpVRBQcGGDRv0/Tds2BCKz90FAMAQgVY6MzMzMzMzPj5+69atHo9n0aJFSqnk5OQFCxbk5eXdcsstxcXF999/v/4k56JFi4YNG3bnnXdardZ33nlnx44dIbwGAAAEIdAQrlmz5pNPPjl16tSTTz6Zm5vrP859/vnnv//973/++eerVq0aO3asPpiWllZZWfn222/7fL7f//73vXr1CsXSAQAIXqAhHDJkyJAhQ876pdzc3Nzc3DMGe/bsOXv27KCWBgBA6HFmAQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0br1G6ECALqt0tJS/+crnIvb7TabzRaL5fy7XXnllddff71xS+saQggAuBD/c8esE7EDTJGO8+6lfyTf+T4Xz3vcNbxP3Lb3/mbg2rqEEAIALoTXpzX/eLFK7BfsRJ++661abcSKLhCvEQIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANGtX/8Gbb76padqtt96qb3o8nldeeaWqqiojI2PGjBlm83/KWl1dvW7dOp/P95Of/OSaa64xcskAABina0eEW7ZsmTlz5uOPP+4fueuuu15++eUrrrhi6dKlRUVF+mB1dXVOTo7X67VYLDfccMNnn31m5JIBADBOF44Im5qa7r333l/+8pfFxcX6SE1NzRtvvHH48OGEhIRbbrllwIABDz/8cFJS0pIlS6ZNm6b38uTJky+88MKqVatCsnwAAILThSPCBx98cM6cOX379vWPlJaWZmZmJiQkKKXS0tIGDhxYVlamlNq+fXtubq6+T15e3rZt24xcMgAAxgn0iLC8vHz37t2LFy9ev369f7ChoSExMdG/2bt37/r6eqWUy+Xq1auXPtirVy+Xy3Wuab/++us9e/YcPnxY3zSbzY888ohe1iB5PB6l7MHPo5TSNNXa2hoREWHIbAiR1tZWk8nkf5UaF7XW1labzRbuVaAzmmbYTD5fa2urUbN1ZLfbO31YCCiEbW1t8+bNe/XVVy0Wy//7x1ar1+v1b7rdbv1n12q1ejwefdDj8ZznB9rhcKSmpmZnZ+ubZrPZ6XQacgcwmy2d7xQYk0nZbDbult2cfhsRwksD97iLg8m4mUymEN3iJlPnqwwohOXl5QcPHpwzZ45S6ujRo42NjdnZ2aWlpSkpKXV1df7d6uvrU1NTlVKpqan6oaFSqq6uLiUl5Vwzx8fHx8XFzZ8/P5BldInZbNxNpJTFYjnjlwB0N/ptRAgvDdzjLhJGljCMt3hAjxpZWVnbtm1buXLlypUrZ8+enZaWtnLlyoiIiNzc3KqqqurqaqXU3r17Gxsbx4wZo5QqLCz0n1BTXFxcWFgYuisAAEAwAjoijImJycrK0i9XVVVFR0frmz179nzwwQdzc3Pz8/M3btz4u9/9LiYmRim1cOHCESNGFBYWWq3WTz75pLy8PHRXAACAYHT5D+oLCgoyMzP9mw8//PDEiRM///zzhQsXXn/99fpgr169KioqNm/e7PP51qxZ43Q6DVsvAACG6nII4+Pj4+PjO45kZWX5jxf9HA7H5MmTg1oaAAChx5kFAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANGuA+3344YfvvvvukSNHEhISpk+ffv311+vjLS0ty5Ytq6qqysjIuPvuu+12uz7+8ccfv/LKKz6f74477hg+fHhI1g4AQNACPSLcsWNHbGzsuHHj7Hb7jTfeuHPnTn182rRp77///oQJE9566605c+bog5WVlePGjevbt+9VV12Vl5f38ccfh2TtAAAELdAjwvvuu89/uaqq6p133snJyamqqtq0aVNDQ4PT6ZwwYUJ6evoTTzyRnp6+ZMmSWbNm3XvvvUopl8u1ePHitWvXhmT5AAAEp8uvEX799dd79uzJyclRSpWXlw8dOtTpdCqlEhMTr7766h07diilysrKxo0bp+8/bty4srIyQ9cMAIBhAj0iVEqtXLnygQceOHXq1D333HPzzTcrpVwuV8+ePf07JCYmulwupVRDQ4N/PDExsb6+/lxz1tTU7Nq1q7KyUt80m83PPPNM7969L+CanMHtdisVEfw8SilNUy0tLTabzZDZECLNzc2appnNnP91KWhpabFYLOFeBTqhaZpRU/l83ubmZqNm6ygyMrLTh4UuhHDevHmzZ8+urKycNm3awIEDFyxYEBkZ6Xa7/Tu0tbVFRkYqpSIiItrb2/XB9vb2qKioc83Zs2fPQYMGTZ06Vd80m83Jycn+M26CYbV24aqdn8mkIiIi9KuGbsvr9QbyE4+Lgtvt5h7X/ZlMJqOmMpvMIbrFA3lM6FotrFZrZmbmnDlzNmzYsGDBgtTU1NraWv9Xa2tr09LSlFJpaWn+8dra2tTU1HNN6HQ6Bw0a9OMf/7hLywiEgbeQUspsNvMI282Z/yvcC4EBuCnFMZnCeIsH+o2PHj2qX/D5fCUlJQMGDFBK5eXl1dTUVFRUKKXKyspOnDgxduxYpdTkyZNfe+01/ah53bp1U6ZMCcXSAQAIXqBHhEOGDElPT09ISKisrOzZs+fq1auVUrGxsU888UR+fv7IkSNLS0ufffZZ/VnQBQsWrF+/ftSoUVar9ZtvvnnppZdCeA0AAAhCoCGsqqrau3fv8ePHL7/88muvvdb/xOPPf/7zm2++ubq6+vnnn+/Tp48+GBcXt3v37rKyMk3TbrzxRkNe8wMAIBQCDWFUVNSIESPO+qX+/fv379//jEGbzTZmzJiglgYAQOjxcjQAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABCNEAIARCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBANEIIABDNGuB+77///oYNG77++uu0tLSFCxdeffXV+vjx48efeuqp/fv3Z2Rk/OpXv3I4HP79V69e7fP5Zs6cmZ+fH5K1AwAQtECPCB999NHU1NSZM2dGR0cPHz68pqZGH586dWpNTc2CBQsqKiruuOMOfXDXrl1TpkzJz88vLCy87bbb/vGPf4Rk7QAABC3QI8Lt27frFyZNmlRSUvLee+/dfffdn376aXl5+ZEjR/Q6JiUl1dTU9OvXb+nSpfPnz7/zzjuVUl988cWSJUtGjhwZqmsAAEAQuvwaocfjqa+vT0lJUUrt3r07KysrOjpaKRUbG3vttdfu3r1bKbVr165Ro0bp+48ePXrXrl2GrhkAAMMEekTo99vf/jY5ObmwsFAp1dDQEB8f7/9Sz549GxoalFKNjY3+8YSEBJfLda7Zqqury8rKSkpK9E2z2fziiy8mJyd3dVXf1t7erlRk8PMopTRNNTU1WSwWQ2ZDiDQ3N3u9XrOZ878uBU1NTSaTKdyrQCc0TTNqKp/Xe/r0aaNm6yg6OrrTh4WuhXDp0qWvv/56SUmJXoUePXq0tbX5v9rc3NyjRw/9G/vHW1pa/GfQfFtaWtro0aP9Ly6azeZ+/foZkhy73R78JDqTSfXo0eM81wLdgclkioqKIoSXBk3TuMd1fwb+smK2WMJ4i3chhCtXrnzhhRe2bdumPy+qlEpLSzt06JB/h6+++io9PV0plZ6e7h8/dOiQPnhW0dHR/fr1mzBhQtdXDgCAAQL99fmVV1558sknt2zZ0qdPH/9gfn5+XV1deXm5Umrz5s3t7e1jx45VSk2dOvXVV1/1er0+n2/NmjVTp04NwcoBADBAoCEsKio6cuTIsGHD4uPj4+PjH3vsMaWUw+FYsmRJYWHhuHHjpk2btnz5cv0JyXnz5nm93uuuu27IkCHHjx8vKioK4TUAACAIgT41evjw4Y6vi0ZG/uc8lLvuumvixIk1NTUDBw70nyDjcDhKSkr27dunaVpGRgYvegMAuq1AQxgbG3uuLyUmJiYmJp4xaDKZMjIyLnxdAAB8JzjFDgAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiBZoCL/44otly5bNmjXrqaee6jje2Ng4d+7cUaNGLVy48OjRo/7xN954Iz8/Pzc3d/369UauFwAAQwUawk2bNu3cudPlcn344YcdxydPnqyUWrx48cmTJ6dNm6YPlpaWzp07d9GiRffdd19RUdGWLVuMXTQAAEYJNIQLFy5cu3bthAkTOg7u3r37s88+W758eXZ29osvvlhSUlJVVaWUWr58eVFR0c0331xQUHDvvfcuX77c+IUDAGCEoF4j3Lt379ChQyMiIpRSDodj0KBBe/bs0ceHDx+u73PDDTfogwAAdEPWYP7xkSNH4uLi/Jvx8fGNjY1KqcbGRv94fHx8Q0PDuWb45z//WVJSsmHDBn3TZDKtW7cuLS0tmFXp2tvblYoMfh6llKappqYmi8ViyGwIkebmZq/XazZz/teloKmpyWQyhXsV6ISmaUZN5fN6T58+bdRsHUVHR3f6sBBUCGNiYpqbm/2bTU1NTqfzjPGmpqbLLrvsXDMMGDAgNjb2pz/9qb4ZERFx1VVXGXIHsNvtwU+iM5lUjx49HA6HURMiFEwmU1RUFCG8NGiaxj2u+zPwlxWzxRLGWzyoEPbp0+fAgQP6ZU3TDh482KdPH328pqZGHz9w4IA+eFZ2uz05OTkrKyuYZQAAcMGC+vU5Ly/v2LFjmzdvVkq99dZbZrP5pptuUkpNmzZt9erV7e3tHo/npZde8p9NCgBAdxPoEeGf//zn22+/Xb9sMplmzZq1evXqyMhIvXMpKSmNjY1r1qyxWq1KqdmzZ2/atKlv374Wi2Xw4MHz588P1fIBAAhOoCGcMWPGjBkzvj0+efLkgoKCurq69PR0/fRRpVRkZOTbb7/tcrl8Pl9qaqphiwUAwGhBvUaoi4qKGjBgwLfHk5OTg58cAICQ4hQ7AIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEAAgGiEEAIhGCAEAohFCAIBohBAAIBohBACIRggBAKIRQgCAaIQQACAaIQQAiEYIAQCiEUIAgGiEEJeI119/vaamJtyrgAGam5uXL18e7lVAkFCFcNWqVcOGDcvKynrxxRdD9C2Ajv76179WVFSEexUwQGNj48qVK8O9CghiDcWkmzZteuihh958802bzTZ58uS0tLTCwsJQfCMAAIIUkiPCP/7xj0VFRSNHjszJybnnnns4KAQAdFshCeFnn32WnZ2tXx42bFhlZWUovgsAAMEzaZpm+KSxsbEbN2688cYblVIVFRU5OTltbW1n3XPkyJEfffSR2fyfHptMpqSkJKvVgCdsm1tajiVnmyJ7nGcfn8/n9Xhtdtv5pzLX7ettbjKZTP83eXOz2+0OfpFKKZvNFh0d3XHkxIkThsyslIqKirLb7f5Nj8fT1NRk1OROp7Pj/0lLS0t7e7shM1ssFofD0XHk1KlTPp/v/P/q9OnTdru94/U9q4iIiMjISP+mz+c7derUBS/1DA6Hw2Kx+Dfb2tpaW1sNmdlkMjmdzo4jTU1NHo/HkMntdntUVJR/U9O0kydPGjKzUio6Otpm+7+7mNvtbm5uPv8/0W+Uyy67rNPJu9sPYYAiIyMjIiL8m16v9/Tp04bMrEL5Q2g2m2NiYjqOfOOxtydnqA7f7ts8Ho/JZLKcdx/N3d6joSLWZnyMlFLTp09/7LHHzr9PSF4jdDqd/gfcU6dOxcXFnWvPv//977t37/b/H9nt9t69e4diSefS1tbW8ScSF6/29nabzdbxYREXL+6Yl4xAQhhSycnJne4TkhD269evuro6NzdXKVVdXd23b99z7el0OsePHx+KNQAAEIiQvEZ4++23/+lPf2pqamptbV2xYsWMGTNC8V0AAAheSEJ45513Dh06NC0tLSUl5corr5w7d24ovgsAAMELyckyuubmZk3TevQ43+kqAACEVwhDCABA9xeSk2UuCseOHXvppZcaGhry8vIKCgrCvRxcuJKSkv379+uXzWbznDlzwrsedNWBAwc+/vjj48ePT58+veNzSDt27CguLo6JiZk5c2Z6enoYV4gAtbe3f/rpp5WVlXFxcT/84Q/942vWrPH/EV3//v2/973vhWmBZyf0Tbfdbvfo0aP37NnTr1+/uXPnrlq1KtwrwoVbu3bta6+9VlNTU1NTc/DgwXAvB11z6NChnJycFStWzJs379ixY/7xDz74ID8/Pykp6ejRo8OGDTty5EgYF4kALVu27Lbbblu6dOnTTz/dcfyee+755JNP9Dtpd7wpNZFef/31a665xuv1apq2YcOG/v3765dxMZozZ87TTz8d7lXgAul3Pf1tDWpra/3jeXl5f/jDH/TLt9xyyxNPPBGe9aEr9Fvz5ZdfvuGGGzqOx8XFffnll2FaVOeEHhGWlJRMmDBBf0eb3Nzcmpqa2tracC8KF27nzp3PPPPMX/7yF6PeWATfGf8bS52hpKRE/1tkpVRubu727du/w0XhAp3r1lRKrV27dvHixWVlZd/legIkNIQulysxMVG/HBkZ6XQ6XS5XeJeEC5aent67d+/jx48/88wz2dnZBr5bFcLl2LFjra2t/jtpr169uIde1EaOHNnS0nLw4MFJkyY98MAD4V7OmYSeLGO1Wr1er3/T7XZ3+h6V6LYefvhh/cKjjz46bNiwVatW/eIXvwjvkhAk/e1J/W+m6vF4uIde1P72t7/pF+bPnz948OBFixZdfvnl4V1SR0KPCFNTU+vq6vTLx44da25uTklJCe+SEDyr1Tp8+HA+p/4S4HA4nE6n/05aV1cXyDtGovu75ppr4uLiDh06FO6F/D9CQ1hYWLhx40b9ObTi4uKcnJykpKRwLwoXyP/m+qdPn/7ggw8GDRoU3vXAEIWFhcXFxUopn8/35ptvTpo0KdwrwgVqbW3V/vsH62VlZSdPnrzqqqvCu6QzCH1q9Kabbho+fPjIkSOHDBny7rvvrl+/PtwrwoXr06dPTk6O0+ncvn17RkbGzJkzw70idM3o0aP1z6v5wQ9+YLfbP/roI6vV+tBDD40dO/bw4cMul8vj8UyfPj3cy0TnysrKfvazn/373//+17/+lZ2dPWbMmOeee27z5s333Xff0KFDW1paPvjgg2efffY7/pShTsl9Zxmfz7d9+/bGxsZRo0alpaWFezm4cF999dXevXtbW1uvvPLKzMzMcC8HXbZnz56OH/U3dOhQ/eO0jh49+v7778fExIwfP57XCC8KJ06c+PLLL/2bsbGx+h+nVVRUVFdXR0dHZ2VlpaamhnGFZyU3hAAAKLGvEQIAoCOEAADRCCEAQDRCCAAQjRACAEQjhAAA0QghAEA0QggAEI0QAgBEI4QAANEIIQBAtP8FgWGIMTFa15MAAAAASUVORK5CYII=\" />\n\nGHZ state will collapse to 0000 or 1111.\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/cuda.html#CUDA-extension-CuYao","page":"CUDA extension - CuYao","title":"CUDA extension - CuYao","text":"","category":"section"},{"location":"man/cuda.html#Tutorial","page":"CUDA extension - CuYao","title":"Tutorial","text":"CuYao is a CUDA extension of Yao, which allows you to run Yao circuits on GPU. The usage of CuYao is similar to Yao, but with some extra APIs to upload and download registers between CPU and GPU:\n\ncu(reg) to upload a registe reg to GPU, and\ncpu(cureg) to download a register cureg from GPU to CPU.\n\njulia> using Yao, CUDA\n\n# create a register on GPU\njulia> cureg = rand_state(9; nbatch=1000) |> cu;   # or `curand_state(9; nbatch=1000)`.\n\n# run a circuit on GPU\njulia> cureg |> put(9, 2=>Z);\n\n# measure the register on GPU\njulia> measure!(cureg)\n1000-element CuArray{DitStr{2, 9, Int64}, 1, CUDA.Mem.DeviceBuffer}:\n 110110100 ₍₂₎\n 000100001 ₍₂₎\n 111111001 ₍₂₎\n             ⋮\n 010001101 ₍₂₎\n 000100110 ₍₂₎\n\n# download the register to CPU\njulia> reg = cureg |> cpu;","category":"section"},{"location":"man/cuda.html#Features","page":"CUDA extension - CuYao","title":"Features","text":"Supported gates:\n\ngeneral U(N) gate\ngeneral U(1) gate\nX, Y, Z gate\nT, S gate\nSWAP gate\ncontrol gates\n\nSupported register operations:\n\nmeasure!, measurereset!, measureremove!, select\nappendqudits!, appendqubits!\ninsertqudit!, insertqubits!\nfocus!, relax!\njoin\ndensity_matrix\nfidelity\nexpect\n\nAutodiff:\n\nautodiff is supported when the only parameterized gates are rotation gates in a circuit.","category":"section"},{"location":"man/cuda.html#API","page":"CUDA extension - CuYao","title":"API","text":"note: Note\nthe cu function is not documented in this module, but it is used to upload a register to GPU.","category":"section"},{"location":"man/cuda.html#Yao.cpu","page":"CUDA extension - CuYao","title":"Yao.cpu","text":"cpu(cureg)\n\nDownload the register state from GPU to CPU.\n\n\n\n\n\n","category":"function"},{"location":"man/cuda.html#Yao.curand_state","page":"CUDA extension - CuYao","title":"Yao.curand_state","text":"curand_state([T=ComplexF64], n::Int; nbatch=1)\n\nThe GPU version of rand_state.\n\n\n\n\n\n","category":"function"},{"location":"man/cuda.html#Yao.cuzero_state","page":"CUDA extension - CuYao","title":"Yao.cuzero_state","text":"cuzero_state([T=ComplexF64], n::Int; nbatch=1)\n\nThe GPU version of zero_state.\n\n\n\n\n\n","category":"function"},{"location":"man/cuda.html#Yao.cuproduct_state","page":"CUDA extension - CuYao","title":"Yao.cuproduct_state","text":"cuproduct_state([T=ComplexF64], total::Int, bit_config::Integer; nbatch=NoBatch())\n\nThe GPU version of product_state.\n\n\n\n\n\n","category":"function"},{"location":"man/cuda.html#Yao.cuuniform_state","page":"CUDA extension - CuYao","title":"Yao.cuuniform_state","text":"cuuniform_state([T=ComplexF64], n::Int; nbatch=1)\n\nThe GPU version of uniform_state.\n\n\n\n\n\n","category":"function"},{"location":"man/cuda.html#Yao.cughz_state","page":"CUDA extension - CuYao","title":"Yao.cughz_state","text":"cughz_state([T=ComplexF64], n::Int; nbatch=1)\n\nThe GPU version of ghz_state.\n\n\n\n\n\n","category":"function"},{"location":"generated/examples/3.grover-search/index.html","page":"Grover Search","title":"Grover Search","text":"(Image: )","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Grover","page":"Grover Search","title":"Grover Search","text":"using Yao\nusing Yao.EasyBuild: variational_circuit\nusing LinearAlgebra","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Grover-Step","page":"Grover Search","title":"Grover Step","text":"A single grover step is consist of applying oracle circuit and reflection circuit. The reflection_circuit function takes the wave function generator U as the input and returns U|0><0|U'.\n\nfunction grover_step!(reg::AbstractRegister, oracle, U::AbstractBlock)\n    apply!(reg |> oracle, reflect_circuit(U))\nend\n\nfunction reflect_circuit(gen::AbstractBlock)\n    N = nqubits(gen)\n    reflect0 = control(N, -collect(1:N-1), N=>-Z)\n    chain(gen', reflect0, gen)\nend\n\nreflect_circuit (generic function with 1 method)\n\nCompute the propotion of target states to estimate the number of iterations, which requires computing the output state.\n\nfunction solution_state(oracle, gen::AbstractBlock)\n    N = nqubits(gen)\n    reg= zero_state(N) |> gen\n    reg.state[real.(statevec(ArrayReg(ones(ComplexF64, 1<<N)) |> oracle)) .> 0] .= 0\n    normalize!(reg)\nend\n\nfunction num_grover_step(oracle, gen::AbstractBlock)\n    N = nqubits(gen)\n    reg = zero_state(N) |> gen\n    ratio = abs2(solution_state(oracle, gen)'*reg)\n    Int(round(pi/4/sqrt(ratio)))-1\nend\n\nnum_grover_step (generic function with 1 method)","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Run","page":"Grover Search","title":"Run","text":"First, we define the problem by an oracle, it finds bit string bit\"000001100100\".\n\nnum_bit = 12\noracle = matblock(Diagonal((v = ones(ComplexF64, 1<<num_bit); v[Int(bit\"000001100100\")+1]*=-1; v)))\n\nmatblock(...)\n\nthen solve the above problem\n\ngen = repeat(num_bit, H, 1:num_bit)\nreg = zero_state(num_bit) |> gen\n\ntarget_state = solution_state(oracle, gen)\n\nfor i = 1:num_grover_step(oracle, gen)\n    grover_step!(reg, oracle, gen)\n    overlap = abs(reg'*target_state)\n    println(\"step $(i-1), overlap = $overlap\")\nend\n\nstep 0, overlap = 0.04685974121093736\nstep 1, overlap = 0.0780487209558483\nstep 2, overlap = 0.10916148124670066\nstep 3, overlap = 0.14016763852852288\nstep 4, overlap = 0.17103691335084453\nstep 5, overlap = 0.20173915993747182\nstep 6, overlap = 0.23224439562572258\nstep 7, overlap = 0.26252283014636996\nstep 8, overlap = 0.29254489471570244\nstep 9, overlap = 0.322281270911289\nstep 10, overlap = 0.35170291930325104\nstep 11, overlap = 0.3807811078130809\nstep 12, overlap = 0.40948743977231195\nstep 13, overlap = 0.4377938816536402\nstep 14, overlap = 0.46567279044741594\nstep 15, overlap = 0.49309694065677034\nstep 16, overlap = 0.5200395508850146\nstep 17, overlap = 0.5464743099893477\nstep 18, overlap = 0.5723754027753314\nstep 19, overlap = 0.5977175352070423\nstep 20, overlap = 0.6224759591082774\nstep 21, overlap = 0.6466264963306958\nstep 22, overlap = 0.6701455623652912\nstep 23, overlap = 0.6930101893741392\nstep 24, overlap = 0.7151980486199263\nstep 25, overlap = 0.7366874722713579\nstep 26, overlap = 0.7574574745631494\nstep 27, overlap = 0.7774877722899375\nstep 28, overlap = 0.7967588046140988\nstep 29, overlap = 0.8152517521681291\nstep 30, overlap = 0.8329485554329328\nstep 31, overlap = 0.8498319323740713\nstep 32, overlap = 0.8658853953187506\nstep 33, overlap = 0.8810932670570639\nstep 34, overlap = 0.8954406961517668\nstep 35, overlap = 0.9089136714416339\nstep 36, overlap = 0.9214990357242339\nstep 37, overlap = 0.9331844986047592\nstep 38, overlap = 0.9439586484983656\nstep 39, overlap = 0.953810963774298\nstep 40, overlap = 0.9627318230309194\nstep 41, overlap = 0.9707125144916121\nstep 42, overlap = 0.9777452445123718\nstep 43, overlap = 0.983823145192787\nstep 44, overlap = 0.9889402810829753\nstep 45, overlap = 0.9930916549799182\nstep 46, overlap = 0.9962732128075449\nstep 47, overlap = 0.9984818475757891\nstep 48, overlap = 0.9997154024147601\n","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Rejection-Sampling","page":"Grover Search","title":"Rejection Sampling","text":"In practise, it is often not possible to determine the number of iterations before actual running. we can use rejection sampling technique to avoid estimating the number of grover steps.\n\nIn a single try, we apply the grover algorithm for nstep times.\n\nfunction single_try(oracle, gen::AbstractBlock, nstep::Int; nbatch::Int)\n    N = nqubits(gen)\n    reg = zero_state(N+1; nbatch)\n    focus(reg, (1:N...,)) do r\n        r |> gen\n        for i = 1:nstep\n            grover_step!(r, oracle, gen)\n        end\n        return r\n    end\n    reg |> checker\n    res = measure!(RemoveMeasured(), reg, (N+1))\n    return res, reg\nend\n\nsingle_try (generic function with 1 method)\n\nAfter running the grover search, we have a checker program that flips the ancilla qubit if the output is the desired value, we assume the checker program can be implemented in polynomial time. to gaurante the output is correct. We contruct a checker \"program\", if the result is correct, flip the ancilla qubit\n\nctrl = -collect(1:num_bit); ctrl[[3,6,7]] *= -1\nchecker = control(num_bit+1,ctrl, num_bit+1=>X)\n\nnqubits: 13\ncontrol(¬1, ¬2, 3, ¬4, ¬5, 6, 7, ¬8, ¬9, ¬10, ¬11, ¬12)\n└─ (13,) X\n\nThe register is batched, with batch dimension nshot. focus! views the first 1-N qubts as system. For a batched register, measure! returns a vector of bitstring as output.","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Run-2","page":"Grover Search","title":"Run","text":"maxtry = 100\nnshot = 3\n\nfor nstep = 0:maxtry\n    println(\"number of iter = $nstep\")\n    res, regi = single_try(oracle, gen, nstep; nbatch=3)\n\n    # success!\n    if any(==(1), res)\n        overlap_final = viewbatch(regi, findfirst(==(1), res))'*target_state\n        println(\"success, overlap = $(overlap_final)\")\n        break\n    end\nend\n\nnumber of iter = 0\nnumber of iter = 1\nnumber of iter = 2\nnumber of iter = 3\nnumber of iter = 4\nnumber of iter = 5\nsuccess, overlap = -1.0 + 0.0im\n\n\nThe final state has an overlap of 1 with the target state.","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Amplitude-Amplification","page":"Grover Search","title":"Amplitude Amplification","text":"Given a circuit to generate a state, now we want to project out the subspace with [1,3,5,8,9,11,12] fixed to 1 and [4,6] fixed to 0. We can construct an oracle\n\nevidense = [1, 3, -4, 5, -6, 8, 9, 11, 12]\nfunction inference_oracle(nbit::Int, locs::Vector{Int})\n    control(nbit, locs[1:end-1], abs(locs[end]) => (locs[end]>0 ? Z : -Z))\nend\noracle = inference_oracle(nqubits(reg), evidense)\n\nnqubits: 12\ncontrol(1, 3, ¬4, 5, ¬6, 8, 9, 11)\n└─ (12,) Z\n\nWe use a variational circuit generator defined in Yao.EasyBuild\n\ngen = dispatch!(variational_circuit(num_bit), :random)\nreg = zero_state(num_bit) |> gen\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 12/12\n    nlevel: 2","category":"section"},{"location":"generated/examples/3.grover-search/index.html#Run-3","page":"Grover Search","title":"Run","text":"solution = solution_state(oracle, gen)\nfor i = 1:num_grover_step(oracle, gen)\n    grover_step!(reg, oracle, gen)\n    println(\"step $(i-1), overlap = $(abs(reg'*solution))\")\nend\n\nstep 0, overlap = 0.1894456210826676\nstep 1, overlap = 0.3123468853360151\nstep 2, overlap = 0.4302119293499148\nstep 3, overlap = 0.541140320150471\nstep 4, overlap = 0.6433434700068401\nstep 5, overlap = 0.735173475270845\nstep 6, overlap = 0.8151496868538877\nstep 7, overlap = 0.8819825839239752\nstep 8, overlap = 0.9345945658880261\nstep 9, overlap = 0.9721373274135896\nstep 10, overlap = 0.9940055363385208\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/automatic_differentiation.html#Automatic-Differentiation","page":"Automatic Differentiation","title":"Automatic Differentiation","text":"Yao currently contains builtin automatic differentiation engine (an operator overloading based) especially for quantum circuits. It uses the reversible context of quantum computation to optimize the performance during simulation, thus you may find this is way faster than any other AD engine at the moment.","category":"section"},{"location":"man/automatic_differentiation.html#Builtin-Reverse-mode-AD-engine-for-simulation","page":"Automatic Differentiation","title":"Builtin Reverse mode AD engine for simulation","text":"As for expectation, the usage is pretty simple, since the evluation of expectations are just\n\nexpect(H, rand_state(10)=>circuit)\n\nto get the gradients, simply add an adjoint\n\nexpect'(H, rand_state(10)=>circuit)\n\nwhich will return the pair of gradients, one is the gradient of input register and the other is the gradient of circuit parameters.","category":"section"},{"location":"man/automatic_differentiation.html#Integration-with-General-purpose-AD-engine","page":"Automatic Differentiation","title":"Integration with General purpose AD engine","text":"The builtin AD engine for Yao only provides the differentiation of quantum circuits, but you can plug it into a general AD engine, such as Zygote, since we have ported these rules to ChainRules.","category":"section"},{"location":"man/automatic_differentiation.html#APIs","page":"Automatic Differentiation","title":"APIs","text":"","category":"section"},{"location":"man/automatic_differentiation.html#YaoBlocks.AD.apply_back-Tuple{Tuple{AbstractArrayReg, AbstractArrayReg}, AbstractBlock}","page":"Automatic Differentiation","title":"YaoBlocks.AD.apply_back","text":"apply_back(st::Tuple{<:AbstractArrayReg, <:AbstractArrayReg}, block::AbstractBlock; kwargs...) -> (out, outδ), paramsδ\n\nThe backward function of apply!. Returns a tuple of ((input register, gradient of input register), parameter gradients)\n\n\n\n\n\n","category":"method"},{"location":"man/automatic_differentiation.html#YaoBlocks.AD.generator-Tuple{RotationGate}","page":"Automatic Differentiation","title":"YaoBlocks.AD.generator","text":"generator(rot::Rotor) -> AbstractBlock\n\nReturn the generator of rotation block.\n\n\n\n\n\n","category":"method"},{"location":"man/automatic_differentiation.html#YaoBlocks.AD.mat_back-Union{Tuple{T}, Tuple{AbstractBlock, AbstractMatrix{T}}} where T","page":"Automatic Differentiation","title":"YaoBlocks.AD.mat_back","text":"mat_back([::Type{T}, ]block::AbstractBlock, adjm::AbstractMatrix) -> Vector\n\nThe backward function of mat. Returns the gradients of parameters.\n\n\n\n\n\n","category":"method"},{"location":"man/automatic_differentiation.html#YaoBlocks.AD.rotgrad-Union{Tuple{T}, Tuple{D}, Tuple{Type{T}, RotationGate{D, T, GT} where {T, GT<:AbstractBlock{D}}}} where {D, T}","page":"Automatic Differentiation","title":"YaoBlocks.AD.rotgrad","text":"The matrix gradient of a rotation block.\n\n\n\n\n\n","category":"method"},{"location":"man/paulipropagation.html#Pauli-Propagation-Backend","page":"Pauli Propagation Backend","title":"Pauli Propagation Backend","text":"Simulating noisy quantum circuits efficiently is a crucial challenge in quantum computing. The Pauli Propagation method[Rudolph2025] provides an efficient way to simulate circuits under certain noise models by tracking how Pauli observables evolve through the circuit. The PauliPropagation extension in Yao provides a convenient interface to convert Yao circuits into the Pauli propagation framework.","category":"section"},{"location":"man/paulipropagation.html#Overview","page":"Pauli Propagation Backend","title":"Overview","text":"Pauli propagation represents quantum circuit simulation as the evolution of Pauli strings through gates and noise channels. This approach offers several advantages:\n\nEfficiency: Scales polynomially for certain circuit classes, especially with sparse Pauli evolution\nNoise Support: Natural representation of common noise models (depolarizing, Pauli channels)\nObservable-Centric: Directly computes expectation values without full state vector\n\nThe method works by propagating a Pauli observable backwards through the circuit, keeping track of how the observable transforms under gates and noise.","category":"section"},{"location":"man/paulipropagation.html#Installation","page":"Pauli Propagation Backend","title":"Installation","text":"The PauliPropagation extension is automatically loaded when you have both packages:\n\nusing Yao\nusing PauliPropagation","category":"section"},{"location":"man/paulipropagation.html#Basic-Usage","page":"Pauli Propagation Backend","title":"Basic Usage","text":"","category":"section"},{"location":"man/paulipropagation.html#Converting-Circuits-to-PauliPropagation","page":"Pauli Propagation Backend","title":"Converting Circuits to PauliPropagation","text":"The primary function for circuit conversion is:\n\nyao2paulipropagation(circuit; observable)\n\nThis function transforms a Yao circuit into a PauliPropagationCircuit intermediate representation.\n\nParameters:\n\ncircuit::ChainBlock: The quantum circuit to convert. Must contain only gates supported by PauliPropagation (Clifford gates, rotations, and noise channels)\nobservable: A Yao block specifying the observable to measure. Must be a sum of Pauli strings\n\nReturns:\n\nPauliPropagationCircuit: An intermediate representation containing the circuit gates and observable as a PauliSum","category":"section"},{"location":"man/paulipropagation.html#Propagating-Observables","page":"Pauli Propagation Backend","title":"Propagating Observables","text":"Once you have a PauliPropagationCircuit, propagate the observable through the circuit:\n\npropagate(pc; kwargs...)\n\nReturns:\n\nPauliSum: The propagated observable. Use overlapwithzero(psum) to get the expectation value","category":"section"},{"location":"man/paulipropagation.html#Example","page":"Pauli Propagation Backend","title":"Example","text":"Here's a complete example showing how to simulate a noisy quantum circuit:\n\nusing Yao, PauliPropagation\n\n# Create a noisy circuit with rotation gates and depolarizing noise\nn = 5\ncircuit = chain(n,\n    put(n, 1=>H),\n    put(n, 2=>Rx(0.3)),\n    control(n, 1, 2=>X),\n    put(n, 1=>quantum_channel(DepolarizingError(1, 0.01)))\n)\n\n# Define an observable (e.g., measure Z on first qubit)\nobservable = put(n, 1=>Z)\n\n# Convert to PauliPropagation representation\npc = yao2paulipropagation(circuit; observable=observable)\n\n# Propagate the observable through the circuit\npsum = propagate(pc)\n\n# Get the expectation value\nexp_pauli = real(overlapwithzero(psum))\nprintln(\"PauliPropagation result: \", exp_pauli)\n\n# Compare with exact density matrix simulation\nreg = zero_state(n) |> density_matrix\nreg_final = apply!(reg, circuit)\nexp_exact = real(expect(observable, reg_final))\nprintln(\"Exact simulation result: \", exp_exact)\nprintln(\"Difference: \", abs(exp_pauli - exp_exact))\n\nThe observable can also be a sum of Pauli strings (e.g., a Hamiltonian):\n\n# Multi-term observable\nhamiltonian = put(n, 1=>X) + 2.0 * kron(n, 1=>Z, 2=>Z)\npc2 = yao2paulipropagation(circuit; observable=hamiltonian)\nexp_val = real(overlapwithzero(propagate(pc2)))\nprintln(\"Hamiltonian expectation: \", exp_val)","category":"section"},{"location":"man/paulipropagation.html#Supported-Gates-and-Channels","page":"Pauli Propagation Backend","title":"Supported Gates and Channels","text":"","category":"section"},{"location":"man/paulipropagation.html#Clifford-Gates","page":"Pauli Propagation Backend","title":"Clifford Gates","text":"Pauli gates: X, Y, Z\nHadamard: H\nPhase gates: S, T, Sdag, Tdag\nTwo-qubit gates: control(n, ctrl, target=>X) (CNOT), control(n, ctrl, target=>Z) (CZ), SWAP, Toffoli","category":"section"},{"location":"man/paulipropagation.html#Rotation-Gates","page":"Pauli Propagation Backend","title":"Rotation Gates","text":"Rx(θ), Ry(θ), Rz(θ) and their multi-qubit versions","category":"section"},{"location":"man/paulipropagation.html#Noise-Channels","page":"Pauli Propagation Backend","title":"Noise Channels","text":"DepolarizingChannel: Depolarizing noise\nMixedUnitaryChannel: Pauli noise channels (X, Y, Z errors)\nAmplitudeDampingError: Amplitude damping","category":"section"},{"location":"man/paulipropagation.html#API-Reference","page":"Pauli Propagation Backend","title":"API Reference","text":"","category":"section"},{"location":"man/paulipropagation.html#PauliPropagationCircuit","page":"Pauli Propagation Backend","title":"PauliPropagationCircuit","text":"An intermediate representation that holds a circuit and observable in PauliPropagation format.\n\nFields:\n\nn::Int: Number of qubits\ngates::Vector{StaticGate}: Vector of frozen gates\nobservable::PauliSum: Observable as a sum of Pauli strings","category":"section"},{"location":"man/paulipropagation.html#propagate(pc::PauliPropagationCircuit;-kwargs...)","page":"Pauli Propagation Backend","title":"propagate(pc::PauliPropagationCircuit; kwargs...)","text":"Propagate the observable through the circuit.\n\nKeyword Arguments:\n\nmax_weight: Maximum Pauli weight to keep (default: no limit)\nmin_abs_coeff: Minimum coefficient magnitude to keep (default: 0)\n\nReturns: PauliSum - the propagated observable","category":"section"},{"location":"man/paulipropagation.html#Performance-Tips","page":"Pauli Propagation Backend","title":"Performance Tips","text":"Truncation: Use max_weight and min_abs_coeff to control the size of the Pauli sum during propagation\nObservable Choice: Simpler observables (lower Pauli weight) propagate more efficiently\nCircuit Structure: Circuits with limited entanglement spread maintain sparse Pauli sums\nFrozen Rotations: All rotation parameters are frozen into the gates for efficient propagation","category":"section"},{"location":"man/paulipropagation.html#References","page":"Pauli Propagation Backend","title":"References","text":"[Rudolph2025]: Rudolph, Manuel S., Jones, Tyson, Teng, Yanting, Angrisani, Armando, and Holmes, Zoe. \"Pauli Propagation: A Computational Framework for Simulating Quantum Systems.\" arXiv:2505.21606 (2025). https://arxiv.org/abs/2505.21606","category":"section"},{"location":"man/paulipropagation.html#YaoBlocks.yao2paulipropagation","page":"Pauli Propagation Backend","title":"YaoBlocks.yao2paulipropagation","text":"yao2paulipropagation(circ::ChainBlock; observable)\n\nConvert a Yao circuit to a Pauli propagation circuit representation. You must using PauliPropagation before using this function.\n\nArguments\n\ncirc::ChainBlock: Yao circuit in the form of a chain of basic gates.\n\nKeyword Arguments\n\nobservable: A Yao block specifying the observable to measure (required). Must be a sum of Pauli strings, e.g. kron(5, 2=>X, 3=>X) + 2.0 * kron(5, 1=>Z). Will be converted to a PauliSum.\n\nReturns\n\nPauliPropagationCircuit: An intermediate representation that can be evaluated with propagate(pc).\n\n\n\n\n\n","category":"function"},{"location":"man/paulipropagation.html#YaoBlocks.paulipropagation2yao","page":"Pauli Propagation Backend","title":"YaoBlocks.paulipropagation2yao","text":"paulipropagation2yao(n::Int, circ::AbstractVector{Gate}, thetas::AbstractVector)\npaulipropagation2yao(pc::PauliCircuit)\n\nConvert a Pauli propagation circuit to a Yao circuit. You must using PauliPropagation before using this function.\n\nArguments\n\nn::Int: Number of qubits.\ncirc::AbstractVector{Gate}: Pauli propagation circuit.\nthetas::AbstractVector: Vector of parameters.\n\nOr:\n\npc::PauliCircuit: A PauliCircuit intermediate representation.\n\n\n\n\n\n","category":"function"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"(Image: )","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#qcbm","page":"Quantum Circuit Born Machine","title":"Quantum Circuit Born Machine","text":"Yao is designed with variational quantum circuits in mind, and this tutorial will introduce how to use Yao for this kind of task by implementing a quantum circuit born machine described in Jin-Guo Liu, Lei Wang (2018)\n\nlet's use the packages first\n\nusing Yao, LinearAlgebra, Plots","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#Training-Target","page":"Quantum Circuit Born Machine","title":"Training Target","text":"In this tutorial, we will ask the variational circuit to learn the most basic distribution: a guassian distribution. It is defined as follows:\n\nf(x left mu sigma^2right) = frac1sqrt2pisigma^2 e^-frac(x-mu)^22sigma^2\n\nWe implement it as gaussian_pdf:\n\nfunction gaussian_pdf(x, μ::Real, σ::Real)\n    pl = @. 1 / sqrt(2pi * σ^2) * exp(-(x - μ)^2 / (2 * σ^2))\n    pl / sum(pl)\nend\npg = gaussian_pdf(1:1<<6, 1<<5-0.5, 1<<4);\n\nWe can plot the distribution, it looks like\n\nPlots.plot(pg)\n\n<img src=\"data:image/png;base64,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\" />","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#Create-the-Circuit","page":"Quantum Circuit Born Machine","title":"Create the Circuit","text":"A quantum circuit born machine looks like the following:\n\n(Image: differentiable ciruit)\n\nIt is composited by two different layers: rotation layer and entangler layer.","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#Rotation-Layer","page":"Quantum Circuit Born Machine","title":"Rotation Layer","text":"Arbitrary rotation is built with Rotation Gate on Z, X, Z axis with parameters.\n\nRz(theta) cdot Rx(theta) cdot Rz(theta)\n\nSince our input will be a 0dots 0rangle state. The first layer of arbitrary rotation can just use Rx(theta) cdot Rz(theta) and the last layer of arbitrary rotation could just use Rz(theta)cdot Rx(theta)\n\nIn 幺, every Hilbert operator is a block type, this ncludes all quantum gates and quantum oracles. In general, operators appears in a quantum circuit can be divided into Composite Blocks and Primitive Blocks.\n\nWe follow the low abstraction principle and thus each block represents a certain approach of calculation. The simplest Composite Block is a Chain Block, which chains other blocks (oracles) with the same number of qubits together. It is just a simple mathematical composition of operators with same size. e.g.\n\ntextchain(X Y Z) iff X cdot Y cdot Z\n\nWe can construct an arbitrary rotation block by chain Rz, Rx, Rz together.\n\nchain(Rz(0.0), Rx(0.0), Rz(0.0))\n\nnqubits: 1\nchain\n├─ rot(Z, 0.0)\n├─ rot(X, 0.0)\n└─ rot(Z, 0.0)\n\nRx, Rz will construct new rotation gate, which are just shorthands for rot(X, 0.0), etc.\n\nThen let's chain them up\n\nlayer(nbit::Int, x::Symbol) = layer(nbit, Val(x))\nlayer(nbit::Int, ::Val{:first}) = chain(nbit, put(i=>chain(Rx(0), Rz(0))) for i = 1:nbit);\n\nWe do not need to feed the first n parameter into put here. All factory methods can be lazy evaluate the first arguements, which is the number of qubits. It will return a lambda function that requires a single interger input. The instance of desired block will only be constructed until all the information is filled. When you filled all the information in somewhere of the declaration, 幺 will be able to infer the others. We will now define the rest of rotation layers\n\nlayer(nbit::Int, ::Val{:last}) = chain(nbit, put(i=>chain(Rz(0), Rx(0))) for i = 1:nbit)\nlayer(nbit::Int, ::Val{:mid}) = chain(nbit, put(i=>chain(Rz(0), Rx(0), Rz(0))) for i = 1:nbit);","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#Entangler","page":"Quantum Circuit Born Machine","title":"Entangler","text":"Another component of quantum circuit born machine are several CNOT operators applied on different qubits.\n\nentangler(pairs) = chain(control(ctrl, target=>X) for (ctrl, target) in pairs);\n\nWe can then define such a born machine\n\nfunction build_circuit(n, nlayers, pairs)\n    circuit = chain(n)\n    push!(circuit, layer(n, :first))\n    for i in 2:nlayers\n        push!(circuit, cache(entangler(pairs)))\n        push!(circuit, layer(n, :mid))\n    end\n    push!(circuit, cache(entangler(pairs)))\n    push!(circuit, layer(n, :last))\n    return circuit\nend\n\nbuild_circuit (generic function with 1 method)\n\nWe use the method cache here to tag the entangler block that it should be cached after its first run, because it is actually a constant oracle. Let's see what will be constructed\n\nbuild_circuit(4, 1, [1=>2, 2=>3, 3=>4])\n\nnqubits: 4\nchain\n├─ chain\n│  ├─ put on (1)\n│  │  └─ chain\n│  │     ├─ rot(X, 0.0)\n│  │     └─ rot(Z, 0.0)\n│  ├─ put on (2)\n│  │  └─ chain\n│  │     ├─ rot(X, 0.0)\n│  │     └─ rot(Z, 0.0)\n│  ├─ put on (3)\n│  │  └─ chain\n│  │     ├─ rot(X, 0.0)\n│  │     └─ rot(Z, 0.0)\n│  └─ put on (4)\n│     └─ chain\n│        ├─ rot(X, 0.0)\n│        └─ rot(Z, 0.0)\n├─ [cached] chain\n│     ├─ control(1)\n│     │  └─ (2,) X\n│     ├─ control(2)\n│     │  └─ (3,) X\n│     └─ control(3)\n│        └─ (4,) X\n└─ chain\n   ├─ put on (1)\n   │  └─ chain\n   │     ├─ rot(Z, 0.0)\n   │     └─ rot(X, 0.0)\n   ├─ put on (2)\n   │  └─ chain\n   │     ├─ rot(Z, 0.0)\n   │     └─ rot(X, 0.0)\n   ├─ put on (3)\n   │  └─ chain\n   │     ├─ rot(Z, 0.0)\n   │     └─ rot(X, 0.0)\n   └─ put on (4)\n      └─ chain\n         ├─ rot(Z, 0.0)\n         └─ rot(X, 0.0)\n","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#MMD-Loss-and-Gradients","page":"Quantum Circuit Born Machine","title":"MMD Loss & Gradients","text":"The MMD loss is describe below:\n\nbeginaligned\nmathcalL = left sum_x p theta(x) phi(x) - sum_x pi(x) phi(x) right^2\n            = langle K(x y) rangle_x sim p_theta ysim p_theta - 2 langle K(x y) rangle_xsim p_theta ysim pi + langle K(x y) rangle_xsimpi ysimpi\nendaligned\n\nWe will use a squared exponential kernel here.\n\nstruct RBFKernel\n    σ::Float64\n    m::Matrix{Float64}\nend\n\nfunction RBFKernel(σ::Float64, space)\n    dx2 = (space .- space').^2\n    return RBFKernel(σ, exp.(-1/2σ * dx2))\nend\n\nkexpect(κ::RBFKernel, x, y) = x' * κ.m * y\n\nkexpect (generic function with 1 method)\n\nThere are two different way to define the loss:\n\nIn simulation we can use the probability distribution of the state directly\n\nget_prob(qcbm) = probs(zero_state(nqubits(qcbm)) |> qcbm)\n\nfunction loss(κ, c, target)\n    p = get_prob(c) - target\n    return kexpect(κ, p, p)\nend\n\nloss (generic function with 1 method)\n\nOr if you want to simulate the whole process with measurement (which is entirely physical), you should define the loss with measurement results, for convenience we directly use the simulated results as our loss","category":"section"},{"location":"generated/examples/6.quantum-circuit-born-machine/index.html#Gradients","page":"Quantum Circuit Born Machine","title":"Gradients","text":"the gradient of MMD loss is\n\nbeginaligned\nfracpartial mathcalLpartial theta^i_l = langle K(x y) rangle_xsim p_theta^+ ysim p_theta - langle K(x y) rangle_xsim p_theta^- ysim p_theta\n- langle K(x y) rangle _xsim p_theta^+ ysimpi + langle K(x y) rangle_xsim p_theta^- ysimpi\nendaligned\n\nwhich can be implemented as\n\nfunction gradient(qcbm, κ, ptrain)\n    n = nqubits(qcbm)\n    prob = get_prob(qcbm)\n    grad = zeros(Float64, nparameters(qcbm))\n\n    count = 1\n    for k in 1:2:length(qcbm), each_line in qcbm[k], gate in content(each_line)\n        dispatch!(+, gate, π/2)\n        prob_pos = probs(zero_state(n) |> qcbm)\n\n        dispatch!(-, gate, π)\n        prob_neg = probs(zero_state(n) |> qcbm)\n\n        dispatch!(+, gate, π/2) # set back\n\n        grad_pos = kexpect(κ, prob, prob_pos) - kexpect(κ, prob, prob_neg)\n        grad_neg = kexpect(κ, ptrain, prob_pos) - kexpect(κ, ptrain, prob_neg)\n        grad[count] = grad_pos - grad_neg\n        count += 1\n    end\n    return grad\nend\n\ngradient (generic function with 1 method)\n\nNow let's setup the training\n\nimport Optimisers\nqcbm = build_circuit(6, 10, [1=>2, 3=>4, 5=>6, 2=>3, 4=>5, 6=>1])\ndispatch!(qcbm, :random) # initialize the parameters\n\nκ = RBFKernel(0.25, 0:2^6-1)\npg = gaussian_pdf(1:1<<6, 1<<5-0.5, 1<<4);\nopt = Optimisers.setup(Optimisers.ADAM(0.01), parameters(qcbm));\n\nfunction train(qcbm, κ, opt, target)\n    history = Float64[]\n    for _ in 1:100\n        push!(history, loss(κ, qcbm, target))\n        ps = parameters(qcbm)\n        Optimisers.update!(opt, ps, gradient(qcbm, κ, target))\n        dispatch!(qcbm, ps)\n    end\n    return history\nend\n\nhistory = train(qcbm, κ, opt, pg)\ntrained_pg = probs(zero_state(nqubits(qcbm)) |> qcbm)\n\n64-element Vector{Float64}:\n 0.004584044716762385\n 0.004744372111957559\n 0.005575156322816176\n 0.0059582339080948\n 0.006451308254644259\n 0.007567108755469743\n 0.007980570284431367\n 0.00886771238710026\n 0.009806914557601286\n 0.010643007565623705\n 0.011545802421719075\n 0.012361425891229098\n 0.013386025046533362\n 0.014422309977304525\n 0.01530151205180086\n 0.01628916849614461\n 0.017518152671305444\n 0.01827363719490804\n 0.019316885913490768\n 0.02009539322949489\n 0.021004682966973477\n 0.021960428877127906\n 0.0226914314471751\n 0.023499949220153152\n 0.02402043944823069\n 0.02457705212704679\n 0.025065254705406607\n 0.02554277107822473\n 0.025698261886543117\n 0.025890346923068082\n 0.02611367417879893\n 0.026073187252494856\n 0.026138598531850424\n 0.025813940908458222\n 0.025643472091115622\n 0.025045790722010824\n 0.024643162769114314\n 0.024031156574723506\n 0.02353507237796853\n 0.02267868837215667\n 0.021865918310195503\n 0.021112553335717973\n 0.020185934801329374\n 0.019297141776817787\n 0.01841210833098677\n 0.017187234930330617\n 0.016425716926930584\n 0.015349718500477593\n 0.014343511601633207\n 0.013142045412986848\n 0.012498830714136221\n 0.011550594264871813\n 0.010416700711642211\n 0.009712287839736294\n 0.008793322239826587\n 0.008165058626221647\n 0.007290923099179455\n 0.006636589801479548\n 0.005890772777625654\n 0.005264816648292311\n 0.004853309027341903\n 0.004270994573958404\n 0.0037394962406342\n 0.003238315290574508\n\nThe history of training looks like below\n\ntitle!(\"training history\")\nxlabel!(\"steps\"); ylabel!(\"loss\")\nPlots.plot(history)\n\n<img src=\"data:image/png;base64,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\" />\n\nAnd let's check what we got\n\nfig2 = Plots.plot(1:1<<6, trained_pg; label=\"trained\")\nPlots.plot!(fig2, 1:1<<6, pg; label=\"target\")\ntitle!(\"distribution\")\nxlabel!(\"x\"); ylabel!(\"p\")\n\n<img src=\"data:image/png;base64,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\" />\n\nSo within 50 steps, we got a pretty close estimation of our target distribution!\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"quick-start.html#Quick-Start","page":"Quick Start","title":"Quick Start","text":"In this quick start, we list several common use cases for Yao before you go deeper into the manual.","category":"section"},{"location":"quick-start.html#Create-a-quantum-register/state","page":"Quick Start","title":"Create a quantum register/state","text":"A register is an object that describes a device with an internal state. See Registers for more details. Yao use registers to represent quantum states. The most common register is the ArrayReg, you can create it by feeding a state vector to it, e.g\n\nusing Yao\nArrayReg(randn(ComplexF64, 2^3))  # a random unnormalized 3-qubit state\nzero_state(5)  # |00000⟩\nrand_state(5)  # a random state\nproduct_state(bit\"10100\")  # |10100⟩\nghz_state(5)  # (|00000⟩ + |11111⟩)/√2\n\nthe internal quantum state can be accessed via statevec method\n\nstatevec(ghz_state(2))\n\nfor more functionalities about registers please refer to the manual of Registers.","category":"section"},{"location":"quick-start.html#Create-quantum-circuit","page":"Quick Start","title":"Create quantum circuit","text":"Yao introduces an abstract representation for linear maps, called \"block\"s, which can be used to represent quantum circuits, Hamiltonians, and other quantum operations. The following code creates a 2-qubit circuit\n\nchain(2, put(1=>H), put(2=>X))\n\nwhere H gate is at 1st qubit, X gate is at 2nd qubit. A more advanced example is the quantum Fourier transform circuit\n\nA(i, j) = control(i, j=>shift(2π/(1<<(i-j+1))))  # a cphase gate\nB(n, k) = chain(n, j==k ? put(k=>H) : A(j, k) for j in k:n)\nqft(n) = chain(B(n, k) for k in 1:n)\ncircuit = qft(3)  # a 3-qubit QFT circuit\nmat(circuit)  # the matrix representation of the circuit\napply!(zero_state(3), circuit)  # apply the circuit to a zero state\n\nMore details about available blocks can be found in the manual of Blocks.","category":"section"},{"location":"quick-start.html#Create-Hamiltonian","page":"Quick Start","title":"Create Hamiltonian","text":"We can create a simple Ising Hamiltonian on 1D chain as following\n\nh = sum([kron(5, i=>Z, mod1(i+1, 5)=>Z) for i in 1:5])  # a 5-qubit Ising Hamiltonian\nmat(h)  # the matrix representation of the Hamiltonian","category":"section"},{"location":"quick-start.html#Differentiating-a-quantum-circuit","page":"Quick Start","title":"Differentiating a quantum circuit","text":"Yao has its own automatic differentiation rule implemented, this allows one obtain gradients of a loss function by simply putting a ' mark following expect or fidelity, e.g\n\nTo obtain the gradient of the quantum Fourier transform circuit with respect to its parameters, one can use the following code\n\ngrad_state, grad_circuit_params = expect'(kron(X, X, I2) + kron(I2, X, X), zero_state(3)=>qft(3))\n\nwhere kron(X, X, I2) + kron(I2, X, X) is the target Hamiltonian, zero_state(3) is the initial state, qft(3) is the quantum Fourier transform circuit. The return value is a vector, each corresponding to the gradient of the loss function with respect to a parameter in the circuit. The list of parameters can be obtained by parameters function.\n\nparameters(qft(3))\n\nTo obtain the gradient of the fidelity between a state parameterized by a quantum circuit and a target state, one can use the following code\n\n((grad_state1, grad_circuit1), grad_state2) = fidelity'(zero_state(3)=>qft(3), ghz_state(3))\n\nwhere zero_state(3) is the initial state, qft(3) is the quantum Fourier transform circuit, ghz_state(3) is the target state.\n\nThe automatic differentiation functionality can also be accessed by interfacing with the machine learning libraries Zygote.","category":"section"},{"location":"quick-start.html#Plot-quantum-circuits","page":"Quick Start","title":"Plot quantum circuits","text":"The component package YaoPlots provides plotting for quantum circuits and ZX diagrams. You can use it to visualize your quantum circuits in VSCode, Jupyter notebook or Pluto notebook.\n\nusing Yao.EasyBuild, Yao.YaoPlots\nusing Compose\n\n# show a qft circuit\nvizcircuit(qft_circuit(5))\n\nMore details about the plotting can be found in the manual: Quantum Circuit Visualization.","category":"section"},{"location":"notes.html#How-to-overload-exist-method-for-a-block","page":"How to overload exist method for a block","title":"How to overload exist method for a block","text":"every block has two method: mat & apply!, overload mat to define how to gather this block's matrix form, overload apply! to define how to apply this block to a register.\n\nPrototypes:\n\napply!(reg, block)\nmat(block)","category":"section"},{"location":"performancetips.html#Performance-Tips","page":"Performance Tips","title":"Performance Tips","text":"","category":"section"},{"location":"performancetips.html#Use-the-correct-block-types","page":"Performance Tips","title":"Use the correct block types","text":"","category":"section"},{"location":"performancetips.html#put-v.s.-subroutine","page":"Performance Tips","title":"put v.s. subroutine","text":"While both blocks maps a subblock to a subset of qudits, their implementations are purposes are quite different. The put block applies the gate in a in-place manner, which requires the static matrix representation of its subblock. It works the best when the subblock is small.\n\nThe subroutine block is for running a sub-program in a subset of qubits. It first sets target qubits as active qubits using the focus! function, then apply the gates on active qubits. Finally, it unsets the active qubits with the relax! function.\n\njulia> using Yao\n\njulia> reg = rand_state(20);\n\njulia> @time apply(reg, put(20, 1:6=>EasyBuild.qft_circuit(6)));  # second run\n  0.070245 seconds (1.32 k allocations: 16.525 MiB)\n\njulia> @time apply(reg, subroutine(20, EasyBuild.qft_circuit(6), 1:6));  # second run\n  0.036840 seconds (1.07 k allocations: 16.072 MiB)","category":"section"},{"location":"performancetips.html#repeat-v.s.-put","page":"Performance Tips","title":"repeat v.s. put","text":"repeat block is not only an alias of a chain of put, sometimes it can provide speed ups due to the different implementations.\n\njulia> reg = rand_state(20);\n\njulia> @time apply!(reg, repeat(20, X));\n  0.002252 seconds (5 allocations: 656 bytes)\n\njulia> @time apply!(reg, chain([put(20, i=>X) for i=1:20]));\n  0.049362 seconds (82.48 k allocations: 4.694 MiB, 47.11% compilation time)\n\nOther gates accelerated by repeat include: X, Y, Z, S, T, Sdag, and Tdag.","category":"section"},{"location":"performancetips.html#Diagonal-matrix-in-time_evole","page":"Performance Tips","title":"Diagonal matrix in time_evole","text":"","category":"section"},{"location":"performancetips.html#Register-storage","page":"Performance Tips","title":"Register storage","text":"One can use transposed storage and normal storage for computing batched registers. The transposed storage is used by default because it is often faster in practice. One can use transpose_storage to convert the storage.","category":"section"},{"location":"performancetips.html#Multithreading","page":"Performance Tips","title":"Multithreading","text":"Multithreading can be switched on by starting Julia in with a global environment variable JULIA_NUM_THREAD\n\n$ JULIA_NUM_THREAD=4 julia xxx.jl\n\nCheck the Julia Multi-Treading manual for details.","category":"section"},{"location":"performancetips.html#GPU-backend","page":"Performance Tips","title":"GPU backend","text":"The GPU backend is supported in CuYao.\n\njulia> using Yao, CuYao\n\njulia> reg = CuYao.cu(rand_state(20));\n\njulia> circ = Yao.EasyBuild.qft_circuit(20);\n\njulia> apply!(reg, circ)\nArrayReg{2, ComplexF64, CuArray...}\n    active qubits: 20/20\n    nlevel: 2","category":"section"},{"location":"man/registers.html#registers","page":"Quantum Registers","title":"Quantum Registers","text":"","category":"section"},{"location":"man/registers.html#Constructing-quantum-states","page":"Quantum Registers","title":"Constructing quantum states","text":"A quantum register is a quantum state or a batch of quantum states. Qubits in a Yao register can be active or inactive. Only active qubits are visible to quantum operators, which enables applying quantum operators on a subset of qubits. For example, Suppose we want to run a quantum Fourier transformation circuit of size 4 on qubits (1, 3, 5, 7) with the focus! function, we first set these qubits to active qubits the rest to inactive, then we apply the circuit on the active qubits, and finally we switch back to the original configuration with the relax! function.\n\nYao provides two types of quantum registers ArrayReg and BatchedArrayReg. Both use matrices as the storage.  For example, for a quantum register with a active qubits, r remaining qubits and batch size b, the storage is as follows.\n\n(Image: )\n\nThe first dimension of size 2^a is for active qubits, only this subset of qubits are allowed to interact with quantum operators. Since we reshaped the state vector into a matrix, applying a quantum operator can be conceptually represented as a matrix-matrix multiplication.\n\nVarious quantum states can be created with the following functions.\n\nusing Yao\nreg = ArrayReg([0, 1, -1+0.0im, 0])  # a unnormalized Bell state |01⟩ - |10⟩\nstatevec(reg)  # a quantum state is represented as a vector\nprint_table(reg)\n\nreg_zero = zero_state(3)  # create a zero state |000⟩\nprint_table(reg_zero)\n\nreg_rand = rand_state(ComplexF32, 3)  # a random state\n\nreg_uniform = uniform_state(ComplexF32, 3)  # a uniform state\nprint_table(reg_uniform)\n\nreg_prod = product_state(bit\"110\")  # a product state\nbit\"110\"[3]  # the bit string is in little-endian format\nprint_table(reg_prod)\n\nreg_ghz = ghz_state(3)  # a GHZ state\nprint_table(reg_ghz)\nvon_neumann_entropy(reg_ghz, (1, 3)) / log(2) # entanglement entropy between qubits (1, 3) and (2,)\n\nreg_rand3 = rand_state(3, nlevel=3)  # a random qutrit state\nreg_prod3 = product_state(dit\"120;3\")  # a qudit product state, what follows \";\" symbol denotes the number of levels\nprint_table(reg_prod3)\n\nreg_batch = rand_state(3; nbatch=2)  # a batch of 2 random qubit states\nprint_table(reg_batch)\nreg_view = viewbatch(reg_batch, 1)  # view the first state in the batch\nprint_table(reg_view)\n\nreg = rand_state(3; nlevel=4, nbatch=2)\nnqudits(reg)  # the total number of qudits\nnactive(reg)  # the number of active qubits\nnremain(reg)  # the number of remaining qubits\nnbatch(reg)  # the batch size\nnlevel(reg)  # the number of levels of each qudit\nbasis(reg)  # the basis of the register\nfocus!(reg, 1:2)  # set on the first two qubits as active\nnactive(reg)  # the number of active qubits\nbasis(reg)  # the basis of the register\nrelax!(reg)  # set all qubits as active\nnactive(reg)  # the number of active qubits\nreorder!(reg, (3,1,2))  # reorder the qubits\n\nreg1 = product_state(bit\"111\");\nreg2 = ghz_state(3);\nfidelity(reg1, reg2)  # the fidelity between two states\ntracedist(reg1, reg2)  # the trace distance between two states","category":"section"},{"location":"man/registers.html#Arithmetic-operations","page":"Quantum Registers","title":"Arithmetic operations","text":"The list of arithmetic operations for ArrayReg include \n\n+\n-\n*\n/ (scalar)\nadjoint\n\nreg1 = rand_state(3)\nreg2 = rand_state(3)\nreg3 = reg1 + reg2  # addition\nnormalize!(reg3)  # normalize the state\nisnormalized(reg3)  # check if the state is normalized\nreg1 - reg2  # subtraction\nreg1 * 2  # scalar multiplication\nreg1 / 2  # scalar division\nreg1'  # adjoint\nreg1' * reg1  # inner product","category":"section"},{"location":"man/registers.html#Register-operations","page":"Quantum Registers","title":"Register operations","text":"reg0 = rand_state(3)\nappend_qudits!(reg0, 2)  # append 2 qubits\ninsert_qudits!(reg0, 2, 2)  # insert 2 qubits at the 2nd position\n\nComparing with using matrix multiplication for quantum simulation, using specialized instructions are much faster and memory efficient. These instructions are specified with the instruct! function.\n\nreg = zero_state(2)\ninstruct!(reg, Val(:H), (1,))  # apply a Hadamard gate on the first qubit\nprint_table(reg)","category":"section"},{"location":"man/registers.html#Measurement","page":"Quantum Registers","title":"Measurement","text":"We use the measure! function returns the measurement outcome and collapses the state after the measurement. We also have some \"cheating\" version measure that does not collapse states to facilitate classical simulation.\n\nmeasure!(reg0, 1)  # measure the qubit, the state collapses\nmeasure!(reg0)  # measure all qubits\nmeasure(reg0, 3)  # measure the qubit at location 3, the state does not collapse (hacky)\nreorder!(reg0, 7:-1:1)  # reorder the qubits\nmeasure!(reg0)\ninvorder!(reg0)  # reverse the order of qubits\nmeasure!(reg0)\nmeasure!(RemoveMeasured(), reg0, 2:4)  # remove the measured qubits\nreg0\n\nreg1 = ghz_state(3)\nselect!(reg1, bit\"111\")  # post-select the |111⟩ state\nisnormalized(reg1)  # check if the state is normalized","category":"section"},{"location":"man/registers.html#Density-matrices","page":"Quantum Registers","title":"Density matrices","text":"reg = rand_state(3)\nrho = density_matrix(reg)  # the density matrix of the state\nrand_density_matrix(3)  # a random density matrix\ncompletely_mixed_state(3)  # a completely mixed state\npartial_tr(rho, 1)  # partial trace on the first qubit\npurify(rho)  # purify the state\nvon_neumann_entropy(rho)  # von Neumann entropy\nmutual_information(rho, 1, 2)  # mutual information between qubits 1 and 2","category":"section"},{"location":"man/registers.html#API","page":"Quantum Registers","title":"API","text":"The constructors and functions for quantum registers are listed below.\n\nThe following functions are for querying the properties of a quantum register.\n\nThe following functions are for querying the state of a quantum register.\n\nThe following functions are for arithmetic operations on quantum registers.\n\nWe also have some faster inplace versions of arithematic operations\n\nWe also define the following functions for state normalization, and distance measurement.\n\nThe following functions are for adding and reordering qubits in a quantum register.\n\nThe instruct! function is for applying quantum operators on a quantum register.\n\nThe following functions are for measurement and post-selection.\n\nThe following functions are for density matrices.","category":"section"},{"location":"man/registers.html#YaoAPI.AbstractRegister","page":"Quantum Registers","title":"YaoAPI.AbstractRegister","text":"AbstractRegister{D}\n\nAbstract type for quantum registers. Type parameter D is the number of levels in each qudit. For qubits, D = 2.\n\nRequired methods\n\ninstruct!\nnqudits\nnactive\ninsert_qubits!\nappend_qubits!\nfocus!\nrelax!\nreorder!\ninvorder!\n\nOptional methods\n\nnlevel\nnremain\n\n\n\n\n\n","category":"type"},{"location":"man/registers.html#YaoArrayRegister.AbstractArrayReg","page":"Quantum Registers","title":"YaoArrayRegister.AbstractArrayReg","text":"AbstractArrayReg\n\nAbstract type for quantum registers that are represented by an array.\n\n\n\n\n\n","category":"type"},{"location":"man/registers.html#YaoArrayRegister.ArrayReg","page":"Quantum Registers","title":"YaoArrayRegister.ArrayReg","text":"ArrayReg{D,T,MT<:AbstractMatrix{T}} <: AbstractArrayRegister{D}\nArrayReg{D}(raw)\nArrayReg(raw::AbstractVecOrMat; nlevel=2)\nArrayReg(r::ArrayReg)\n\nSimulated full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. T is the numerical type for each amplitude, it is ComplexF64 by default.\n\nwarning: Warning\nArrayReg constructor will not normalize the quantum state. If you need a normalized quantum state remember to use normalize!(register) on the register.\n\n\n\n\n\n","category":"type"},{"location":"man/registers.html#YaoArrayRegister.BatchedArrayReg","page":"Quantum Registers","title":"YaoArrayRegister.BatchedArrayReg","text":"BatchedArrayReg{D,T,MT<:AbstractMatrix{T}} <: AbstractArrayReg{D}\nBatchedArrayReg(raw, nbatch; nlevel=2)\nBatchedArrayReg{D}(raw, nbatch)\n\nSimulated batched full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. T is the numerical type for each amplitude, it is ComplexF64 by default.\n\nwarning: Warning\nBatchedArrayReg constructor will not normalize the quantum state. If you need a normalized quantum state remember to use normalize!(register) on the register.\n\n\n\n\n\n","category":"type"},{"location":"man/registers.html#YaoArrayRegister.arrayreg","page":"Quantum Registers","title":"YaoArrayRegister.arrayreg","text":"arrayreg(state; nbatch::Union{Integer,NoBatch}=NoBatch(), nlevel::Integer=2)\n\nCreate an array register, if nbatch is a integer, it will return a BatchedArrayReg.\n\n\n\n\n\narrayreg([T=ComplexF64], bit_str; nbatch=NoBatch())\n\nConstruct an array register from bit string literal. For bit string literal please read @bit_str.\n\nExamples\n\njulia> arrayreg(bit\"1010\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> arrayreg(ComplexF32, bit\"1010\")\nArrayReg{2, ComplexF32, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.product_state","page":"Quantum Registers","title":"YaoArrayRegister.product_state","text":"product_state([T=ComplexF64], dit_str; nbatch=NoBatch(), no_transpose_storage=false)\nproduct_state([T=ComplexF64], nbits::Int, val::Int; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)\nproduct_state([T=ComplexF64], vector; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)\n\nCreate an ArrayReg of product state. The configuration can be specified with a dit string, which can be defined with @bit_str or @dit_str. Or equivalently, it can be specified explicitly with nbits, val and nlevel. See also zero_state, rand_state, uniform_state.\n\nExamples\n\njulia> reg = product_state(dit\"120;3\"; nbatch=2)\nBatchedArrayReg{3, ComplexF64, Transpose...}\n    active qudits: 3/3\n    nlevel: 3\n    nbatch: 2\n\njulia> measure(reg)\n1×2 Matrix{BitBasis.DitStr64{3, 3}}:\n 120 ₍₃₎  120 ₍₃₎\n\njulia> product_state(bit\"100\"; nbatch=2);\n\njulia> r1 = product_state(ComplexF32, bit\"001\"; nbatch=2);\n\njulia> r2 = product_state(ComplexF32, [1, 0, 0]; nbatch=2);\n\njulia> r3 = product_state(ComplexF32, 3, 0b001; nbatch=2);\n\njulia> r1 ≈ r2   # because we read bit strings from right to left, vectors from left to right.\ntrue\n\njulia> r1 ≈ r3\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.zero_state","page":"Quantum Registers","title":"YaoArrayRegister.zero_state","text":"zero_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())\n\nCreate an AbstractArrayReg that initialized to state 0rangle^otimes n. See also product_state, rand_state, uniform_state and ghz_state.\n\nExamples\n\njulia> zero_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> zero_state(ComplexF32, 4)\nArrayReg{2, ComplexF32, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> zero_state(ComplexF32, 4; nbatch=3)\nBatchedArrayReg{2, ComplexF32, Transpose...}\n    active qubits: 4/4\n    nlevel: 2\n    nbatch: 3\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.zero_state_like","page":"Quantum Registers","title":"YaoArrayRegister.zero_state_like","text":"zero_state_like(register, n) -> AbstractRegister\n\nCreate a register initialized to zero from an existing one.\n\nExamples\n\njulia> reg = rand_state(3; nbatch=2);\n\njulia> zero_state_like(reg, 2)\nBatchedArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/2\n    nlevel: 2\n    nbatch: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.rand_state","page":"Quantum Registers","title":"YaoArrayRegister.rand_state","text":"rand_state([T=ComplexF64], n::Int; nbatch=NoBatch(), no_transpose_storage=false)\n\nCreate a random AbstractArrayReg with total number of qudits n.\n\nExamples\n\njulia> rand_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> rand_state(ComplexF64, 4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\njulia> rand_state(ComplexF64, 4; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qubits: 4/4\n    nlevel: 2\n    nbatch: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.uniform_state","page":"Quantum Registers","title":"YaoArrayRegister.uniform_state","text":"uniform_state([T=ComplexF64], n; nbatch=NoBatch(), no_transpose_storage=false)\n\nCreate a uniform state:\n\nfrac1sqrt2^n sum_k=0^2^n-1 krangle\n\nThis state can also be created by applying H (Hadmard gate) on 0000 state.\n\nExample\n\njulia> uniform_state(4; nbatch=2)\nBatchedArrayReg{2, ComplexF64, Transpose...}\n    active qubits: 4/4\n    nlevel: 2\n    nbatch: 2\n\njulia> uniform_state(ComplexF32, 4; nbatch=2)\nBatchedArrayReg{2, ComplexF32, Transpose...}\n    active qubits: 4/4\n    nlevel: 2\n    nbatch: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.ghz_state","page":"Quantum Registers","title":"YaoArrayRegister.ghz_state","text":"ghz_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())\n\nCreate a GHZ state (or a cat state) that defined as\n\nfrac0rangle^otimes n + 1rangle^otimes nsqrt2\n\nExamples\n\njulia> ghz_state(4)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 4/4\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.clone","page":"Quantum Registers","title":"YaoAPI.clone","text":"clone(register, n)\n\nCreate an ArrayReg by cloning the original register for n times on batch dimension. This function is only for emulation.\n\nExample\n\njulia> clone(arrayreg(bit\"101\"; nbatch=3), 4)\nBatchedArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n    nbatch: 12\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.nqudits","page":"Quantum Registers","title":"YaoAPI.nqudits","text":"nqudits(register) -> Int\n\nReturns the total number of qudits in register.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.nqubits","page":"Quantum Registers","title":"YaoAPI.nqubits","text":"nqubits(register) -> Int\n\nReturns the (total) number of qubits. See nactive, nremain for more details.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.nactive","page":"Quantum Registers","title":"YaoAPI.nactive","text":"nactive(register) -> Int\n\nReturns the number of active qudits in register. Here, active qudits means the system qubits that operators can be applied on.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.nremain","page":"Quantum Registers","title":"YaoAPI.nremain","text":"nremain(register) -> Int\n\nReturns the number of inactive qudits in register. It equals to subtracting nqudits and nactive.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.nbatch","page":"Quantum Registers","title":"YaoArrayRegister.nbatch","text":"nbatch(register) -> Union{Int,NoBatch()}\n\nReturns the number of batches.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.nlevel","page":"Quantum Registers","title":"YaoAPI.nlevel","text":"nlevel(x)\n\nNumber of levels in each qudit.\n\nExamples\n\njulia> nlevel(X)\n2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.focus!","page":"Quantum Registers","title":"YaoAPI.focus!","text":"focus!(register, locs) -> register\nfocus!(locs...) -> f(register) -> register\n\nSet the active qubits to focused locations, usually used to execute a subroutine. If register is not provided, returns a lambda that takes a register as input.\n\nExamples\n\njulia> reg = product_state(bit\"01101\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\njulia> focus!(reg, (1,3,4))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/5\n    nlevel: 2\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 111 ₍₂₎\n 111 ₍₂₎\n 111 ₍₂₎\n\njulia> measure(apply(reg, put(3, 2=>X)); nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 101 ₍₂₎\n 101 ₍₂₎\n 101 ₍₂₎\n\nHere, we prepare a product state and only look at the qubits 1, 3 and 4. The measurement results are all ones. With the focued register, we can apply a block of size 3 on it, even though the number of qubits is 5.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.focus","page":"Quantum Registers","title":"YaoAPI.focus","text":"focus(f, register, locs)\n\nCall a callable f under the context of focus. See also focus!.\n\nExamples\n\nTo print the focused register\n\njulia> r = arrayreg(bit\"101100\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 6/6\n    nlevel: 2\n\njulia> focus(x->(println(x);x), r, (1, 2));\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/6\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.relax!","page":"Quantum Registers","title":"YaoAPI.relax!","text":"relax!(register[, locs]; to_nactive=nqudits(register)) -> register\nrelax!(locs::Int...; to_nactive=nqudits(register)) -> f(register) -> register\n\nInverse transformation of focus!, where to_nactive is the number  of active bits for target register. If the register is not provided, returns a lambda function that takes a register as input.\n\nExamples\n\njulia> reg = product_state(bit\"01101\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\njulia> focus!(reg, (1,3,4))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/5\n    nlevel: 2\n\njulia> relax!(reg, (1,3,4))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.exchange_sysenv","page":"Quantum Registers","title":"YaoArrayRegister.exchange_sysenv","text":"exchange_sysenv(reg::AbstractArrayReg) -> AbstractRegister\n\nExchange system (focused qubits) and environment (remaining qubits).\n\njulia> reg = rand_state(5)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\njulia> focus!(reg, (2,4))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/5\n    nlevel: 2\n\njulia> exchange_sysenv(reg)\nArrayReg{2, ComplexF64, Adjoint...}\n    active qubits: 3/5\n    nlevel: 2\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.state","page":"Quantum Registers","title":"YaoArrayRegister.state","text":"state(register::AbstractArrayReg) -> Matrix\n\nReturns the raw array storage of register. See also statevec.\n\n\n\n\n\nstate(ρ::DensityMatrix) -> Matrix\n\nReturn the raw state of density matrix ρ.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#BitBasis.basis","page":"Quantum Registers","title":"BitBasis.basis","text":"basis(ditstr) -> UnitRange{DitStr{D,N,T}}\nbasis(DitStr{D,N,T}) -> UnitRange{DitStr{D,N,T}}\n\nReturns the UnitRange for basis in Hilbert Space of qudits.\n\n\n\n\n\nbasis(register) -> UnitRange\n\nReturns an UnitRange of the all the bits in the Hilbert space of given register.\n\njulia> collect(basis(rand_state(3)))\n8-element Vector{DitStr{2, 3, Int64}}:\n 000 ₍₂₎\n 001 ₍₂₎\n 010 ₍₂₎\n 011 ₍₂₎\n 100 ₍₂₎\n 101 ₍₂₎\n 110 ₍₂₎\n 111 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.statevec","page":"Quantum Registers","title":"YaoArrayRegister.statevec","text":"statevec(r::ArrayReg) -> array\n\nReturn a state matrix/vector by droping the last dimension of size 1 (i.e. nactive(r) = nqudits(r)). See also state.\n\nwarning: Warning\nstatevec is not type stable. It may cause performance slow down.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.relaxedvec","page":"Quantum Registers","title":"YaoArrayRegister.relaxedvec","text":"relaxedvec(r::AbstractArrayReg) -> AbstractArray\n\nReturn a vector representation of state, with all qudits activated. See also state, statevec.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#BitBasis.hypercubic","page":"Quantum Registers","title":"BitBasis.hypercubic","text":"hypercubic(A::Array) -> Array\n\nget the hypercubic representation for an array.\n\n\n\n\n\nhypercubic(r::ArrayReg) -> AbstractArray\n\nReturn the hypercubic representation (high dimensional tensor) of this register, only active qudits are considered. See also rank3 and state.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.rank3","page":"Quantum Registers","title":"YaoArrayRegister.rank3","text":"rank3(r::ArrayReg)\n\nReturn the rank 3 tensor representation of state, the 3 dimensions are (activated space, remaining space, batch dimension). See also hypercubic and state.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.viewbatch","page":"Quantum Registers","title":"YaoAPI.viewbatch","text":"viewbatch(register, i::Int) -> AbstractRegister\n\nReturns the i-th single register of a batched register. The returned instance is a view of the original register, i.e. inplace operation changes the original register directly.\n\nExamples\n\njulia> reg = zero_state(5; nbatch=2);\n\njulia> apply!(viewbatch(reg, 2), put(5, 2=>X));\n\njulia> measure(reg; nshots=3)\n3×2 Matrix{DitStr{2, 5, Int64}}:\n 00000 ₍₂₎  00010 ₍₂₎\n 00000 ₍₂₎  00010 ₍₂₎\n 00000 ₍₂₎  00010 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.transpose_storage","page":"Quantum Registers","title":"YaoArrayRegister.transpose_storage","text":"transpose_storage(register) -> register\n\nTranspose the register storage. Sometimes transposed storage provides better performance for batched simulation.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.AdjointArrayReg","page":"Quantum Registers","title":"YaoArrayRegister.AdjointArrayReg","text":"AdjointArrayReg{D,T,MT} = AdjointRegister{D,<:AbstractArrayReg{D,T,MT}}\n\nAdjoint array register type, it is used to represent the bra in the Dirac notation.\n\n\n\n\n\n","category":"type"},{"location":"man/registers.html#YaoArrayRegister.regadd!","page":"Quantum Registers","title":"YaoArrayRegister.regadd!","text":"regadd!(target, source)\n\nInplace version of + that accumulates source to target.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.regsub!","page":"Quantum Registers","title":"YaoArrayRegister.regsub!","text":"regsub!(target, source)\n\nInplace version of - that subtract source from target.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.regscale!","page":"Quantum Registers","title":"YaoArrayRegister.regscale!","text":"regscale!(target, x)\n\nInplace version of multiplying a scalar x to target.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#LinearAlgebra.normalize!","page":"Quantum Registers","title":"LinearAlgebra.normalize!","text":"normalize!(r::AbstractArrayReg)\n\nNormalize the register r by its 2-norm. It changes the register directly.\n\nExamples\n\nThe following code creates a normalized GHZ state.\n\njulia> reg = product_state(bit\"000\") + product_state(bit\"111\");\n\njulia> norm(reg)\n1.4142135623730951\n\njulia> isnormalized(reg)\nfalse\n\njulia> normalize!(reg);\n\njulia> isnormalized(reg)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.isnormalized","page":"Quantum Registers","title":"YaoArrayRegister.isnormalized","text":"isnormalized(r::ArrayReg) -> Bool\n\nReturns true if the register r is normalized.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.fidelity","page":"Quantum Registers","title":"YaoAPI.fidelity","text":"fidelity(register1, register2) -> Real/Vector{<:Real}\nfidelity'(pair_or_reg1, pair_or_reg2) -> (g1, g2)\n\nReturn the fidelity between two states. Calcuate the fidelity between r1 and r2, if r1 or r2 is not pure state (nactive(r) != nqudits(r)), the fidelity is calcuated by purification. See also: http://iopscience.iop.org/article/10.1088/1367-2630/aa6a4b/meta\n\nObtain the gradient with respect to registers and circuit parameters. For pair input ψ=>circuit, the returned gradient is a pair of gψ=>gparams, with gψ the gradient of input state and gparams the gradients of circuit parameters. For register input, the return value is a register.\n\nDefinition\n\nThe fidelity of two quantum state for qudits is defined as:\n\nF(ρ σ) = tr(sqrtsqrtρσsqrtρ)\n\nnote: Note\nThis definition is different from the one in Wiki by a square.\n\nExamples\n\njulia> reg1 = uniform_state(3);\n\njulia> reg2 = zero_state(3);\n\njulia> fidelity(reg1, reg2)\n0.35355339059327373\n\nReferences\n\nJozsa R. Fidelity for mixed quantum states[J]. Journal of modern optics, 1994, 41(12): 2315-2323.\nNielsen M A, Chuang I. Quantum computation and quantum information[J]. 2002.\n\nnote: Note\nThe original definition of fidelity F was from \"transition probability\", defined by Jozsa in 1994, it is the square of what we use here.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.tracedist","page":"Quantum Registers","title":"YaoAPI.tracedist","text":"tracedist(register1, register2)\n\nReturn the trace distance of register1 and register2.\n\nDefinition\n\nTrace distance is defined as following:\n\nfrac12  A - B _rm tr\n\nIt takes values between 0 and 1.\n\nExamples\n\njulia> reg1 = uniform_state(3);\n\njulia> reg2 = zero_state(3);\n\njulia> tracedist(reg1, reg2)\n0.9354143466934852\n\nReferences\n\nhttps://en.wikipedia.org/wiki/Trace_distance\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.insert_qudits!","page":"Quantum Registers","title":"YaoAPI.insert_qudits!","text":"insert_qudits!(register, loc::Int, nqudits::Int) -> register\ninsert_qudits!(loc::Int, nqudits::Int) -> λ(register)\n\nInsert qudits to given register in state |0>. i.e. |psi> -> join(|psi>, |0...>, |psi>), increased bits have higher indices.\n\nExamples\n\njulia> reg = product_state(bit\"01101\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\njulia> insert_qudits!(reg, 2, 2)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 7/7\n    nlevel: 2\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 7, Int64}}:\n 0110001 ₍₂₎\n 0110001 ₍₂₎\n 0110001 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.insert_qubits!","page":"Quantum Registers","title":"YaoAPI.insert_qubits!","text":"insert_qubits!(register, loc::Int, nqubits::Int=1) -> register\ninsert_qubits!(loc::Int, nqubits::Int=1) -> λ(register)\n\nInsert n qubits to given register in state |0>. It is an alias of insert_qudits! function.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.append_qudits!","page":"Quantum Registers","title":"YaoAPI.append_qudits!","text":"append_qudits!(register, n::Int) -> register\nappend_qudits!(n::Int) -> λ(register)\n\nAdd n qudits to given register in state |0>. i.e. |psi> -> |000> ⊗ |psi>, increased bits have higher indices.\n\nIf only an integer is provided, then returns a lambda function.\n\nExamples\n\njulia> reg = product_state(bit\"01101\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\njulia> append_qudits!(reg, 2)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 7/7\n    nlevel: 2\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 7, Int64}}:\n 0001101 ₍₂₎\n 0001101 ₍₂₎\n 0001101 ₍₂₎\n\nNote here, we read the bit string from right to left.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.append_qubits!","page":"Quantum Registers","title":"YaoAPI.append_qubits!","text":"append_qubits!(register, n::Int) -> register\nappend_qubits!(n::Int) -> λ(register)\n\nAdd n qudits to given register in state |0>. It is an alias of append_qudits! function.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.reorder!","page":"Quantum Registers","title":"YaoAPI.reorder!","text":"reorder!(reigster, orders)\n\nReorder the locations of register by input orders. For a 3-qubit register, an order (i, j, k) specifies the following reordering of qubits\n\nmove the first qubit go to i,\nmove the second qubit go to j,\nmove the third qubit go to k.\n\nnote: Note\nThe convention of reorder! is different from the permutedims function, one can use the sortperm function to relate the permutation order and the order in this function.\n\nExamples\n\njulia> reg = product_state(bit\"010101\");\n\njulia> reorder!(reg, (1,4,2,5,3,6));\n\njulia> measure(reg)\n1-element Vector{DitStr{2, 6, Int64}}:\n 000111 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.invorder!","page":"Quantum Registers","title":"YaoAPI.invorder!","text":"invorder!(register)\n\nInverse the locations of the register.\n\nExamples\n\njulia> reg = product_state(bit\"010101\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 6/6\n    nlevel: 2\n\njulia> measure(invorder!(reg); nshots=3)\n3-element Vector{DitStr{2, 6, Int64}}:\n 101010 ₍₂₎\n 101010 ₍₂₎\n 101010 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.instruct!","page":"Quantum Registers","title":"YaoAPI.instruct!","text":"instruct!([nlevel=Val(2), ]state, operator, locs[, control_locs, control_configs, theta])\n\nUnified interface for applying an operator to a quantum state. It modifies the state directly.\n\nArguments\n\nnlevel is the number of levels in each qudit,\nstate is a vector or matrix representing the quantum state, where the first dimension is the active qubit dimension, the second is the batch dimension.\noperator is a quantum operator, which can be Val(GATE_SYMBOL) or a matrix.\nlocs::Tuple is a tuple for specifying the locations this gate applied.\ncontrol_locs::Tuple and control_configs are tuples for specifying the control locations and control values.\ntheta::Real is the parameter for the gate, e.g. Val(:Rx) gate takes a real number of its parameter.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.measure!","page":"Quantum Registers","title":"YaoAPI.measure!","text":"measure!([postprocess,] [operator, ]register[, locs]; rng=Random.GLOBAL_RNG)\n\nMeasure current active qudits or qudits at locs. If the operator is not provided, it will measure on the computational basis and collapse to a product state. Otherwise, the quantum state collapse to the subspace corresponds to the resulting eigenvalue of the observable.\n\nArguments\n\npostprocess is the postprocessing method, it can be\nNoPostProcess() (default).\nResetTo(config), reset to result state to config. It can not be used if operator is provided, because measuring an operator in general does not return a product state.\nRemoveMeasured(), remove the measured qudits from the register. It is also incompatible with the operator argument.\noperator::AbstractBlock is the operator to measure.\nregister::AbstractRegister is the quantum state.\nlocs is the qubits to performance the measurement. If locs is not provided, all current active qudits are measured (regarding to active qudits,\n\nsee focus! and relax!).\n\nKeyword arguments\n\nrng is the random number generator.\n\nExamples\n\nThe following example measures a random state on the computational basis and reset it to a certain bitstring value.\n\njulia> reg = rand_state(3);\n\njulia> measure!(ResetTo(bit\"011\"), reg)\n110 ₍₂₎\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 011 ₍₂₎\n 011 ₍₂₎\n 011 ₍₂₎\n\njulia> measure!(RemoveMeasured(), reg, (1,2))\n11 ₍₂₎\n\njulia> reg  # removed qubits are not usable anymore\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 1/1\n    nlevel: 2\n\nMeasuring an operator will project the state to the subspace associated with the returned eigenvalue.\n\njulia> reg = uniform_state(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> print_table(reg)\n000 ₍₂₎   0.35355 + 0.0im\n001 ₍₂₎   0.35355 + 0.0im\n010 ₍₂₎   0.35355 + 0.0im\n011 ₍₂₎   0.35355 + 0.0im\n100 ₍₂₎   0.35355 + 0.0im\n101 ₍₂₎   0.35355 + 0.0im\n110 ₍₂₎   0.35355 + 0.0im\n111 ₍₂₎   0.35355 + 0.0im\n\njulia> measure!(repeat(3, Z, 1:3), reg)\n-1.0 + 0.0im\n\njulia> print_table(reg)\n000 ₍₂₎   0.0 + 0.0im\n001 ₍₂₎   0.5 + 0.0im\n010 ₍₂₎   0.5 + 0.0im\n011 ₍₂₎   0.0 + 0.0im\n100 ₍₂₎   0.5 + 0.0im\n101 ₍₂₎   0.0 + 0.0im\n110 ₍₂₎   0.0 + 0.0im\n111 ₍₂₎   0.5 + 0.0im\n\nHere, we measured the parity operator, as a result,  the resulting state collapsed to the subspace with either even or odd parity.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.measure","page":"Quantum Registers","title":"YaoAPI.measure","text":"measure([, operator], register[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -> Vector{Int}\n\nMeasure a quantum state and return measurement results of qudits. This measurement function a cheating version of measure! that does not collapse the input state. It also does not need to recompute the quantum state for performing multiple shots measurement.\n\nArguments\n\noperator::AbstractBlock is the operator to measure.\nregister::AbstractRegister is the quantum state.\nlocs is the qubits to performance the measurement. If locs is not provided, all current active qudits are measured (regarding to active qudits,\n\nsee focus! and relax!).\n\nKeyword arguments\n\nnshots::Int is the number of shots.\nrng is the random number generator.\n\nExamples\n\njulia> reg = product_state(bit\"110\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> measure(reg; nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 110 ₍₂₎\n 110 ₍₂₎\n 110 ₍₂₎\n\njulia> measure(reg, (2,3); nshots=3)\n3-element Vector{DitStr{2, 2, Int64}}:\n 11 ₍₂₎\n 11 ₍₂₎\n 11 ₍₂₎\n\nThe following example switches to the X basis for measurement.\n\njulia> reg = apply!(product_state(bit\"100\"), repeat(3, H, 1:3))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> measure(repeat(3, X, 1:3), reg; nshots=3)\n3-element Vector{ComplexF64}:\n -1.0 + 0.0im\n -1.0 + 0.0im\n -1.0 + 0.0im\n\njulia> reg = apply!(product_state(bit\"101\"), repeat(3, H, 1:3))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> measure(repeat(3, X, 1:3), reg; nshots=3)\n3-element Vector{ComplexF64}:\n 1.0 - 0.0im\n 1.0 - 0.0im\n 1.0 - 0.0im\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.select!","page":"Quantum Registers","title":"YaoAPI.select!","text":"select!(dest::AbstractRegister, src::AbstractRegister, bits::Integer...) -> AbstractRegister\nselect!(register::AbstractRegister, bits::Integer...) -> register\nselect!(b::Integer) -> f(register)\n\nselect a subspace of given quantum state based on input eigen state bits. See also select for the non-inplace version. If the register is not provided, it returns a lambda expression that takes a register as the input.\n\nExamples\n\njulia> reg = ghz_state(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> select!(reg, bit\"111\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 0/0\n    nlevel: 2\n\njulia> norm(reg)\n0.7071067811865476\n\nThe selection only works on the activated qubits, for example\n\njulia> reg = focus!(ghz_state(3), (1, 2))\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 2/3\n    nlevel: 2\n\njulia> select!(reg, bit\"11\")\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 0/1\n    nlevel: 2\n\njulia> statevec(reg)\n1×2 Matrix{ComplexF64}:\n 0.0+0.0im  0.707107+0.0im\n\ntip: Tip\nDevelopers should overload select!(r::RegisterType, bits::NTuple{N, <:Integer}) and do not assume bits has specific number of bits (e.g Int64), or it will restrict the its maximum available number of qudits.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.select","page":"Quantum Registers","title":"YaoAPI.select","text":"select(register, bits) -> AbstractRegister\n\nThe non-inplace version of select!.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.collapseto!","page":"Quantum Registers","title":"YaoAPI.collapseto!","text":"collapseto!(register, config)\n\nSet the register to bit string literal bit_str (or an equivalent integer). About bit string literal, see more in @bit_str. This interface is only for emulation.\n\nExamples\n\nThe following code collapse a random state to a certain state.\n\njulia> measure(collapseto!(rand_state(3), bit\"001\"); nshots=3)\n3-element Vector{DitStr{2, 3, Int64}}:\n 001 ₍₂₎\n 001 ₍₂₎\n 001 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.probs","page":"Quantum Registers","title":"YaoAPI.probs","text":"probs(register) -> Vector\n\nReturns the probability distribution of computation basis, aka xψ^2.\n\nExamples\n\njulia> reg = product_state(bit\"101\");\n\njulia> reg |> probs\n8-element Vector{Float64}:\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 1.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.most_probable","page":"Quantum Registers","title":"YaoArrayRegister.most_probable","text":"most_probable(reg::ArrayReg{D, T} where T, n::Int64) -> Any\n\n\nFind n most probable qubit configurations in a quantum register and return these configurations as a vector of DitStr instances.\n\nExample\n\njulia> most_probable(ghz_state(3), 2)\n2-element Vector{DitStr{2, 3, Int64}}:\n 000 ₍₂₎\n 111 ₍₂₎\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.DensityMatrix","page":"Quantum Registers","title":"YaoAPI.DensityMatrix","text":"DensityMatrix{D,T,MT<:AbstractMatrix{T}} <: AbstractRegister{D}\nDensityMatrix{D}(state::AbstractMatrix)\nDensityMatrix(state::AbstractMatrix; nlevel=2)\n\nDensity matrix type, where state is a matrix. Type parameter D is the number of levels, it can also be specified by a keyword argument nlevel.\n\n\n\n\n\n","category":"type"},{"location":"man/registers.html#YaoAPI.density_matrix","page":"Quantum Registers","title":"YaoAPI.density_matrix","text":"density_matrix(register_or_rho[, locations])\n\nReturns the reduced density matrix for qubits at locations (default: all qubits).\n\nExamples\n\nThe following code gets the single site reduce density matrix for the GHZ state.\n\njulia> reg = ghz_state(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> density_matrix(reg, (2,)).state\n2×2 Matrix{ComplexF64}:\n 0.5+0.0im  0.0+0.0im\n 0.0-0.0im  0.5+0.0im\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.rand_density_matrix","page":"Quantum Registers","title":"YaoArrayRegister.rand_density_matrix","text":"rand_density_matrix([T=ComplexF64], n::Int; nlevel::Int=2, pure::Bool=false)\n\nGenerate a random density matrix by partial tracing half of the pure state.\n\nnote: Note\nThe generated density matrix is not strict hermitian due to rounding error. If you need to check hermicity, do not use ishermitian consider using isapprox(dm.state, dm.state') or explicit mark it as Hermitian.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.completely_mixed_state","page":"Quantum Registers","title":"YaoArrayRegister.completely_mixed_state","text":"completely_mixed_state([T=ComplexF64], n::Int; nlevel::Int=2)\n\nGenerate the completely mixed state with density matrix I(n) ./ nlevel^n.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.partial_tr","page":"Quantum Registers","title":"YaoAPI.partial_tr","text":"partial_tr(ρ, locs) -> DensityMatrix\n\nReturn a density matrix which is the partial traced on locs.\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoAPI.purify","page":"Quantum Registers","title":"YaoAPI.purify","text":"purify(r::DensityMatrix; nbit_env::Int=nactive(r)) -> ArrayReg\n\nGet a purification of target density matrix.\n\nExamples\n\nThe following example shows how to measure a local operator on the register, reduced density matrix and the purified register. Their results should be consistent.\n\njulia> reg = ghz_state(3)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/3\n    nlevel: 2\n\njulia> r = density_matrix(reg, (2,));\n\njulia> preg = purify(r)\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 1/2\n    nlevel: 2\n\njulia> isapprox(expect(Z + Y, preg), 0.0; atol=1e-10)\ntrue\n\njulia> isapprox(expect(Z + Y, r), 0.0; atol=1e-10)\ntrue\n\njulia> isapprox(expect(put(3, 2=>(Z + Y)), reg), 0.0; atol=1e-10)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.von_neumann_entropy","page":"Quantum Registers","title":"YaoArrayRegister.von_neumann_entropy","text":"von_neumann_entropy(reg::AbstractArrayReg, part)\nvon_neumann_entropy(ρ::DensityMatrix)\n\nThe entanglement entropy between part and the rest part in quantum state reg. If the input is a density matrix, it returns the entropy of a mixed state.\n\nExample\n\nThe Von Neumann entropy of any segment of GHZ state is log 2.\n\njulia> von_neumann_entropy(ghz_state(3), (1,2))\n0.6931471805599612\n\n\n\n\n\nvon_neumann_entropy(rho) -> Real\n\nReturn the von-Neumann entropy for the input density matrix:\n\n-rm Tr(rholnrho)\n\n\n\n\n\n","category":"function"},{"location":"man/registers.html#YaoArrayRegister.mutual_information","page":"Quantum Registers","title":"YaoArrayRegister.mutual_information","text":"mutual_information(register_or_rho, part1, part2)\n\nReturns the mutual information between subsystems part1 and part2 of the input quantum register or density matrix:\n\nS(rho_A) + S(rho_B) - S(rho_AB)\n\nExample\n\nThe mutual information of a GHZ state of any two disjoint parts is always equal to log 2.\n\njulia> mutual_information(ghz_state(4), (1,), (3,4))\n0.6931471805599132\n\n\n\n\n\n","category":"function"},{"location":"generated/examples/2.qft-phase-estimation/index.html","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"(Image: )","category":"section"},{"location":"generated/examples/2.qft-phase-estimation/index.html#example-qft","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation and Phase Estimation","text":"Let's use Yao first\n\nusing Yao","category":"section"},{"location":"generated/examples/2.qft-phase-estimation/index.html#Quantum-Fourier-Transformation","page":"Quantum Fourier Transformation and Phase Estimation","title":"Quantum Fourier Transformation","text":"The Quantum Fourier Transformation (QFT) circuit is to repeat two kinds of blocks repeatly:\n\n(Image: qft-circuit)\n\nThe basic building block control phase shift gate is defined as\n\nR(k)=beginbmatrix\n1  0\n0  expleft(frac2pi i2^kright)\nendbmatrix\n\nLet's define block A and block B, block A is actually a control block.\n\nA(i, j) = control(i, j=>shift(2π/(1<<(i-j+1))))\n\nA (generic function with 1 method)\n\nOnce you construct the blockl you can inspect its matrix using mat function. Let's construct the circuit in dash box A, and see the matrix of R_4 gate.\n\nR4 = A(4, 1)\n\n(n -> control(n, 4, 1 => shift(0.39269908169872414)))\n\nIf you have read about preparing GHZ state, you probably know that in Yao, we could just leave the number of qubits, and it will be evaluated when possible.\n\nR4(5)\n\nnqubits: 5\ncontrol(4)\n└─ (1,) shift(0.39269908169872414)\n\nits matrix will be\n\nmat(R4(5))\n\n32×32 Diagonal{ComplexF64, Vector{ComplexF64}}:\n 1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im          ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      0.92388+0.382683im      ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅           1.0+0.0im          ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅      0.92388+0.382683im      ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅           1.0+0.0im          ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅      0.92388+0.382683im      ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅           1.0+0.0im          ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅      0.92388+0.382683im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅           1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im      ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      1.0+0.0im          ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅      0.92388+0.382683im      ⋅              ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅           1.0+0.0im          ⋅               ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅      0.92388+0.382683im      ⋅              ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅           1.0+0.0im          ⋅               ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅      0.92388+0.382683im      ⋅              ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅           1.0+0.0im          ⋅    \n     ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅          ⋅              ⋅               ⋅              ⋅               ⋅              ⋅               ⋅      0.92388+0.382683im\n\nThen we repeat this control block over and over on different qubits, and put a Hadamard gate to ith qubit to construct i-th B block.\n\nB(n, k) = chain(n, j==k ? put(k=>H) : A(j, k) for j in k:n)\n\nB (generic function with 1 method)\n\nWe need to input the total number of qubits n here because we have to iterate through from k-th location to the last.\n\nNow, let's construct the circuit by chaining all the B blocks together\n\nqft(n) = chain(B(n, k) for k in 1:n)\nqft(4)\n\nnqubits: 4\nchain\n├─ chain\n│  ├─ put on (1)\n│  │  └─ H\n│  ├─ control(2)\n│  │  └─ (1,) shift(1.5707963267948966)\n│  ├─ control(3)\n│  │  └─ (1,) shift(0.7853981633974483)\n│  └─ control(4)\n│     └─ (1,) shift(0.39269908169872414)\n├─ chain\n│  ├─ put on (2)\n│  │  └─ H\n│  ├─ control(3)\n│  │  └─ (2,) shift(1.5707963267948966)\n│  └─ control(4)\n│     └─ (2,) shift(0.7853981633974483)\n├─ chain\n│  ├─ put on (3)\n│  │  └─ H\n│  └─ control(4)\n│     └─ (3,) shift(1.5707963267948966)\n└─ chain\n   └─ put on (4)\n      └─ H\n","category":"section"},{"location":"generated/examples/2.qft-phase-estimation/index.html#Wrap-QFT-to-an-external-block","page":"Quantum Fourier Transformation and Phase Estimation","title":"Wrap QFT to an external block","text":"In most cases, functions are enough to wrap quantum circuits, like A and B we defined above, but sometimes, we need to dispatch specialized methods on certain kinds of quantum circuit, or we want to define an external block to export, thus, it's useful to be able to wrap circuit to custom blocks.\n\nFirst, we define a new type as subtype of PrimitiveBlock since we are not going to use the subblocks of QFT, if you need to use its subblocks, it'd be better to define it under CompositeBlock.\n\nstruct QFT <: PrimitiveBlock{2}\n    n::Int\nend\n\nYaoBlocks.nqudits(q::QFT) = q.n\n\nNow, let's define its circuit\n\ncircuit(q::QFT) = qft(q.n)\n\ncircuit (generic function with 1 method)\n\nAnd forward mat to its circuit's matrix\n\nYaoBlocks.mat(::Type{T}, x::QFT) where T = mat(T, circuit(x))\n\nYou may notice, it is a little ugly to print QFT at the moment, this is because we print the type summary by default, you can define your own printing by overloading print_block\n\nYaoBlocks.print_block(io::IO, x::QFT) = print(io, \"QFT($(x.n))\")\n\nSince it is possible to use FFT to simulate the results of QFT (like cheating), we could define our custom apply! method:\n\nusing FFTW, LinearAlgebra\n\nfunction YaoBlocks.apply!(r::ArrayReg, x::QFT)\n    α = sqrt(length(statevec(r)))\n    invorder!(r)\n    lmul!(α, ifft!(statevec(r)))\n    return r\nend\n\nNow let's check if our apply! method is correct:\n\nr = rand_state(5)\nr1 = r |> copy |> QFT(5)\nr2 = r |> copy |> circuit(QFT(5))\nr1 ≈ r2\n\ntrue\n\nWe can get iQFT (inverse QFT) directly by calling adjoint\n\nQFT(5)'\n\n [†]QFT(5)\n\nQFT and iQFT are different from FFT and IFFT in three ways,\n\nthey are different by a factor of sqrt2^n with n the number of qubits.\nthe bit numbering will exchange after applying QFT or iQFT.\ndue to the convention, QFT is more related to IFFT rather than FFT.","category":"section"},{"location":"generated/examples/2.qft-phase-estimation/index.html#Phase-Estimation","page":"Quantum Fourier Transformation and Phase Estimation","title":"Phase Estimation","text":"Since we have QFT and iQFT blocks we can then use them to realize phase estimation circuit, what we want to realize is the following circuit:\n\n(Image: phase estimation)\n\nFirst we call Hadamard gates repeatly on first n qubits.\n\nHadamards(n) = repeat(H, 1:n)\n\nHadamards (generic function with 1 method)\n\nThen in dashed box B, we have controlled unitaries:\n\nControlU(n, m, U) = chain(n+m, control(k, n+1:n+m=>matblock(U^(2^(k-1)))) for k in 1:n)\n\nControlU (generic function with 1 method)\n\neach of them is a U of power 2^(k-1).\n\nSince we will only apply the qft and Hadamard on first n qubits, we could use Subroutine, which creates a context of a sub-scope of the qubits.\n\nPE(n, m, U) =\n    chain(n+m, # total number of the qubits\n        subroutine(Hadamards(n), 1:n), # apply H in local scope\n        ControlU(n, m, U),\n        subroutine(QFT(n)', 1:n))\n\nPE (generic function with 1 method)\n\nwe use the first n qubits as the output space to store phase ϕ, and the other m qubits as the input state which corresponds to an eigenvector of oracle matrix U.\n\nThe subroutine here uses focus! and relax! to manage a local scope of quantum circuit, and only activate the first n qubits while applying the block inside the subroutine context, and the scope will be relax!ed back, after the context. This is equivalent to manually focus! then relax!\n\nfullly activated\n\nr = rand_state(5)\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\nfirst 3 qubits activated\n\nfocus!(r, 1:3)\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 3/5\n    nlevel: 2\n\nrelax back to the original\n\nrelax!(r, 1:3)\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 5/5\n    nlevel: 2\n\nIn this way, we will be able to apply small operator directly on the subset of the qubits.\n\nDetails about the algorithm can be found here: Quantum Phase Estimation Algorithm\n\nNow let's check the results of our phase estimation.\n\nFirst we need to set up a unitary with known phase, we set the phase to be 0.75, which is 0.75 * 2^3 == 6 == 0b110 .\n\nN, M = 3, 5\nP = eigen(rand_unitary(1<<M)).vectors\nθ = Int(0b110) / 1<<N\nphases = rand(1<<M)\nphases[0b010+1] = θ\nU = P * Diagonal(exp.(2π * im * phases)) * P'\n\n32×32 Matrix{ComplexF64}:\n  -0.144962+0.0444319im    -0.0305481+0.0281083im    -0.181845-0.0089989im      0.11524-0.131727im     -0.120354+0.0244182im    -0.065087+0.260427im     -0.054275-0.0782636im      0.127904-0.048851im     -0.150032+0.0375001im   -0.0455951-0.00877855im     0.299176-0.16356im       -0.146485+0.0182846im    0.0282236+0.180326im      -0.253254+0.0124136im   -0.0035428-0.0861414im      -0.232074+0.100926im        0.168527-0.122614im       0.0768066+0.250107im      0.0749144-0.386448im     -0.0836012+0.0966332im     0.0836941+0.0495439im    0.0533422+0.111939im      0.206414-0.00317963im     -0.11916-0.0131149im     -0.0279084+0.0687168im     0.0765351-0.0431481im    0.0726389-0.1037im      -0.0129742-0.160422im    -0.00114029-0.0500038im    -0.00808284-0.00674633im    -0.169385-0.0180742im      0.0633277-0.0869393im\n   0.133163+0.0220742im    -0.0979171-0.147188im    -0.0700065+0.0224978im    -0.165661-0.0203366im    -0.081892+0.0811331im    0.0456342+0.118372im    -0.0872115-0.0519006im     -0.130179-0.0474956im    -0.234396-0.224599im     0.0299626-0.0726292im     -0.144621+0.0271228im     0.0847335-0.0204393im   -0.0268257-0.0465785im     0.0374664-0.0171545im      0.06021+0.111575im       -0.118223-0.199372im        0.186821+0.113405im       0.0669929+0.0128303im      0.232095+0.188956im     -0.0424383+0.189339im     -0.0758577+0.0305417im    -0.232136+0.01017im      0.0775851-0.240683im      -0.205725+0.244493im       0.0348313+0.188323im      -0.170525-0.132079im    -0.0282036-0.185927im    -0.0766267+0.020833im       0.115392-0.00534082im    -0.0164506+0.0316054im     -0.161602+0.236963im       -0.109453+0.055574im\n -0.0191742+0.256607im       0.186469-0.0478407im     -0.13293-0.185803im     -0.209029-0.120796im      0.029789+0.046279im     0.0951418-0.0099707im    0.0379654+0.0804341im    -0.0596533-0.158558im     -0.136186-0.00651426im    0.186928-0.134963im      -0.130499-0.0644753im     -0.289971-0.110381im      0.052473-0.22698im       0.0112787-0.268749im     0.0170011-0.042196im        -0.15195+0.0895725im      0.0514005-0.00597756im      0.237308+0.00638322im  -0.00273495+0.0424451im    -0.0452162-0.0594804im     0.0042728+0.184623im    -0.0216135+0.0219578im   -0.0206957+0.157206im       0.177432-0.195563im       0.0416771-0.089343im      -0.212443+0.0106521im   -0.0567145+0.239362im       0.16152-0.0447064im       0.15089+0.0305477im     -0.0879083-0.0431648im    -0.0682987+0.000336937im    -0.031192-0.0980261im\n  -0.174899+0.247752im       0.343642+0.223735im     0.0663951-0.0282292im    -0.167468+0.0650005im   -0.0859271+0.00683717im  -0.0721654+0.042021im    -0.0541232-0.080967im    -0.00651566+0.162296im     0.0308385+0.0378694im    0.0069604+0.101879im     -0.0400413+0.140823im      -0.103732-0.0248044im     0.227274+0.0097907im      -0.10781+0.0762753im    -0.318335-0.107517im       -0.054242+0.0134563im        0.06062+0.0570585im       -0.20545-0.0974948im      0.139191+0.0378122im    -0.0586516-0.148173im     -0.0344458+0.0304947im    0.0698548-0.0812727im   -0.0249284-0.160611im     -0.0665933-0.144637im      -0.0900088+0.164116im      -0.195869+0.125592im    0.00145662-0.113536im     -0.124857+0.110738im     -0.0885217-0.182195im        0.061713+0.0838961im     0.0141759+0.180118im        0.178444+0.0692978im\n  0.0532492-0.0734167im      0.225962+0.0303237im     0.154671+0.0277925im     0.131677-0.231136im      0.075593-0.184703im    -0.0629584+0.00142982im   -0.094651-0.0461451im      0.139972+0.028647im    -0.0590234+0.0341617im    -0.178535-0.168144im      0.0804225+0.0403884im      -0.17846+0.0806522im     0.160631-0.0972973im     0.0174071+0.049636im      0.159046-0.0698426im     -0.0717418+0.223522im      -0.0388336+0.0186135im       0.243483+0.0155269im      0.108338+0.233698im      -0.186775+0.212831im      -0.126111+0.101744im    -0.0991723-0.0369498im     0.093221-0.0408876im     0.0482236+0.0700577im      -0.197029-0.181963im       0.154909+0.0527611im    0.0025622-0.0826686im   -0.0166588+0.110709im     -0.0601873+0.0554435im       0.121127+0.127202im       0.211032+0.0539211im     -0.0897779+0.245705im\n -0.0183485+0.0583393im      0.162482+0.121348im     -0.139585-0.0389478im   0.00440194+0.0491971im    0.0673973+0.218069im     0.0389844-0.0317497im     0.220113-0.0110953im     0.0456121-0.291107im     -0.191082+0.0340836im    -0.265548-0.134477im      -0.114453-0.0756965im     0.0824926-0.110316im     0.0301121+0.171369im     0.00480005+0.254565im   -0.00718701+0.105123im      -0.0468725-0.201606im      -0.0720956-0.100695im     -0.00775338-0.149487im       0.117865+0.0681945im     -0.053475+0.0586291im      0.158441-0.0861231im   -0.0978277-0.0207557im   -0.0440861+0.0828634im      0.132197+0.0254725im     -0.0956271-0.111314im      0.0983903-0.0243368im     0.166386-0.0797104im     0.318021+0.181048im      -0.137594-0.171649im        0.142327-0.0682559im    -0.0939744-0.0133249im      0.0618322-0.102977im\n -0.0373138+0.135432im     -0.0236522-0.092819im      0.211223-0.0183512im   -0.0406801+0.137916im    -0.0708201+0.0355738im     0.169665+0.0341795im    -0.170002-0.182559im      0.0265003+0.0538511im    -0.021068-0.0638457im    -0.216313+0.0515089im    0.00591169+0.138921im    -0.00660451+0.218439im    -0.0475454+0.162378im      0.0381099-0.183946im    -0.0414071-0.0136407im    -0.00675189+0.0488213im       0.264488-0.114091im        0.205069-0.119054im      -0.141442+0.0725613im     -0.164219-0.190663im       -0.11148-0.173615im      0.020809-0.0363732im   -0.0980103+0.322383im       0.107169+0.189576im      -0.0495889+0.0795722im    -0.0581349-0.0596513im   -0.0991429-0.119685im      0.104258-0.121572im     -0.0134166-0.0470667im       0.203789+0.154052im      -0.140255-0.160752im     -0.00888574-0.0473091im\n  0.0997905+0.0134394im     0.0560958+0.0867464im     0.265385-0.0770898im     0.199641-0.0847807im    0.0127532-0.175556im     0.0488374-0.0448597im     0.143996-0.0381767im     -0.159117-0.169542im      0.113177+0.0201771im    -0.157144+0.0600701im     -0.114162-0.280823im     -0.0675548+0.0768501im    -0.203422+0.0246449im     -0.116973-0.0364907im   -0.0132943+0.154955im     -0.00809672+0.144571im      0.00118718+0.243718im       0.0289381+0.0295462im     0.0723993-0.0988553im    -0.0775198-0.191618im      -0.125381+0.0808228im   -0.0590726+0.105867im    -0.0278801-0.0449485im      0.115397+0.0905971im       0.252243+0.17471im      -0.0494927+0.250579im      0.207363-0.0734654im  -0.00229273+0.0639161im     0.0476596+0.052052im       0.0586455-0.188003im      -0.185585+0.104805im       0.0780424+0.10401im\n 0.00999499-0.205879im      0.0113092-0.190199im    -0.0542257+0.146502im      0.228166-0.00658083im  0.00151593+0.0223065im    0.0701129-0.227377im     -0.197683-0.18958im      -0.0327195+0.0545749im    -0.106924-0.159226im     -0.202671-0.226259im       0.103211-0.166555im      -0.108369-0.0105829im    0.0884096-0.0792602im     0.0622075-0.0222039im    -0.318785+0.00437655im          0.09-0.107863im        0.131503+0.0666991im      -0.065818+0.0132968im    -0.0805076-0.0373684im       0.16725-0.0872436im      0.146355+0.190802im      -0.16002-0.128654im      0.015279-0.0370911im      0.223117-0.190591im       0.0847719-0.189761im      -0.130595-0.0983258im   -0.0707913-0.122309im     -0.147314-0.0402027im    -0.0436784-0.0312496im      0.0184225-0.0488555im    -0.0535632+0.0272326im      0.0958044-0.0189757im\n -0.0995909-0.00304294im    0.0042298+0.0536957im   0.00114848-0.28723im        0.12428+0.0969048im     0.105442-0.166102im     0.0359962+0.0659361im    0.0545097-0.0422605im    -0.0705907-0.0217686im     0.138459+0.00377969im   -0.271297-0.0921404im    -0.0660695+0.123422im     -0.0995928-0.0402422im    -0.133005-0.00673912im     0.105571+0.0877355im    -0.320887+0.13999im        0.0244829-0.206494im        0.101972-0.243345im        0.130941+0.169682im     -0.0468939+0.076521im      0.0761676+0.186348im     -0.0917871-0.0734828im     0.245947+0.00977924im    0.211855-0.165656im      0.0139144+0.0642412im      -0.016566+0.0504969im    -0.0421381-0.00170378im  -0.0262159+0.200759im     0.0690825-0.118796im       0.220722+0.0817853im     -0.0202828-0.00813652im     0.172643+0.131212im       0.0808026-0.0369621im\n  0.0239659-0.121278im      0.0961215+0.118669im    -0.0844436-0.165366im       0.07414+0.0562539im     0.182223+0.110996im      0.118244-0.0912424im    -0.216711+0.160667im      -0.236554-0.073629im      0.161983-0.185351im    0.00211274+0.0386531im       0.03959-0.0235096im     0.0869267+0.00681195im  0.00616853-0.148342im      -0.232741-0.0145586im    0.0130431-0.139596im       -0.175161+0.0971955im      0.0674919-0.16221im         0.041928+0.0663036im    -0.0439204+0.127416im      0.0725077-0.1659im       0.00408703-0.152233im     -0.144551+0.0290638im   -0.0218535-0.253033im      -0.190553-0.111896im        0.144218-0.0307814im      0.117055-0.0589615im   -0.0259168-0.109845im      0.291488-0.0523491im     -0.060406-0.00956217im    -0.0411264+0.133952im     -0.0314978-0.19546im         0.120147+0.213632im\n   0.114075-0.114586im       0.115821-0.0432057im    0.0690224+0.109596im      0.088434-0.13641im       0.114805+0.128515im     -0.192957+0.120543im    -0.0611501-0.0398287im     -0.148552-0.0267929im     0.124971+0.145433im      0.261532-0.0573253im      0.182965-0.176535im      0.0864262-0.135909im    -0.0399477-0.0797538im     0.0745644-0.225859im    -0.0282421+0.112277im      0.00179088-0.134056im        0.138528-0.0390097im       0.124078-0.379256im       0.135989-0.0658451im    -0.0627198-0.154188im      0.0369477-0.106536im       0.27841-0.0874135im     0.110613-0.140553im     -0.0176053+0.122051im       -0.104484-0.156393im      0.0618737+0.0817297im   -0.0433156-0.0898779im    0.0603745+0.0116428im      0.131405-0.0166816im       0.143084+0.049367im     0.00917318+0.0809401im       0.102349-0.13465im\n   0.104493-0.289734im      0.0878114+0.090968im      0.191958-0.0554819im   0.00741581+0.142816im     -0.246181-0.229425im    -0.0640638-0.0797722im    -0.143201-0.00428898im     0.182084-0.26069im      -0.106948-0.00424826im    0.166451-0.00503966im   -0.0294804+0.0378661im     0.0150043-0.00424517im   -0.128339-0.192465im     -0.0205357+0.246082im    0.00255848-0.0202419im      -0.249406-0.0104876im     0.00727477-0.0629008im     -0.0360726-0.0937939im     -0.139647+0.0800292im     0.0384094-0.11856im      0.00301353+0.197854im      0.157866+0.129767im    -0.0707366-0.0118596im    0.00212471-0.0710478im     -0.0613688+0.116147im     -0.0307195-0.11855im       0.101606-0.12214im       0.075542-0.166592im    -0.00976677-0.0825329im      0.0522511+0.0653958im      0.049363+0.0852455im      -0.177618-0.267749im\n -0.0342792-0.141253im      -0.238426+0.0468542im    0.0886243+0.107233im     0.0381363-0.120401im     -0.175651-0.0396658im    0.0872209-0.0937025im     0.122427-0.0381043im     -0.191722-0.0136711im     0.040602-0.0737143im    0.0860504+0.084925im      0.0247619+0.0365796im    -0.0464512-0.140952im      0.218651-0.136869im      -0.157569-0.0678284im    -0.163088+0.14664im        0.0111532+0.234221im      -0.0238115-0.0535727im      0.0676192+0.067573im        0.16141+0.0787134im    -0.0182287+0.0473954im      0.241316-0.128391im    -0.0578756-0.198977im    -0.0210565+0.289891im    -0.00549218+0.0510543im      0.0283583+0.216455im       0.129436-0.19358im       0.117659+0.104627im      0.128403+0.00881163im    0.0160216-0.0672982im      0.0548285+0.101306im       0.168388+0.269751im        0.140396-0.0573788im\n  -0.225257+0.0414013im     0.0414824-0.0870205im  -0.00125002+0.0168879im     0.120589+0.212306im     0.0470637+0.140161im     -0.170941-0.0291513im   -0.0440861+0.207443im      0.0402612+0.12108im      0.0767806-0.160262im     0.0165462-0.0836758im      0.030682-0.0116722im     0.0382299+0.326996im      0.231989+0.026578im      0.0136754-0.0151935im    -0.132931+0.000392866im   -0.0778377+0.105258im      -0.0797727+0.187131im       0.0397191-0.0505257im     0.0787821-0.0641407im     0.0524699-0.00387522im   -0.0435757-0.125296im   -0.00552883+0.204076im    -0.0587473-0.0408487im      0.163377-0.0286099im    -0.00289506+0.0154113im      0.178073-0.105327im     0.0702585-0.0457861im      0.14593+0.0904301im      0.395061-0.0476026im     -0.0212854-0.109701im     -0.0121976+0.176399im       -0.292928-0.095544im\n   0.137886+0.18191im        0.130313+0.0327466im     0.118663+0.0593853im    0.0627561-0.145708im      0.170642+0.0646462im     0.176262-0.0912696im    0.0619575+0.216836im      0.0617369+0.0669467im     0.163932-0.219798im     -0.109561+0.105992im     -0.0352472+0.0135036im    -0.0136739-0.0364121im   -0.0559575+0.0569505im     0.0496839+0.139064im     0.0865386-0.169257im      -0.0519926-0.23213im      -0.00773541-0.0978649im     0.00267212-0.0457776im      0.160596-0.1898im       -0.0711131-0.206633im       0.368265+0.202663im     -0.030647+0.0109724im     0.127038+0.144364im     -0.0246778+0.0508457im    -0.00558507+0.118863im     -0.0204846-0.0784775im   -0.0132168-0.0727495im    -0.128013-0.105928im       0.177323+0.154035im       0.0266067+0.142937im        0.19476+0.0352463im      -0.154213+0.0253236im\n  -0.249676-0.127036im      0.0213224-0.150712im      0.206342-0.0377104im   -0.0743283-0.0143208im    0.0867904+0.0404969im    0.0248633+0.0510114im     0.076782-0.108826im      -0.055372+0.234772im      0.130138+0.0444059im     0.141692-0.0390307im     -0.194367-0.00241416im     0.188347+0.140855im     0.0860492-0.129201im      0.0641944+0.0525604im    -0.121193+0.10123im        -0.300004-0.108222im       -0.178528-0.102806im        0.143888+0.00802017im     0.021087-0.0753311im       0.13762+0.0684075im      0.047085+0.322106im    -0.0113506+0.0252676im     0.200104+0.19734im       -0.129499+0.131455im       0.0679546-0.091372im      0.0224382+0.089742im     0.0593312+0.023665im     0.0337759-0.00793444im    -0.154789-0.185527im       0.0326739-0.0327243im     -0.185788-0.124083im        0.023484+0.136241im\n  -0.126649-0.156238im    -0.00259626+0.245541im     -0.104726-0.0433416im    0.0977379+0.0534655im     0.065833-0.0266474im    0.0130087+0.0727592im    0.0567315-0.0609647im      0.223869-0.103944im       0.14289-0.108294im    -0.0760882+0.107062im     -0.0369632+0.0307141im    -0.0779763+0.0318109im     0.156338-0.0843069im        0.1647-0.0406111im    0.0778119+0.019249im      0.00662662+0.106747im        0.207791+0.0344685im      -0.102424-0.323705im      -0.100803-0.133913im      0.0148366+0.221432im      0.0813667+0.0245733im    -0.166793-0.112853im     -0.160589+0.0855516im     -0.371038+0.0159192im       0.143387-0.162463im      -0.180258+0.118871im     0.0391874+0.0967364im    0.0403591-0.128298im       0.144094+0.110604im        0.162669-0.0527881im    -0.0904993+0.0940847im     -0.0203165+0.024229im\n  0.0463579+0.0304959im     -0.179379-0.0364966im    0.0658989-0.10275im    -0.00977827+0.0272683im     0.217341+0.333324im     -0.170845+0.0403377im   0.00655838-0.152194im     -0.0956277-0.140179im     -0.129755-0.0962659im   -0.0919241+0.170224im      -0.145316+0.189854im     0.00211921-0.217329im    -0.0930123-0.121822im      -0.129026+0.0680158im    -0.150272-0.108924im      -0.0660715+0.183582im       -0.016117+0.0123823im      0.0983609+0.0435974im    -0.0490889-0.122352im      0.0883271-0.047124im      -0.212751+0.164654im   -0.00489971-0.144472im     -0.086508+0.0312531im    -0.0698069-0.0544387im      -0.138165-0.0688836im      0.192707+0.0181075im    0.0912449-0.0781621im    -0.267231+0.110719im       0.158576+0.0893792im       0.208445-0.0826482im     0.0758455-0.0944285im     -0.0453453-0.113159im\n -0.0881023-0.212518im      0.0420182+0.0729799im    -0.056614+0.11396im     -0.0554617-0.0351326im      0.19426+0.194037im     0.0836075+0.0771053im    -0.262308+0.118062im      0.0528924+0.0448913im    -0.124394-0.10773im     -0.0971963+0.146739im      0.0132994+0.0869041im    -0.0570118+0.123254im     -0.136961-0.247478im      0.0995948-0.016145im      0.124879-0.167709im       0.0502267-0.165555im      -0.0895259+0.232195im       0.0901673+0.156728im     -0.0463143+0.00506978im    -0.226636+0.0882669im     0.0897046-0.0574519im     0.291355-0.165256im    -0.0450872+0.012088im        0.12179+0.0185441im      0.0532936+0.136885im         0.0183+0.0908587im     0.200007+0.120155im     0.0173032-0.0916442im    -0.0914623-0.16645im        0.0255386-0.143459im     -0.0809871+0.138703im        0.148801+0.0116596im\n  -0.107272+0.012571im      -0.215972+0.0453664im    -0.110097-0.0591736im     -0.21482-0.0413717im   -0.0650655-0.0053735im     0.228405-0.348424im     0.0368249+0.0862262im     -0.136717-0.114499im     0.0838454+0.00889508im  -0.0413416-0.176099im       0.259898-0.00336212im   -0.0146109+0.0461696im     0.141871-0.0821713im      0.235331+0.159412im     0.0101122+0.0425317im       -0.12939-0.0768439im       0.194958+0.0712595im      0.0214306-0.0973537im    -0.0157255-0.153326im      -0.215165-0.198717im      -0.267292+0.0396385im    0.0220684+0.0808091im    0.0269097+0.0233659im     -0.154921+0.0424716im       -0.17123+0.0076909im      0.164315+0.023694im     0.0667311+0.0555472im    -0.130817+0.0279818im    -0.0647061-0.0528522im     -0.0699174-0.185158im       0.100279+0.0185695im      0.0616618+0.0579979im\n -0.0841295-0.140318im       0.205831+0.149491im     0.0906117-0.0533096im   -0.0674903+0.0257811im    0.0285889+0.0769321im     0.292482+0.0103587im      0.14912-0.16308im       0.0469003-0.0318594im    -0.106024+0.089553im     -0.146603+0.0459397im     0.0827655+0.0215137im     0.0911229-0.0340743im   -0.0828042-0.0407503im     0.0310417-0.347183im    -0.0908392+0.0640947im        0.13658-0.0187414im      -0.171001+0.0817635im    -0.00463467+0.00888547im    0.0596631-0.038323im      -0.128554-0.025979im    -0.00413353+0.0806397im    -0.106348+0.207255im    0.00206326-0.156719im      -0.154567-0.105907im        0.117653-0.00505259im     0.334465-0.127708im     -0.212795+0.131534im     -0.140579-0.0506819im    -0.0396025-0.122997im    -0.000350631+0.18407im      -0.0454797+0.0829523im      -0.170667-0.180172im\n  -0.135671+0.0596685im    0.00788543-0.0460328im     0.328799+0.116695im     0.0109438+0.0553497im     0.146155+0.0249141im    0.0829159-0.141199im     0.0479557+0.0129129im    -0.0099768-0.198327im    -0.0268001+0.0856544im      0.16112-0.0810716im   -0.00785504+0.248822im     -0.0562466+0.127273im       0.10187+0.0148376im     0.0644244+0.0338071im     0.234301+0.213216im        0.150229+0.0845996im      0.0964571-0.245749im       -0.125124+0.152548im       0.149414-0.0684874im    -0.0911605+0.0801415im     0.0712458+0.0645247im    0.0818176-0.0936835im   -0.0816271-0.240481im      0.0747538-0.13775im      -0.00313367-0.0721699im    -0.0251908-0.175245im      0.158012-0.0511372im    -0.106215-0.0484053im      0.190829+0.0035044im     -0.0277375+0.0628212im     -0.258508-0.116855im        0.167785+0.0257314im\n  0.0219018+0.191347im      -0.229698+0.0422589im     0.144019-0.0296447im  -0.00960798+0.026235im     0.0772236-0.0831218im   -0.0723582+0.0304253im   -0.0265032+0.122206im       -0.14101+0.00367636im   -0.122425-0.240223im      0.125059-0.040345im     -0.0594322-0.109041im      -0.249972-0.00395902im    0.160456+0.18912im         0.17475-0.141628im    -0.0162995-0.0593076im       0.152831-0.0656472im        0.07646-0.0142691im   -0.000901707-0.00130023im  -0.00522599+0.102239im        0.14669+0.07233im        0.100767+0.117541im      0.128703+0.204142im    -0.0261384-0.147465im     -0.0915726-0.0768863im      0.0742421+0.0214421im      0.193718+0.112625im      0.123769+0.0165246im    0.0544395-0.137165im       -0.32359-0.0822733im        0.36743-0.0194459im     0.0774117-0.0344045im     -0.0885654-0.0478953im\n   0.151585-0.0981116im      0.166994+0.142208im      0.114728-0.237021im    -0.0101987+0.130488im      0.162125+0.0714833im    0.0246846-0.165471im       -0.1141-0.0361301im    -0.0204165+0.0512735im     -0.20646-0.0743442im    0.0702985-0.0220783im     -0.062651-0.280798im       0.108975+0.0960257im    0.0624267+0.227318im      0.0535601+0.083203im     0.0987943+0.131655im      0.00969063+0.190816im        0.118465+0.205927im      0.00840137+0.103999im       0.143449-0.0398543im      0.245223+0.0317777im     0.0560439-0.0452024im    0.0503866-0.174232im     0.0369641+0.107182im     -0.0933994+0.0527613im      -0.318168+0.0870311im   -9.76606e-5+0.0988555im    -0.127525+0.215571im    -0.0669128-0.153315im      0.0438489-0.0829551im      -0.149756+0.0685888im     0.0224043-0.051189im       0.0673275-0.0607037im\n    0.20405-0.121217im      0.0378264+0.0584626im    0.0469113-0.116385im      0.273034-0.200808im    -0.0848721+0.267081im     0.0569666-0.00191999im     0.17215+0.223245im     -0.0221787+0.050407im      0.207238-0.0376334im    0.0798021+0.0343084im    -0.0608318+0.256857im      -0.110452+0.0932001im   -0.0241459+0.0227044im   -0.00826295-0.119468im     -0.147635+0.0117372im     -0.0271243+0.046604im        0.125108+0.0737979im      0.0350632-0.026289im     -0.0986014-0.082754im    -0.00715526+0.157023im     -0.0133223-0.0145523im     -0.11629+0.173414im    -0.0417401-0.117892im       0.103358+0.120372im       -0.303002-0.0207584im     -0.207726-0.10243im       0.104235+0.0399278im   -0.0791742+0.0173173im     -0.293762-0.109753im       -0.123162+0.00272767im   -0.0697291-0.053578im      -0.0104349-0.160607im\n -0.0496588+0.1475im        -0.041251+0.154637im    -0.0528247+0.137935im     0.0936671-0.214986im     0.0555951-0.166016im     0.0332564-0.0683752im    -0.159023-0.0269118im     -0.194635-0.0599073im    0.0340625+0.0853484im   -0.0751944-0.203326im     -0.0480283+0.180419im        0.28491-0.0107299im     0.147991-0.0724192im     -0.155748+0.0656439im    -0.053676-0.0247884im     -0.0796295+0.000359065im    0.0626056+0.260996im      -0.0499446-0.00815118im    0.0221037+0.0632842im    -0.0895777+0.214818im       0.146307+0.031479im     0.0779351+0.0663068im   -0.0377451-0.0125428im     0.0224474+0.0736195im       0.121977+0.0973711im    -0.0335803+0.171308im     -0.134357+0.0415673im    -0.033654-0.0281584im       0.10324-0.0102304im      0.0640343+0.000240483im   0.0254923-0.387549im       -0.045553-0.338147im\n  0.0486462-0.00668951im  -0.00310929+0.179441im     -0.113866-0.027614im     -0.171402+0.117193im     0.0631839-0.0693694im    -0.156893+0.0935299im    -0.206352-0.00360571im    0.0194501-0.170488im      0.202389-0.0199268im     0.112127-0.0573992im    -0.0692712-0.0581472im     0.0679996-0.107209im     0.0118158-0.0211093im     0.0144084-0.0469611im    -0.199647+0.234884im       0.0369369-0.120293im      -0.0706228-0.0315854im       0.166796+0.0366348im     0.0627534-0.135284im       -0.13973+0.148462im      0.0920082-0.0870329im    -0.169695+0.156569im     -0.261818+0.136321im       0.242717-0.052013im       -0.100773+0.0163623im      0.104241+0.0680378im    0.0562075-0.142618im     -0.258942-0.273878im     -0.0360371-0.00432911im    -0.0606954+0.0949074im    0.00704373-0.0378981im     -0.0230408+0.272748im\n  0.0569319+0.0570984im    -0.0818236-0.0538985im   -0.0179353-0.0418944im    0.0687061-0.129352im      0.194669+0.0649033im    -0.114082-0.0505262im   -0.0616101-0.224838im       0.256995-0.0999626im     0.225694-0.0243717im    0.0102019-0.0725198im    -0.0829121-0.0690805im     -0.191417+0.072748im    -0.0726541-0.00253215im    0.0638434+0.0761689im    0.0141639-0.159613im      -0.0967297+0.0629962im      0.0508077-0.131074im     0.000143976-0.128354im        0.29585+0.255281im      0.0761741-0.00717919im  -0.00679616-0.160649im     0.0940267+0.139539im    -0.0914464+0.114636im     -0.0723028+0.000777528im     0.251539+0.100347im      0.0974624-0.141906im    -0.0983911+0.0582129im    -0.247985+0.0733088im    -0.0884217-0.216985im       -0.231943-0.130661im     -0.0421742-0.0121885im      0.0886331-0.116235im\n -0.0110701-0.0887451im     0.0831209-0.209348im      0.290723-0.0577116im   -0.0840909+0.0457174im   0.00937487+0.0583083im    -0.035697+0.0658508im    -0.113676+0.125643im      0.0240539-0.0412573im     -0.12991-0.0606548im     -0.21241-0.0479586im      0.144625+0.0526466im    -0.0539531-0.311512im      0.268716+0.137417im      -0.111229-0.0764652im   -0.0467689+0.0229644im       0.128357+0.00130503im     -0.170455-0.00837705im     0.0815651-0.196896im     -0.0863464+0.027879im     -0.0444252+0.0148821im     0.0140524+0.0243194im    0.0515771+0.0992339im   -0.0477328+0.0243746im     -0.193131+0.139848im        0.118289+0.0247141im     -0.101905+0.0823433im     0.218791-0.0611707im    0.0134986-0.0925175im     0.0266755+0.0214555im      -0.437785-0.116777im      0.0938227-0.117343im         0.05577-0.0422439im\n  0.0712643-0.136258im     -0.0139616-0.0365383im    -0.114207-0.0897255im    -0.149992+0.118788im      0.103455-0.0788815im     0.277105+0.170326im     0.0057294+0.0410469im     0.0357424+0.168812im      0.154218+0.0656244im   -0.0699526+0.0755907im    0.00333801-0.202978im       0.181328-0.10825im      0.0789667-0.0140867im      0.127311-0.0890427im    0.0281817-0.00710012im   -0.00682349+0.205107im       0.0845479-0.0337055im     -0.0616019+0.227198im       0.136563+0.207492im     -0.0722069-0.0204244im     0.0478157-0.0274197im     0.076983+0.189895im     0.0405509+0.0633635im     0.0025196-0.10111im       -0.0642444-0.179538im      -0.233339-0.0554078im     0.310821-0.221064im     -0.135607+0.112874im      0.0880486-0.0466692im       0.161545-0.0797012im      0.112548-0.072165im      0.00757463-0.205245im\n  0.0698404-0.115603im      0.0392981+0.016789im    -0.0882942+0.0654701im    -0.314398-0.0175604im     0.104091+0.013591im      -0.26064-0.110909im      0.114547+0.248644im        0.13906-0.185142im      0.227634+0.0731969im    -0.166819-0.0273939im      0.020079+0.141834im     -0.0855635+0.0579294im    0.0885408+0.130874im      -0.157122-0.149009im     0.0673918+0.159051im       0.0219252+0.0191013im      0.0143551+0.146228im       0.0114273+0.215413im     -0.0810758+0.0758134im      0.144313-0.121148im     -0.0232099+0.156283im     0.0193707-0.102989im      0.143108+0.031667im      -0.024717+0.1714im          0.106753-0.0538297im    -0.0351171-0.0942596im    -0.241604-0.177307im     0.0102698-0.148963im    0.000810898-0.186488im        0.166754-0.0845426im     0.0370013+0.070223im       0.0957774-0.0655796im\n\nand then generate the state ψ\n\npsi = P[:, 3]\n\n32-element Vector{ComplexF64}:\n 0.0012726886161744805 + 0.12113964727903195im\n  0.005133577562855207 - 0.14211415072862543im\n -0.042109964721717554 + 0.09255565209352135im\n   0.08023485603379354 - 0.03160153563658087im\n   0.36403664580365425 + 0.0im\n    0.0765457910731712 + 0.02185849138335361im\n  -0.16333610916556646 - 0.18515941177166956im\n -0.010339300880293771 - 0.0735400615561609im\n  -0.18636620409270102 + 0.1549617520139838im\n   0.15942441463610105 + 0.05483749089794266im\n  -0.03077405313667972 + 0.31828213272120615im\n  -0.15546631535959682 + 0.02776695234878801im\n  0.054159027940989174 + 0.025799124688396326im\n  -0.07933283891193085 - 0.1452936243843333im\n  -0.09672863785818435 + 0.008211457917888354im\n  -0.23934665988605064 + 0.10364231267174603im\n   0.10474268879655312 + 0.11093597840229222im\n  -0.17681079340016814 - 0.0004338614136403518im\n  -0.13398746955251067 - 0.06184881852239336im\n    -0.082358207135772 + 0.10290639482780822im\n   0.05189722551131373 + 0.14506076401789245im\n  0.030331917360319878 - 0.10816923985749921im\n     0.250762371345969 - 0.11617607520798164im\n  -0.05420459763228919 + 0.11601400981459731im\n   0.05318618309477792 + 0.2352320536132399im\n    0.0800631677003739 - 0.09683149571995688im\n   0.02198431495863278 - 0.07236390538510776im\n  -0.11910733081651395 + 0.08148460252078611im\n 0.0010996855775564224 + 0.15037005579460644im\n  -0.17608138831086256 + 0.06935792373892488im\n   0.08639680929591136 + 0.10489000149899977im\n 0.0029168322066786545 - 0.13766234181530726im\n\nIn the phase estimation process, we will feed the state to circuit and measure the first n qubits processed by iQFT.\n\nr = join(ArrayReg(psi), zero_state(N))\nr |> PE(N, M, U)\n\nArrayReg{2, ComplexF64, Array...}\n    active qubits: 8/8\n    nlevel: 2\n\nSince our phase can be represented by 3 qubits precisely, we only need to measure once\n\nresults = measure(r, 1:N; nshots=1)\n\n1-element Vector{DitStr{2, 3, Int64}}:\n 011 ₍₂₎\n\nRecall that our QFT's bit numbering is reversed, let's reverse it back\n\nusing BitBasis\nestimated_phase = bfloat(results[]; nbits=N)\n\n0.75\n\nthe phase is exactly 0.75!\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html","page":"Noisy Simulation","title":"Noisy Simulation","text":"(Image: )","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Noisy-Simulation","page":"Noisy Simulation","title":"Noisy Simulation","text":"using Yao\nusing YaoBlocks.Optimise: replace_block\nusing CairoMakie\n\nTo start, we create a simple circuit that we want to simulate, the one generating the 4-qubit GHZ state psirangle = frac1sqrt2(0000rangle + 1111rangle). The code is as follows:\n\nn_qubits = 4\ncirc = chain(\n    put(n_qubits, 1 => H),\n    [control(n_qubits, i, i+1 => X) for i in 1:n_qubits-1]...,\n)\n\nnqubits: 4\nchain\n├─ put on (1)\n│  └─ H\n├─ control(1)\n│  └─ (2,) X\n├─ control(2)\n│  └─ (3,) X\n└─ control(3)\n   └─ (4,) X\n\n\nVisualize the circuit\n\nvizcircuit(circ)\n\n(Image: )\n\nThe ideal simulation gives the following result:\n\nreg = zero_state(n_qubits) |> circ\nsamples = measure(reg, nshots=1000);\n\nVisualize the results\n\nhist(map(x -> x.buf, samples))\n\n<img width=600 height=450 style='object-fit: contain; height: auto;' src=\"data:image/png;base64, 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KgAAAADQsEqjRkZGcvvtt2fmzJk54YQT8uu88sor+dGPfpTBwcHMnz8/Bx98cPr7+7OjVq1alccffzwbN27MXnvtlYULF6arqysAAAAATK5Koz7zmc/ky1/+cvbff/+ccMIJ2ZaNGzfm05/+dG644YYMDQ1lwuzZs/PJT34yX/ziFzNt2rRsy3/913/ljDPOyN13353x8fFM2GuvvXLJJZdkyZIlAQAAAGDyVBp055135sorr8yvMzIykqOOOiorVqzIhHnz5uXFF1/MK6+8kosvvjg//vGPc/vtt6e7uzuv9fTTT+fwww/P4OBgOqoqs2bNytq1a/Pzn/88f/zHf5xf/vKXOffccwMAAADA5Kg05vnnn8+f/dmfZXx8PL/OhRdemBUrVqTjjDPOyAUXXJB3vOMd+c///M/89V//db797W/n3/7t33L11VfnnHPOyWstWbIkg4OD6e7uzjXXXJOPfvSjmTlzZh566KF87GMfy8qVK/OZz3wmRx99dN773vcGAAAAgJ2v0pDx8fGcdtppWb16dbq6ujI+Pp5tGRwczNVXX52O448/Pl/5ylfS3d2djne+8525+eab86EPfSgPP/xwLrvsspx55pmZNm1aJtx111154IEH0nHxxRfn9NNPz4TDDjss3/3ud/P+978/69aty0UXXZTly5cHAAAAgJ2v0pBly5bl7rvvzj777JP3v//9Wb58ebbljjvuyMaNG9NxySWXpLu7O1vr7+/P0qVL8yd/8if55S9/mR/84Ac58sgjM+Eb3/hGOubPn5+//Mu/zGstWLAgp5xySq677rrccccdGRoaSn9/fwAAAADYuSqNeOSRR3L++eenp6cnN998c66//vpszz333JOOPffcMwcddFB+leOPPz49PT0ZGxvLvffemyOPPDIT7rnnnnQce+yxmTZtWn6VxYsX57rrrsvw8HB+8IMfZNGiRQEAAABg56o0YMOGDfnoRz+a0dHRfPGLX8wRRxyR66+/Ptvzs5/9LB0HH3xwtuUtb3lLDjrooPzwhz/ME088kQnr16/PqlWr0nHwwQdnW4488shMeOKJJ7Jo0aIAAAAAsHNVGnD22WfnqaeeyhFHHJELLrggO+KZZ55Jx957753t2XvvvfPDH/4wTz/9dCY8/fTTmbD33ntnW2bPnp2BgYG8/PLLefrppwMAAADAzleZZN/4xjdyww03ZPbs2bn55pvT09OTHbF+/fp0DAwMZHsGBgbSsW7dukx45ZVXMmFgYCDbMzAwkJdffjnr1q3Ljlq0aFFej9WrV+fNaGRkJK+88kqmupGRkaxevTrA1Pbqq69m3bp1GR4ezqZNmwIwlb388svZsGFDNm/enKGhoQBT28jISKa6V155JS+++GJ6e3vDG1OZRM8991xOP/30dHz1q1/NPvvskx0xPDycLVu2pKOvry/b09/fn44NGzZkwsaNGzOhr68v29Pf35+ODRs2ZEfde++9eT2Gh4fzZjQyMpJNmzZlqtuyZUuGh4cDTG0jIyMZGRlJVWV4eDgAU9nIyEhGRkYyMjKSqgowtW3ZsiVT3aZNmzI8PJzx8fHwxlQmydjYWJYsWZJ169blYx/7WJYsWZIdVVWZMDY2lu3ZtGlTOrq6ujKhqjJhbGws27Np06Z0dHV1ZUfdc8892RGLFi1Kx/z58/NmNDw8nNkvjiRZm6mst7c38+fPDzC1rV+/PlWVWbNmZWBgIABT2fTp09PX15eBgYHMmjUrwNTW27suyVCmstmzZ2fevHnp6+sLb0xlkvzN3/xN7rvvvuy77775yle+ktejqjJ9+vSMjo5meHg42zM8PJyOmTNnZsIuu+ySCcPDw9me4eHhdMycOTM76uijj87r0dfXlzeradOmZarr7u5OX19fgKlt06ZN6e3tTW9vb/r6+gIwlfX29mZ0dDR9fX3p6+sLMLV1d3dnqps2bVr6+vrS19cX3pjKJLn88svTceihh+aaa67Jaz322GPpePnll3PppZem4+1vf3tOO+20dMybNy+rVq3KCy+8kO15/vnn07Hbbrtlwrx58zLhhRdeyLaMj49n9erV6dhtt90CAAAAwM5XmSRbtmxJx6233ppbb7012zI4OJjzzjsvHYceemhOO+20dLz73e/OqlWr8swzz2R7nn322XS85z3vyYR9990306dPz+joaJ555plsy6pVqzI6OpqO97znPQEAAABg56tMkt/93d/N6OhotuXJJ5/M888/n76+vhx++OHpePe7350Jhx56aL73ve/loYceytjYWHp6evJaL730Up5++ul0HHLIIZnQ09OThQsX5sEHH8z999+fbVmxYkUmHHLIIQEAAABg56tMkrvvvjvb84lPfCLXXXdd3vGOd+T73/9+XuuEE07I5ZdfnvXr1+fOO+/MiSeemNdavnx5JixevDhbO+GEE/Lggw/mP/7jPzI4OJi5c+fmtb75zW+mY6+99srChQsDAAAAwM5XeZP60Ic+lN/6rd/KT3/603z+85/PokWL0tvbmwkvv/xyLr744nQcd9xx2W+//bK1j3/847n44oszOjqaCy64IF/96leztRUrVuS2225Lx1lnnRUAAAAAJkflTaq7uzvLli3L8ccfn0cffTRHHXVUzjjjjCxcuDD33Xdfrr766vz3f/93+vv7c9lll+W19txzz5x77rm5+OKL84//+I959dVX80d/9EeZN29e7r333lx++eUZGxvLu971rpx99tkBAAAAYHJU3sSOPfbYXHXVVVm6dGnuu+++3HfffdnazJkzc/PNN+eggw7Kr/KlL30pv/jFL3LjjTfmpptuyk033ZSt7b///rnjjjsyY8aMAAAAADA5Ko066aSTsscee+Qtb3lLtuess87K7/zO7+Saa67JfffdlzVr1uStb31rjjzyyHzyk5/Mvvvum23p7u7Ov/zLv+TUU0/NDTfckJ/+9KcZGhrKXnvtlZNPPjlnnnlmZs6cGQAAAAAmT6VRJ510Uk466aTsiIULF+baa6/NG7V48eIsXrw4AAAAALSnAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyoAAAAA0LAKAAAAADSsAgAAAAANqwAAAABAwyqNGRsby8jISGbMmJHXa8uWLXnllVey6667pqurK6/X6OhohoeHM3v27AAAAADQhkoDnn322Xz+85/Pww8/nGeeeSabNm3KPvvsk4ULF+azn/1sDj/88GzP8uXL8w//8A954IEHsnnz5kyfPj0f/vCHc+655+aYY47J9mzatCnLli3LDTfckJUrV2Z8fDy77rprFi9enAsvvDALFiwIAAAAAJOnMsmuvfba/MVf/EWGhoaytWeffTbPPvtsvvOd7+TMM8/M1Vdfna6urrzWOeeck6uuuipbGx0dzT333JN77703F110Uc4777z8Khs2bMjRRx+d+++/P1tbt25dbrrppnz729/Od77znfze7/1eAAAAAJgclUn01FNP5Zxzzsno6Gjmzp2bSy+9NEcccUT6+vry4IMP5gtf+EKefPLJXHPNNVmwYEGWLl2arV1//fW56qqr0nH44Yfn7LPPzsEHH5z77rsvV1xxRZ588smcf/75Ofjgg3Pcccfltc4888zcf//96ViyZEk+9rGP5W1ve1vuueeefOlLX8qrr76aU089NT/72c/ytre9LQAAAADsfJVJ9KlPfSqjo6Pp7e3NihUrsv/++2fCfvvtl4985CP5wAc+kEcffTTnnXdelixZkvnz56djZGQkF154YTre9a535c4778ycOXPSccABB+Too4/O4YcfntWrV+f888/Pcccdl6395Cc/yU033ZSOU089NTfddFO6urrScfDBB+eAAw7IySefnLVr1+Zv//Zv83d/93cBAAAAYOerTJKXX345d999dzr+/M//PPvvv39eq7e3N3//93+fI488MsPDw3nggQdy4oknpuPuu+/OqlWr0nHllVdmzpw52do+++yTz33uc1m6dGkeeeSRPPbYYznooIMy4YYbbsj4+Hj6+/vzta99LV1dXdnaiSeemJNOOim33357brzxxlxxxRXp7u4OAAAAADtXZZL8+Mc/zpYtW9Lx4Q9/ONty2GGHpaurK+Pj43n00Udz4oknpuOuu+5Kx8DAQBYtWpRfZfHixVm6dGk67rrrrhx00EGZcNddd6Xj6KOPzsDAQH6VxYsX5/bbb89LL72Uhx56KIcddlgAAAAA2Lkqk2TTpk059NBD0/He974327Jx48aMj4+nY/bs2Znwox/9KB3ve9/70t3dnV9lv/32y4IFC7Jy5co89thjmTAyMpInn3wyHYcffni25bjjjsuExx57LIcddlgAAAAA2Lkqk+Soo47KQw89lF/nlltuyYRDDjkkE1auXJmOfffdN9uz//77Z+XKlVm5cmUmPPPMMxkbG0vHvvvum23Zfffd09/fn6GhoaxcuTIAAAAA7HyVhj3yyCM5//zz0/GBD3wgH/zgBzNhzZo16Zg/f362Z/78+ekYHBzMhDVr1mTC/Pnzsz3z5s3Lz3/+8wwODmZHLV++PK/Hxo0b82Y0PDyc0dHRTHVjY2PZuHFjgKltaGgoQ0NDqar09vYGYCobGhrK0NBQ+vr60tPTE2BqGxsby1Q3OjqajRs3ZsuWLeGNqTRoy5Ytufbaa3Puuedm48aNmTNnTr7+9a9nwujoaDZv3pyOvr6+bE9/f386NmzYkAkbNmzIhL6+vmxPf39/OjZs2JAd9Yd/+Id5PV566aW8GY2MjGT9+vWZ6kZHR/PSSy8FmNo2bNiQdevWZXR0NJs3bw7AVLZu3bps2LAhW7ZsyfDwcICpbXR0NFPd+vXrMzg4mN7e3vDGVBrzve99L3/1V3+VRx99NB177LFHbrvtthx44IGZMD4+ngldXV3ZnvHx8XRs3rw5E8bHxzOhq6sr2zM+Pp6OzZs3Z0edeuqp2RHLly9Px4wZM/Jm1NPTk+nTpycZylTW09OTGTNmBJjatmzZkpGRkfT392fGjBkBmMpGR0czNjaW/v7+zJgxI8DU1tPTk6lu+vTpmTFjRnp7e8MbU2nEL37xiyxdujTf+ta30tHd3Z2Pf/zjueKKK7Lrrrtma729venp6cnY2FiGh4ezPSMjI+nYZZddMmGXXXbJhOHh4WzPyMhIOnbZZZfsqG9+85vZEV1dXenYbbfd8mY0PDycWbNeTTKUqWz69OnZbbfdAkxtvb296e7uzqxZszJnzpwATGU9PT2ZPn165syZk1mzZgWY2qZPfyFT3axZszJ37tz09fWFN6bSgFtuuSWnn3561q9fn45jjz02l112WRYuXJhtGRgYyODgYNasWZPteemll9IxMDCQCQMDA5mwZs2abM/g4GA6BgYGAgAAAMDOV5lk1113XT7xiU+kY5999sm1116bY445Jr/OggULMjg4mOeeey7b84tf/CIdCxYsyIT9998/XV1dGR8fz3PPPZdtWbt2bV599dV0LFiwIAAAAADsfJVJ9N3vfjenn356Ov7gD/4gN954Y3bZZZfsiN/+7d/O/fffn4cffjjbMjQ0lMcffzwdBx54YCb09/fnne98Z1auXJmHH3442/Lwww9nwoEHHhgAAAAAdr7KJPrsZz+bsbGxHHnkkVm+fHl6enqyo4499th8/etfz/PPP5+HH344hx56aF7r3//937Np06Z0HH/88dnasccem5UrV+aee+7J6Ohopk+fnte644470rHrrrvmiCOOCAAAAAA7X2WSfP/7389PfvKTdFx22WXp6enJ6/H7v//7mTdvXl588cVccsklufXWW7O1LVu25LLLLkvHAQcckPe9733Z2p/+6Z/m6quvzuDgYL72ta/lk5/8ZLb2P//zP/mnf/qndCxZsiTTpk0LAAAAADtfZZJ873vfy4RLL700XV1d+XVOP/30LFq0KB0zZszI+eefn6VLl+a2227Lueeem0996lPZc88988QTT+Siiy7K/fffn46LL744XV1d2dr73//+fOQjH8ntt9+eT3/60+nv788pp5ySmTNnZsWKFTn77LOzbt26zJo1K5/73OcCAAAAwOSoTJKnn346E771rW9lRxx99NFZtGhRJpxzzjlZsWJFbrnllixbtizLli3LnDlzsnbt2kz43Oc+l5NPPjm/yvXXX58nn3wyjz/+eD7xiU/kjDPOSH9/f9avX5+O6dOn51//9V+zxx57BAAAAIDJUZkkc+fOzYc//OG8Hrvvvnu21tXVlZtvvjkf/OAH8+UvfzlPPfVU1q5dm45DDjkk5513Xk455ZRsy5w5c/LAAw/kC1/4Qv75n/85g4ODWb9+faoqxxxzTC666KK8973vDQAAAACTpzJJrrzyyvz/oaurK2eddVbOOuusDA4OZs2aNXnrW9+a2bNnZ0fMnDkPGA8UAAAas0lEQVQzy5Yty+WXX54XXnghQ0ND2X333dPX1xcAAAAAJl/l/yFz587N3Llz80Z0d3fn7W9/ewAAAABoSwUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQAAAABoWAUAAAAAGlYBAAAAgIZVAAAAAKBhFQCA/9se/Md4QR92A3/f1w+/T4bi6fyFsbUeKkj9xRLcHyNrNbNY1Ohc7VLm3KZjgc0fTWfV6aTapfTJCrVWUxvars6IbsFOG6HXZBG3FV2GXYtoD/EHhRUEFMHj+HX35BtzqY+P4OnzRD/e9/V6AQBAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVK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AK3s3HPPzbJly7J06dKcc8454b0pAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipXAe3TOOeekv78/ACRz5szJnDlzAkCycOHCLFy4MAAkS5cuDf/vSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEngP9u7dm5UrV2bDhg0ZO3ZsJk2alI6OjgAA0Bo2b96crq6unHbaaens7MxgrV+/PqtXr05PT08mTJiQKVOmpK2tLQAfZps3b05XV1dOO+20dHZ2hv//SuBduuOOOzJv3rxs2rQpA0opufDCC/ONb3wjHR0dARjqfvKTn2TGjBkZjLVr12bs2LEBGEruueeeXH/99Zk/f346OzvzTl544YVcddVVWbZsWfr7+zNgwoQJ+fKXv5zLLrssAB9W99xzT66//vrMnz8/nZ2dOZCLLroojz32WN7JVVddlS996UvhDSXwLvzVX/1VFixYkAGHHXZYtm7dmr179+aBBx7Ik08+mSeeeCIdHR0BGMqeeeaZbNmyJYPR19cXgKFk165d+c53vpPBeu655/Jbv/Vb2bJlS5pKKTn44IPzyiuv5KWXXspnP/vZbNiwIdddd10APmx27dqV73znOxms//qv/8qWLVvyTnbs2BF+rQQG6Yc//GEWLFiQpmnTpuWuu+7K5MmTs3nz5tx55525+eab88ILL+TKK6/MP//zPwdgKOvu7k7TMccck1mzZuVARo4cGYChYvPmzZk7d26effbZDNZll12WLVu2pNFo5M4778xnPvOZtLe35z//8z/zh3/4h+nu7s4XvvCFfOITn8jHP/7xAHxYbN68OXPnzs2zzz6bwdi1a1fWrVuXpssuuyzHH3989mfatGnh10pgkG699dY0TZgwIUuWLElHR0eaDjvssPzN3/xNNm7cmDvvvDNLlizJz3/+80yaNCkAQ9WaNWvSdPbZZ+dLX/pSAIayVatW5b777stPf/rTdHV1pbe3N4P16KOP5oknnkjT7bffniuvvDIDpk6dmkceeSRnnXVWtm3blttuuy0PPPBAAGq2atWq3HffffnpT3+arq6u9Pb2ZrDWrl2bvr6+NN10002ZOHFiGJwSGIQXX3wxK1asSNO1116bjo6OvNX111+fO++8M/39/XnggQcyadKkAAxV3d3daTrxxBMDMNQtX748t912W96L+++/P02HH354rrnmmrzVxz72sVx88cX59re/nYcffjg7d+7MqFGjAlCr5cuX57bbbst70d3dnaaDDjooH/3oR8PglcAg/OhHP8qAGTNm5O0cc8wx+fjHP56nnnoqXV1d+du//dsADFVr1qxJU2dnZwCGuunTp2fRokV5s8svvzyD8aMf/ShN5557boYNG5a3c/755+fb3/52ent78/jjj+eTn/xkAGo1ffr0LFq0KG92+eWXZzDWrFmTpuOPPz7Dhg0Lg1cCg/D000+n6Td+4zfykY98JPszffr0PPXUU3nmmWcCMFRt3Lgx27dvT9PEiROzZs2aPPbYY1m7dm2OOuqoTJ48OaeffnrGjBkTgKGgs7MznZ2debPLL78872T79u1Zv359mk477bTsz/Tp0zPgmWeeySc/+ckA1KqzszOdnZ15s8svvzyD0d3dnaaJEydm7969efTRR7N69er09PRk0qRJmTJlSk444YTwfyuBQVi7dm2aJkyYkAM57rjj0rR169a8+uqrGTduXACGmjVr1mTA/Pnz8+CDD2bfvn15syOPPDLf+MY3cuGFFwagVT333HMZcNxxx2V/xo4dm3HjxuXVV1/Nc889F4Chas2aNWnatGlTTj755HR3d+etPvvZz2bBggUZP358+LUSGITXXnstTePGjcuBjBs3LgO2bduWcePGBWCo6e7uzoD7778/o0aNymmnnZajjz46Tz/9dJ5++un8z//8Ty666KLceuutuemmmwLQil577bUMGDduXA5k3LhxefXVV7Nt27YADFXd3d1peuKJJ9J03HHH5cwzz8zWrVvz1FNP5ZVXXsm9996bH//4x/nv//7vdHR0hDeUwCD09PSkaeTIkTmQUaNGZcDrr78egKGou7s7A6688sp87Wtfy8iRIzPg8ccfz6xZs7J27drMmzcvF154YSZNmhSAVtPT05MBI0eOzIGMGjUqTa+//noAhqJdu3Zl3bp1aTryyCPz4IMPZtq0aRnQ09OTL37xi1mwYEF+9atf5S//8i/zj//4j+ENJTAIpZQ07du3LweyZ8+eDGhrawvAUHT22Wfny1/+cjo6OnLFFVfkrX77t387ixcvztSpU7Nnz57ceuutWbx4cQBaTSklA/bt25cD2bNnT5ra2toCMBTt2rUrt912W5ouuOCCTJw4MW82evTofO1rX8vzzz+fH/zgB7nvvvty44035uSTTw5JCQzCmDFj0tTb25sD6e3tzYD29vYADEXnnXdezjvvvBzIGWeckd/7vd/LI488kpUrVwagFY0ZMyYDent7cyC9vb1pam9vD8BQNHbs2Pz1X/913slNN92UH/zgB2lauXJlTj755JCUwCB0dHSkaePGjTmQX/3qV2lqa2vL+PHjA9DKJk+enEceeSRr165NT09PRo8eHYBW0tHRkQEbN27M/vT392fTpk1pOuywwwLQyk455ZQ0Go309fXlZz/7WXhDCQxCZ2dnmtatW5c9e/Zk2LBheTvPP/98mo499tiMHj06AK1s/PjxaWo0GimlBKDVHH/88Rk+fHh2796dtWvXZn/Wr1+f3bt3p2nixIkBaGWjRo3K6NGjs2PHjowYMSK8oQQG4YwzzkjT7t27s3LlykydOjVvZ8WKFWk6/fTTAzAUrV+/PvPmzUvT7Nmzc+qpp2Z/fvGLX6TpxBNPzPDhwwPQag466KBMmTIlTz75ZH7yk59kf1asWJEBp59+egCGorvvvjsrV67MhAkT8sUvfjH7s2HDhuzYsSNNkyZNCm8ogUGYPn16Ro0alZ07d2bx4sWZOnVq3mr16tX5+c9/nqZPf/rTARiKjjzyyPzLv/xLNmzYkF27dmXRokV5Ozt37syyZcvSNGXKlAC0qk996lN58skn8+Mf/zhbtmzJ+PHj81aLFy9O04QJEzJlypQADFV333132tra8pnPfCbHH3983s5DDz2UAVOmTAlvKIFBGDVqVP7oj/4o3/zmN3PXXXdl9uzZ+chHPpIB/f39+cIXvpCmjo6OXHLJJQEYihqNRi699NL8/d//fb73ve/l4osvzqc+9am82d69e3PttdfmxRdfzLBhw3L99dcHoFX98R//cW6//fbs3r07N954Y775zW/mzVasWJF/+qd/StPs2bMDMFRdfPHFmTNnTvbs2ZNZs2alq6srw4cPz5utWrUqN9xwQ5ouvfTSnHjiieENJTBIN954Yx588MG8/PLL+Z3f+Z1cc801mT59ep599tl897vfzQ9/+MM03X777Wlvbw/AUHXDDTdkyZIlef755zNz5sx87nOfyyc+8YmMHTs2zzzzTO6999489dRTabruuusyefLkALSqY489Ntddd11uv/323HXXXdmxY0f+4A/+IB0dHenq6sr8+fOzb9++nHjiiZkzZ04Ahqrx48fn7/7u73Lttddm+fLlOeWUU/IXf/EX+djHPpbNmzfnySefzLe+9a3s3r07hxxySBYsWBB+rQQG6aijjsqSJUtywQUXZN26dbn66qvzZm1tbbnhhhvyJ3/yJwEYysaPH5+HHnooM2bMyEsvvZRFixZl0aJFebMRI0bklltuyec///kAtLp58+Zl3bp1+Yd/+Id8//vfz/e///282Uc/+tE8/PDDGT16dACGsmuuuSYvvvhi7rjjjqxZsyZXX3113mrq1KlZtGhRjjjiiPBrJfAuTJs2LT/72c9yxx13ZOnSpdmwYUPGjh2bM844I1dddVXOPvvsALSCyZMnp7u7O/fcc08effTRvPDCC9m+fXtOOeWUnHrqqfnc5z6XiRMnBmCouvnmm9M0bdq0vJNGo5Hvfe97ueSSS7Jo0aKsWrUqO3fuzIQJEzJz5sz8+Z//edrb2wPwYXXzzTenadq0aXknCxYsyJ/92Z9l4cKFWb16dV588cV0dHRkypQpOfvsszNr1qwcdNBB4f9UAu/SEUcckXnz5mXevHkBaGXDhw/P7NmzM3v27AC0mltuuSXv1vnnn5/zzz8/AEPNLbfcknfjlFNOyd133x0GrwQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAV+9+mYbFEVSxKAQAAAABJRU5ErkJggg==\"/>\n\nAdd errors to noise model\n\ncirc_noisy = Optimise.replace_block(circ) do x\n    if x isa PutBlock && length(x.locs) == 1\n        chain(x, put(nqubits(x), x.locs => quantum_channel(BitFlipError(0.1))))\n    elseif x isa ControlBlock && length(x.ctrl_locs) == 1 && length(x.locs) == 1\n        chain(x, put(nqubits(x), (x.ctrl_locs..., x.locs...) => kron(quantum_channel(BitFlipError(0.1)), quantum_channel(BitFlipError(0.1)))))\n    else\n        x\n    end\nend\n\npush!(circ_noisy, repeat(quantum_channel(BitFlipError(0.05)), n_qubits)) # add measurement noise\n\nnqubits: 4\nchain\n├─ chain\n│  ├─ put on (1)\n│  │  └─ H\n│  └─ put on (1)\n│     └─ mixed_unitary_channel\n│        ├─ [0.9] I2\n│        └─ [0.1] X\n├─ chain\n│  ├─ control(1)\n│  │  └─ (2,) X\n│  └─ put on (1, 2)\n│     └─ mixed_unitary_channel\n│        ├─ [0.81] kron\n│        │  ├─ 1=>I2\n│        │  └─ 2=>I2\n│        ├─ [0.09000000000000001] kron\n│        │  ├─ 1=>I2\n│        │  └─ 2=>X\n│        ├─ [0.09000000000000001] kron\n│        │  ├─ 1=>X\n│        │  └─ 2=>I2\n│        └─ [0.010000000000000002] kron\n│           ├─ 1=>X\n│           └─ 2=>X\n├─ chain\n│  ├─ control(2)\n│  │  └─ (3,) X\n│  └─ put on (2, 3)\n│     └─ mixed_unitary_channel\n│        ├─ [0.81] kron\n│        │  ├─ 1=>I2\n│        │  └─ 2=>I2\n│        ├─ [0.09000000000000001] kron\n│        │  ├─ 1=>I2\n│        │  └─ 2=>X\n│        ├─ [0.09000000000000001] kron\n│        │  ├─ 1=>X\n│        │  └─ 2=>I2\n│        └─ [0.010000000000000002] kron\n│           ├─ 1=>X\n│           └─ 2=>X\n├─ chain\n│  ├─ control(3)\n│  │  └─ (4,) X\n│  └─ put on (3, 4)\n│     └─ mixed_unitary_channel\n│        ├─ [0.81] kron\n│        │  ├─ 1=>I2\n│        │  └─ 2=>I2\n│        ├─ [0.09000000000000001] kron\n│        │  ├─ 1=>I2\n│        │  └─ 2=>X\n│        ├─ [0.09000000000000001] kron\n│        │  ├─ 1=>X\n│        │  └─ 2=>I2\n│        └─ [0.010000000000000002] kron\n│           ├─ 1=>X\n│           └─ 2=>X\n└─ repeat on (4)\n   └─ mixed_unitary_channel\n      ├─ [0.95] I2\n      └─ [0.05] X\n\n\nsimulate the noisy circuit\n\nrho = apply(density_matrix(reg), circ_noisy)\nsamples = measure(rho, nshots=1000);\n\nVisualize the results\n\nhist(map(x -> x.buf, samples))\n\n<img width=600 height=450 style='object-fit: contain; height: auto;' src=\"data:image/png;base64, iVBORw0KGgoAAAANSUhEUgAABLAAAAOECAYAAACxbcj6AAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAgY0hSTQAAeiYAAICEAAD6AAAAgOgAAHUwAADqYAAAOpgAABdwnLpRPAAAAAlwSFlzAAAdhwAAHYcBj+XxZQAAIABJREFUeAHswXmQH3RhP+7Xhnf2ILshqyScIiAhEkm41QFbK6IcAwYVqjK06lAVPBCpsYIVgxbLIVLATluwiiPIoNaCUrki0yE1BCRAQMRkU5QACoHNtdlk95Njv7/PHzuT4UdioDb7Tvd5njL0/wkAAAAAVKoEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRJGTEtLSwAAAAC2B0NDQxkpJQAAAABQsRJG3NDQULZHAwMDWbp0adrb2zNp0qQAjGZ9fX1Zvnx5urq60t3dHYDRbPny5enr60t3d3e6uroCMJotXbo0AwMDmTRpUtrb27M9amlpyUgrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWUolFixbloYceyqJFi9Lf35+pU6fmoIMOykEHHZQ/ZOPGjfnZz36WefPmpbe3N5MmTcqf/dmf5cgjj8zWWLNmTW655ZY89thjWbNmTfbaa6+ceOKJ2W+//QIAAADAyCoZYcuXL895552Xa6+9Nhs3bsyLnXDCCbn66quz77775qX86le/yvvf//48+uijebGjjjoq3/ve97LXXntlc26++eacccYZWbZsWTb1mc98Jh/5yEdy1VVXpb29PQAAAACMjJIRtGHDhhx99NF5+OGH07T33nvniCOOSHt7e37xi1/k17/+dX76059mzpw5efjhh7PvvvtmU08//XSOPvroPPfcc2nab7/9csghh2Tu3Ll55pln8vOf/zzveMc7ct9992XChAl5sTvuuCOnnHJKNmzYkDFjxuTwww/Prrvumv/8z//MqlWrcu2112blypW56aabwktbvzFZvnZ9duhvZLRqLWPS1VYCAAAA/O8oGUH/+I//mIcffjhN5557bi6++OKMHTs2w77zne/kIx/5SPr6+nL66adnzpw52WGHHTLsnHPOyXPPPZemG264IaeddlqGXXzxxTnvvPOyaNGiXHjhhbniiiuyqcHBwZxxxhnZsGFDJkyYkLlz5+aAAw5I07p16/Ke97wnt956a77//e/ntNNOy4wZM8L/3y+fX5sv/9fSJP+d0epP931Vvj7jDQEAAAD+d5SMkKGhoVx00UVpOuigg3LZZZdlzJgx2dQHP/jBLFmyJBdccEHuvffeLFiwIIceemiaFi9enB/96EdpmjlzZk477bRs6vOf/3wefPDB/OAHP8i//Mu/5MILL8z48eMz7IYbbsgzzzyTphtuuCEHHHBAho0dOzY33nhjpk+fnt/85je57LLLMmPGjAAAAACw7ZWMkMcffzxLly5N00c/+tGMGTMmL+X000/PBRdckKb58+fn0EMPTdOPf/zjDA0NpaWlJZ/5zGfyUj784Q/nBz/4QdauXZu77ror733vezPs5ptvTtPrX//6nHDCCXmxzs7OnHrqqbn00ktz77335vnnn8/EiRMDAAAAwLZVMkJ++9vfZti0adOyOXvuuWdaWloyNDSU3//+9xl2zz33pGnq1KnZbbfd8lKOPvrodHZ2ZvXq1bnnnnvy3ve+N8PmzJmTpre//e3ZnHe961259NJLs3HjxvzXf/1X3v3udwcAAACAbatkhBx88MH5yU9+kqbDDjssm/Pwww9naGgoTfvtt1+GLVy4ME0HHnhgNqetrS3Tp0/P3Llzs2jRogx77rnnsmLFijQdeOCB2ZwjjjgiLS0tGRoayqJFiwIAAADAtlcyQnbffffsvvvu2ZKNGzfmi1/8Ypo6Oztz7LHH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AAAAgG2vZIS97nWvyxNPPJFXoqenJ02vf/3rU0rJy/Gv//qvWbNmTVpaWvLDH/4wXV1d2dSsWbNyxx13ZN68ebn66qtz9tlnBwAAAIBtr2SEvepVr8qGDRsybMWKFVm5cmW2xuLFi9M0ZcqUvFy33nprmo466qhMmTIlL+U973lP5s2bl8WLF6enpyeTJ08OAAAAANtWyQj7xS9+kU3NmjUrF154Yf6QwcHBPPXUU2maMmVKhjUajbS2tmZLNm7cmAcffDBNb3nLW7I5J554Yj73uc+l6f7778/kyZMDAAAAwLZVsp164oknsnHjxjSNHTs2H/rQh3L33Xfn6aefzs4775xp06blxBNPzNlnn50ddtghm1qyZEkGBgbStP/++2dzpkyZklJK1q9fn56engAAAACw7ZVsp3p6ejLs2GOPzfr16zPs+eefz91335277747119/fb73ve9lypQpGfbss89m2G677ZbNGTNmTHbZZZc888wz+f3vf5+tNX/+/LwcjUYj26NGo5ENGzZktNu4cWMajUaA0a3RaGTdunVpNBppNBoBGM0ajUbWrVuXRqORRqMRgNFs3bp1WbduXRqNRsaMGRNemZLt1OLFizNsxx13zLnnnpsjjzwye+yxR371q1/l2muvzZ133pkHH3ww73//+/OLX/wipZQ09ff3Z9iOO+6YLeno6EhTf39/ttbhhx+el+PZZ5/N9mhwcDArVqzIaDc4OJhnn302wOjW39+flStXZs2aNRkcHAzAaLZy5cr09/en0Wikv78/AKNZb29vBgcHs3HjxrS1tYVXpmQ79eSTT6atrS0TJ07M7NmzM2XKlAybOnVqTjnllHz+85/PJZdckocffjhXXHFFZs6cmaZGo5FhpZRsSSklTQMDA9lahx12WLbG/Pnz09Ta2prt0dDQUEopSTZkNBszZkxaW1sDjG6NRiNjx45Na2trWltbAzCatba2ptFoZOzYsWltbQ3AaDZ27Nhs3Lgxra2taW1tDa9MyXbqyiuvzJVXXpktufDCC3PTTTflt7/9bW655ZbMnDkzTTvuuGOGDQ4OZksGBgbS1NHRka31wAMPZGu0tLSkadddd832aGBgIDstHUiyNKNZW1tbdt111wCjW19fX1pbW9PV1ZXu7u4AjGZtbW3p6OhId3d3urq6AjCajRkzJgMDA5k0aVLa29vDK1Pyf1hbW1uOOeaYfPOb38yjjz6aYV1dXRm2atWqbMmqVavS1NXVFQAAAAC2vZL/4/bff/80rVq1KitWrMiECROyzz77ZNjTTz+dzVm7dm2WLVuWpn322ScAAAAAbHsl26FGo5Fly5alaeedd04pJZuzfPnyNO28886ZMGFCmrq7u7PLLrvkueeeyyOPPJLNefTRRzPsgAMOCAAAAADbXsl2aPny5dlzzz2zYcOGfOMb38gnPvGJbM4jjzySpmnTpmVTRx99dG688cbcfffd2Zyf/exnaRo7dmz+9E//NAAAAABseyXboV122SVve9vbMnv27Fx11VX54Ac/mM7OzrzYvHnz8tOf/jRNJ5xwQjZ16qmn5sYbb8zixYtz++2357jjjsumBgcH881vfjNNxx13XMaPHx8AAAAAtr2S7dQnPvGJzJ49O4sWLcq73/3uXHPNNdlnn33SNDQ0lB/96Ef55Cc/maGhoUybNi2f/vSns6mTTz4506ZNy6OPPpqPfexjmT17diZPnpymRqORM888M0888URaWlryt3/7twEAAABgZJRsp04++eTMnDkzl112WWbPnp3Jkydn3333zfjx47Nw4cKsXr06Tbvttluuu+66jB07NptqaWnJDTfckCOPPDJLlizJlClTcthhh2XixImZM2dOVq9enaYvfelLeeMb3xgAAAAARkbJduziiy/OPvvsk69+9at5+umn09PTk2E77LBDTj/99FxxxRXp7u7OS5k2bVp+/vOf58Mf/nAefPDBPPDAAxnW3d2diy66KGeddVYAAAAAGDkllZk1a1ZmzZqVrTFmzJicddZZOeOMM/LLX/4yv/3tb9PX15c3vOENecMb3pCOjo78IdOnT8/8+fPzyCOP5LHHHsvatWuz11575U/+5E/S1tYWAAAAAEZWyf8Bra2tOfTQQ3PooYfmlZo+fXqmT58eAAAAAOpSAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAwB/BwPqNWTWwPqPV6v51aazbmK4AAAB/bCUA8Edw2+NLc9Hsnoxmx7+uK+f+yU4BAAD+uEoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAADwR/XTx5fmnid6M1o1Go28dc/2HN3dHQD4YygBAAD+qBY935/Zi17IaDZlQgkA/LGUAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAACA/yULfrcqz69uZLRaubIv+08Yk0nhf6IEAAAA4H/Jd37xVO55YllGswveMimTXxP+B0oAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlYCAAAAABUrAQAAAICKlQAAAABAxUoAAAAAoGIlAAAAAFCxEgAAAACoWAkAAAAAVKwEAAAAACpWAgAAAAAVKwEAAACAipUAAAAAQMVKAAAAAKBiJQAAAABQsRIAAAAAqFgJAAAAAFSsBAAAAAAqVgIAAAAAFSsBAAAAgIqVAAAAAEDFSgAAAACgYiUAAAAAULESAAAAAKhYCQAAAABUrAQAAAAAKlZSoRUrVqTRaGTSpEl5OTZu3JhVq1Zlp512SktLS16uRqORgYGBjB8/PgAAAADUoaQyQ0NDOfjgg/PCCy9k9erV2Ro/+MEP8g//8A+5//77s379+rS2tuatb31rPvvZz+ad73xntmTdunW5/PLL8+1vfzs9PT0ZGhrKTjvtlJNOOikXXHBBJk+eHAAAAABGTkll7rnnnjz55JMZN25ctsbZZ5+dq6++OptqNBq56667Mnv27Fx00UU577zz8lL6+/tzzDHHZN68ednUypUrc/311+ff//3fc8stt+Ttb397AAAAABgZJRXp7e3NRz7ykWytb33rW7n66qvT9KY3vSmf+tSncsghh2Tu3Ln52te+loULF+YLX/hCDjnkkBx33HF5sbPOOivz5s1L02mnnZbTTz89u+66a+6666585StfyerVq3PqqafmV7/6VXbdddcAAAAAsO2VjLAFCxbksccey5w5c3L99ddn9erV2RqDg4O54IIL0rT//vvntttuS3d3d5qmTp2aY445Jm9605uydOnSfOELX8hxxx2XTf3yl7/M9ddfn6ZTTz01119/fVpaWtJ0yCGHZOrUqZkxY0aWL1+eSy+9NF//+tcDAAAAwLZXMsKOPfbYPPfcc3m57rzzzjzzzDNpuuqqq9Ld3Z1N7b333jn//PNzzjnn5MEHH8wjjzyS6dOnZ9i3v/3tDA0NpaOjI9dcc01aWlqyqRNPPDHvete7cvPNN+e73/1uvva1r2XMmDEBAAAAYNsqGWHve9/7snLlygx7+OGHs2DBgvwht99+e5omTJiQd7zjHXkpJ510Us4555w03X777Zk+fXqG3X777Wk65phjMmHChLyUk046KTfffHNeeOGFPPDAA3njG98YAAAAALatkhF25ZVXZlOzZs3KggUL8ocsWLAgTYcffnjGjBmTl7Lvvvtm8uTJ6enpySOPPJJhg4ODWbhwYZre9KY3ZXOOO+64DHvkkUfyxje+MQAAAABsWyXbqZ6enjTts88+2ZLXve516enpSU9PT4Y98cQT2bBhQ5r22WefbM7u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Jz7xibS1teWnP/1pPvWpT6WjoyOf//znc8opp+R973tfAAAAAHjrlezDVq1albqTTz45X/rSl/J6PPjgg3n88cdTt2DBglx00UUZNG3atDzwwAM56aSTsnXr1lx33XW55557AgAAAMBbr2Qf1tHRkboJEybk9br77rtTd/DBB+fSSy/Nax199NE5++yzc9ttt+X+++9Pd3d3Ro4cGQAAAADeWiX7sFWrVqVu4sSJeb1+9KMfpe60007L8OHD87vMmjUrt912W3p6evLoo4/m1FNPDQAAAABvrZJ91Pr169PZ2Zm6SZMmZdWqVXn44YezevXqHHrooZkyZUpOOOGEjBo1Kq/V2dmZtWvXpu7444/PnsyYMSODVq5cmVNPPTUAAAAAvLVK9lGrVq3KoIULF+bee+9Nf39/dnfIIYfk61//es4888zs7rnnnsugI488MnsyZsyYjB07Nq+88kqee+65AAAAAPDWK9lHdXR0ZNDdd9+dkSNH5vjjj89hhx2Wp59+Ok8//XR+/etf56yzzsq1116bq6++OoO2bduWQWPHjs3ejB07Nq+88kq2bt2aofrYxz6W12Pjxo3ZF/X29qazszONrq+vLxs3bgyNrbOzM41ux44daXS9vb3ZtGlT+vv7AzS27u7uNLpXX301mzZtSm9vb4DG1tfXl0bX2dmZTZs2ZcSIEeGNKdlHdXR0ZNBFF12Ur371q2lpacmgRx99NHPmzMnq1aszf/78nHnmmZk8eXLqurq6MqilpSV7M3LkyNS9+uqrGap77rknr0dXV1f2Rb29venr60uj6+/vT1dXV2hsfX19aXS7dvWn0e3cuTPd3d1pbm4O0Nh27NiRRrdz5850d3enVqsFGtl9HduycmNPGlln3640ur6+vnR1daW/vz+8MSX7qJNPPjnXX3992tvbc+GFF+a1PvjBD2bx4sWZNm1aduzYkWuvvTaLFy9OXSklg/r7+7M3O3bsSF1TU1OGavHixRmKj33sY6k76KCDsi/q6enJ6A09SV5JI2tubs5BBx0UGtvoLbUkG9PIhg8fnqQ3jWzEiBEZN25cxo4dG6CxjRzZk2RbGllra2vGjRuXtra2QCN78cltWb6uO43smINb0+hGjx6dcePGpaWlJbwxJfuo008/Paeffnr25sQTT8yHP/zhPPDAA3nyySczaNSoURnU09OTvenp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XJGbb745AwMDueeeezJ58uQA7K86OjpSN2HChADs7x555JFcd911eSPuvvvu1B188MG59NJL81pHH310zj777Nx22225//77093dnZEjRwagqh555JFcd911eSM6OjpSN2zYsLz73e8OQ1cCQ/CjH/0og2bOnJnf5fDDD8/73ve+PPXUU1m2bFn+4R/+IQD7q1WrVqVu4sSJAdjfzZgxI4sWLcruLrjgggzFj370o9SddtppGT58eH6XWbNm5bbbbktPT08effTRnHrqqQGoqhkzZmTRokXZ3QUXXJChWLVqVeqOOuqoDB8+PAxdCQzB008/nbp3vOMdede73pU9mTFjRp566qmsXLkyAPur9evXp7OzM3WTJk3KqlWr8vDDD2f16tU59NBDM2XKlJxwwgkZNWpUAPYHEydOzMSJE7O7Cy64IL9PZ2dn1q78kKIAAAipSURBVK5dm7rjjz8+ezJjxowMWrlyZU499dQAVNXEiRMzceLE7O6CCy7IUHR0dKRu0qRJ2blzZx588ME888wz6erqyuTJkzN16tS85z3vCf9/JTAEq1evTt348eOzN0ceeWTqNm/enFdeeSVjx44NwP5m1apVGbRw4cLce++96e/vz+4OOeSQfP3rX8+ZZ54ZgEb13HPPZdCRRx6ZPRkzZkzGjh2bV155Jc8991wA9lerVq1K3YYNG/Le9743HR0dea1PfvKTueGGGzJu3LjwX0pgCLZt25a6sWPHZm/Gjh2bQVu3bs3YsWMDsL/p6OjIoLvvvjsjR47M8ccfn8MOOyxPP/10nn766fz617/OWWedlWuvvTZXX311ABrRtm3bMmjs2LHZm7Fjx+aVV17J1q1bA7C/6ujoSN3jjz+euiOPPDLvf//7s3nz5jz11FPZsmVL7rzzzvz4xz/Of/zHf6S9vT38VgkMQVdXV+paWlqyNyNHjsygV199NQD7o46Ojgy66KKL8tWvfjUtLS0Z9Oijj2bOnDlZvXp15s+fnzPPPDOTJ08OQKPp6urKoJaWluzNyJEjU/fqq68GYH/U29ubNWvWpO6QQw7Jvffem+nTp2dQV1dXvvCFL+SGG27Ib37zm/zN3/xN/vmf/zn8VgkMQSkldf39/dmbHTt2ZFBTU1MA9kcnn3xyrr/++rS3t+fCCy/Ma33wgx/M4sWLM23atOzYsSPXXnttFi9eHIBGU0rJoP7+/uzNjh07UtfU1BSA/VFvb2+uu+661H30ox/NpEmTsrvW1tZ89atfzfPPP5/vf//7ueuuu3LVVVflve99b0hKYAhGjRqVup6enuxNT09PBrW1tQVgf3T66afn9NNPz96ceOKJ+fCHP5wHHnggTz75ZAAa0ahRozKop6cne9PT05O6tra2AOyPxowZk7/7u7/L73P11Vfn+9//fuqefPLJvPe97w1JCQxBe3t76tavX5+9+c1vfpO6pqamjBs3LgCNbMqUKXnggQeyevXqdHV1pbW1NQCNpL29PYPWr1+fPRkYGMiGDRtSd9BBBwWgkR177LGp1WrZtWtXfvGLX4TfKoEhmDhxYurWrFmTHTt2ZPjw4fldnn/++dQdccQRaW1tDUAjGzduXOpqtVpKKQFoNEcddVSam5vT19eX1atXZ0/Wrl2bvr6+1E2aNCkAjWzkyJFpbW3N9u3bM2LEiPBbJTAEJ554Yur6+vry5JNPZtq0afldli9fnroTTjghAPujtWvXZv78+ambO3dujjvuuOzJr371q9RNmDAhzc3NAWg0w4YNy9SpU/PEE0/ksccey54sX748g0444YQA7I+++c1v5sknn8z48ePzhS98IXuybt26bN++PXWTJ08Ov1UCQzBjxoyMHDky3d3dWbx4caZNm5bXeuaZZ/LLX/4ydR/5yEcCsD865JBD8oMf/CDr1q1Lb29vFi1alN+lu7s7S5cuTd3UqVMD0KjOOOOMPPHEE/nxj3+cTZs2Zdy4cXmtxYsXp278+PGZOnVqAPZX3/zmN9PU1JRPfOITOeqoo/K73HfffRk0derU8FslMAQjR47Mn//5n+cb3/hGbrnllsydOzfvete7MmhgYCCf//znU9fe3p5zzjknAPujWq2Wc889N1/5yldy++235+yzz84ZZ5yR3e3cuTOXXXZZXnzxxQwfPjxXXHFFABrVpz/96SxYsCB9fX256qqr8o1vfCO7W758eb73ve+lbu7cuQHYX5199tmZN29eduzYkTlz5mTZsmVpbm7O7lasWJErr7wydeeee24mTJgQfqsEhuiqq67Kvffem5dffjl/+qd/mksvvTQzZszIs88+m+985zv54Q9/mLoFCxakra0tAPurK6+8MkuWLMnzzz+f2bNn5/zzz88pp5ySMWPGZOXKlbnzzjvz1FNPpe7yyy/PlClTAtCojjjiiFx++eVZsGBBbrnllmzfvj0f//jH097enmXLlmXhwoXp7+/PhAkTMm/evADsr8aNG5d//Md/zGWXXZZHHnkkxx57bP76r/86Rx99dDZu3Jgnnngi3/rWt9LX15cDDjggN9xwQ/gvJTBEhx56aJYsWZKPfvSjWbNmTT772c9md01NTbnyyivzF3/xFwHYn40bNy733XdfZs6cmZdeeimLFi3KokWLsrsRI0bkmmuuyec+97kANLr58+dnzZo1+e53v5s77rgjd9xxR3b37ne/O/fff39aW1sDsD+79NJL8+KLL+amm27KqlWr8tnPfjavNW3atCxatCjvfOc7w38pgddh+vTp+cUvfpGbbropDz30UNatW5cxY8bkxBNPzMUXX5yTTz45AI1gypQp6ejoyK233poHH3wwL7zwQjo7O3PsscfmuOOOy/nnn59JkyYFYH/1xS9+MXXTp0/P71Or1XL77bfnnHPOyaJFi7JixYp0d3dn/PjxmT17dj7zmc+kra0tAPuqL37xi6mbPn16fp8bbrghf/VXf5Ubb7wxzzzzTF588cW0t7dn6tSpOfnkkzNnzpwMGzYs/H+VwOv0zne+M/Pnz8/8+fMD0Miam5szd+7czJ07NwCN5pprrsnrNWvWrMyaNSsA+5trrrkmr8exxx6bb37zm2HoSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwkoAAAAAoMJKAAAAAKDCSgAAAACgwv4ffv2JjgGRJmIAAAAASUVORK5CYII=\"/>","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Error-Types-and-Quantum-Channels","page":"Noisy Simulation","title":"Error Types and Quantum Channels","text":"Yao provides various types of quantum errors and their corresponding quantum channel representations. Let's explore the different error types available:","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#1.-Bit-Flip-Error","page":"Noisy Simulation","title":"1. Bit Flip Error","text":"A bit flip error with probability p applies X gate with probability p\n\nbit_flip = BitFlipError(0.1)\nbit_flip_channel = quantum_channel(bit_flip)\nprintln(\"Bit Flip Error Channel: \", bit_flip_channel)\n\nBit Flip Error Channel: nqubits: 1\nmixed_unitary_channel\n├─ [0.9] I2\n└─ [0.1] X\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#2.-Phase-Flip-Error","page":"Noisy Simulation","title":"2. Phase Flip Error","text":"A phase flip error with probability p applies Z gate with probability p\n\nphase_flip = PhaseFlipError(0.1)\nphase_flip_channel = quantum_channel(phase_flip)\nprintln(\"Phase Flip Error Channel: \", phase_flip_channel)\n\nPhase Flip Error Channel: nqubits: 1\nmixed_unitary_channel\n├─ [0.9] I2\n└─ [0.1] Z\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#3.-Depolarizing-Error","page":"Noisy Simulation","title":"3. Depolarizing Error","text":"A depolarizing error with probability p applies X, Y, or Z gate with equal probability p/3\n\ndepolarizing = DepolarizingError(1, 0.1)\ndepolarizing_channel = quantum_channel(depolarizing)\nprintln(\"Depolarizing Error Channel: \", depolarizing_channel)\n\nDepolarizing Error Channel: nqubits: 1\nDepolarizingChannel{1}(0.1)\n\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#4.-Pauli-Error","page":"Noisy Simulation","title":"4. Pauli Error","text":"A Pauli error with probabilities px, py, pz for X, Y, Z gates respectively\n\npauli_error = PauliError(0.05, 0.03, 0.02)\npauli_channel = quantum_channel(pauli_error)\nprintln(\"Pauli Error Channel: \", pauli_channel)\n\nPauli Error Channel: nqubits: 1\nmixed_unitary_channel\n├─ [0.8999999999999999] I2\n├─ [0.05] X\n├─ [0.03] Y\n└─ [0.02] Z\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#5.-Reset-Error","page":"Noisy Simulation","title":"5. Reset Error","text":"A reset error that resets qubits to |0⟩ or |1⟩ with given probabilities\n\nreset_error = ResetError(0.1, 0.05)  # p0, p1\nreset_channel = quantum_channel(reset_error)\nprintln(\"Reset Error Channel: \", reset_channel)\n\nReset Error Channel: nqubits: 1\nkraus_channel\n├─ [scale: 0.9219544457292888] I2\n├─ [scale: 0.31622776601683794] P0\n├─ [scale: 0.31622776601683794] Pd\n├─ [scale: 0.22360679774997896] P1\n└─ [scale: 0.22360679774997896] Pu\n\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#6.-Thermal-Relaxation-Error","page":"Noisy Simulation","title":"6. Thermal Relaxation Error","text":"Models decoherence with T1 and T2 times\n\nthermal_relaxation = ThermalRelaxationError(100.0, 200.0, 1.0, 0.0)\nthermal_channel = quantum_channel(thermal_relaxation)\nprintln(\"Thermal Relaxation Error Channel: \", thermal_relaxation)\n\nThermal Relaxation Error Channel: ThermalRelaxationError{Float64}(100.0, 200.0, 1.0, 0.0)\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#7.-Amplitude-Damping-Error","page":"Noisy Simulation","title":"7. Amplitude Damping Error","text":"Models energy loss to environment\n\namplitude_damping = AmplitudeDampingError(0.1)\namplitude_channel = quantum_channel(amplitude_damping)\nprintln(\"Amplitude Damping Error Channel: \", amplitude_damping)\n\nAmplitude Damping Error Channel: AmplitudeDampingError{Float64}(0.1, 0.0)\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#8.-Phase-Damping-Error","page":"Noisy Simulation","title":"8. Phase Damping Error","text":"Models pure dephasing\n\nphase_damping = PhaseDampingError(0.1)\nphase_channel = quantum_channel(phase_damping)\nprintln(\"Phase Damping Error Channel: \", phase_damping)\n\nPhase Damping Error Channel: PhaseDampingError{Float64}(0.1)\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#9.-Phase-Amplitude-Damping-Error","page":"Noisy Simulation","title":"9. Phase-Amplitude Damping Error","text":"Combines both amplitude and phase damping\n\nphase_amplitude_damping = PhaseAmplitudeDampingError(0.1, 0.05, 0.0)\nphase_amplitude_channel = quantum_channel(phase_amplitude_damping)\nprintln(\"Phase-Amplitude Damping Error Channel: \", phase_amplitude_damping)\n\nPhase-Amplitude Damping Error Channel: PhaseAmplitudeDampingError{Float64}(0.1, 0.05, 0.0)\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#10.-Coherent-Error","page":"Noisy Simulation","title":"10. Coherent Error","text":"A deterministic error represented by a quantum gate\n\ncoherent_error = CoherentError(X)\ncoherent_channel = quantum_channel(coherent_error)\nprintln(\"Coherent Error Channel: \", coherent_error)\n\nCoherent Error Channel: CoherentError{XGate}(X)\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Channel-Representations","page":"Noisy Simulation","title":"Channel Representations","text":"Each error type can be converted to different channel representations:","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Kraus-Channel-Representation","page":"Noisy Simulation","title":"Kraus Channel Representation","text":"Represents the channel as a set of Kraus operators\n\nbit_flip_kraus = KrausChannel(bit_flip)\nprintln(\"Bit Flip Kraus Operators:\")\nfor (i, op) in enumerate(bit_flip_kraus.operators)\n    println(\"K$i = \", mat(op))\nend\n\nBit Flip Kraus Operators:\nK1 = Diagonal(ComplexF64[0.9486832980505138 + 0.0im, 0.9486832980505138 + 0.0im])\nK2 = LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}\n(1, 2) = 0.31622776601683794 + 0.0im\n(2, 1) = 0.31622776601683794 + 0.0im\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Mixed-Unitary-Channel-Representation","page":"Noisy Simulation","title":"Mixed Unitary Channel Representation","text":"Represents the channel as a convex combination of unitary operators\n\nbit_flip_mixed = MixedUnitaryChannel(bit_flip)\nprintln(\"Bit Flip Mixed Unitary Channel:\")\nfor (i, (prob, gate)) in enumerate(zip(bit_flip_mixed.probs, bit_flip_mixed.operators))\n    println(\"p$i = $prob, U$i = \", mat(gate))\nend\n\nBit Flip Mixed Unitary Channel:\np1 = 0.9, U1 = ComplexF64[1.0 + 0.0im 0.0 + 0.0im; 0.0 + 0.0im 1.0 + 0.0im]\np2 = 0.1, U2 = LuxurySparse.SDPermMatrix{ComplexF64, Int64, Vector{ComplexF64}, Vector{Int64}}\n(1, 2) = 1.0 + 0.0im\n(2, 1) = 1.0 + 0.0im\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Superoperator-Representation","page":"Noisy Simulation","title":"Superoperator Representation","text":"Represents the channel as a superoperator matrix\n\nbit_flip_superop = SuperOp(bit_flip)\nprintln(\"Bit Flip Superoperator Matrix:\")\nprintln(bit_flip_superop.superop)\n\nBit Flip Superoperator Matrix:\nsparse([1, 4, 2, 3, 2, 3, 1, 4], [1, 1, 2, 2, 3, 3, 4, 4], ComplexF64[0.8999999999999999 + 0.0im, 0.1 + 0.0im, 0.8999999999999999 + 0.0im, 0.1 + 0.0im, 0.1 + 0.0im, 0.8999999999999999 + 0.0im, 0.1 + 0.0im, 0.8999999999999999 + 0.0im], 4, 4)\n","category":"section"},{"location":"generated/examples/9.noisy-simulation/index.html#Example:-Comparing-Different-Error-Types","page":"Noisy Simulation","title":"Example: Comparing Different Error Types","text":"Let's compare how different error types affect a simple circuit:\n\nCreate a simple test circuit\n\ntest_circ = chain(2, put(1=>H), control(2, 1=>X))\n\nnqubits: 2\nchain\n├─ put on (1)\n│  └─ H\n└─ control(2)\n   └─ (1,) X\n\n\nTest different error types\n\nerror_types = [\n    (\"Bit Flip\", BitFlipError(0.1)),\n    (\"Phase Flip\", PhaseFlipError(0.1)),\n    (\"Depolarizing\", DepolarizingError(1, 0.1)),\n    (\"Amplitude Damping\", AmplitudeDampingError(0.1)),\n    (\"Phase Damping\", PhaseDampingError(0.1))\n]\n\nprintln(\"\\nComparing different error types on a 2-qubit circuit:\")\nfor (name, error) in error_types\n    # Add error after each gate\n    noisy_circ = replace_block(test_circ) do block\n        if block isa PutBlock && length(block.locs) == 1\n            chain(block, put(nqubits(block), block.locs => quantum_channel(error)))\n        elseif block isa ControlBlock && length(block.ctrl_locs) == 1 && length(block.locs) == 1\n            chain(block, put(nqubits(block), (block.ctrl_locs..., block.locs...) =>\n                kron(quantum_channel(error), quantum_channel(error))))\n        else\n            block\n        end\n    end\n\n    # Simulate\n    rho = noisy_simulation(zero_state(2), noisy_circ)\n    fid = fidelity(rho, apply(density_matrix(zero_state(2)), test_circ))\n    println(\"$name Error: Fidelity = $(round(fid, digits=3))\")\nend\n\n\nComparing different error types on a 2-qubit circuit:\n┌ Warning: Assignment to `rho` in soft scope is ambiguous because a global variable by the same name exists: `rho` will be treated as a new local. Disambiguate by using `local rho` to suppress this warning or `global rho` to assign to the existing global variable.\n└ @ ~/work/Yao.jl/Yao.jl/docs/src/generated/examples/9.noisy-simulation/index.md:24\nBit Flip Error: Fidelity = 0.949\nPhase Flip Error: Fidelity = 0.906\nDepolarizing Error: Fidelity = 0.927\nAmplitude Damping Error: Fidelity = 0.975\nPhase Damping Error: Fidelity = 0.975\n\n\n\n\nThis page was generated using Literate.jl.","category":"section"},{"location":"man/bitbasis.html#BitBasis","page":"BitBasis","title":"BitBasis","text":"Types and operations for basis represented by bits in linear algebra.\n\nFor more details please ref to BitBasis.jl.","category":"section"},{"location":"man/bitbasis.html#BitBasis.@bit_str-Tuple{Any}","page":"BitBasis","title":"BitBasis.@bit_str","text":"@bit_str -> BitStr64\n\nConstruct a bit string. such as bit\"0000\". The bit strings also supports string join. Just use it like normal strings.\n\nExample\n\njulia> bit\"10001\"\n10001 ₍₂₎\n\njulia> bit\"100_111_101\"\n100111101 ₍₂₎\n\njulia> join(bit\"1001\", bit\"11\", bit\"1110\")\n1001111110 ₍₂₎\n\njulia> onehot(bit\"1001\")\n16-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 1.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n\n","category":"macro"},{"location":"man/bitbasis.html#BitBasis.@dit_str-Tuple{Any}","page":"BitBasis","title":"BitBasis.@dit_str","text":"@dit_str -> DitStr64\n\nConstruct a dit string. such as dit\"0201;3\". The dit strings also supports string join. Just use it like normal strings.\n\nExample\n\njulia> dit\"10201;3\"\n10201 ₍₃₎\n\njulia> dit\"100_121_121;3\"\n100121121 ₍₃₎\n\njulia> join(dit\"1021;3\", dit\"11;3\", dit\"1210;3\")\n1021111210 ₍₃₎\n\njulia> onehot(dit\"1021;3\")\n81-element Vector{ComplexF64}:\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n     ⋮\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n 0.0 + 0.0im\n\n\n\n\n\n\n","category":"macro"},{"location":"man/bitbasis.html#BitBasis.@lbit_str-Tuple{Any}","page":"BitBasis","title":"BitBasis.@lbit_str","text":"@lbit_str -> LongBitStr\n\nLong bit string version of @bit_str macro.\n\n\n\n\n\n","category":"macro"},{"location":"man/bitbasis.html#BitBasis.@ldit_str-Tuple{Any}","page":"BitBasis","title":"BitBasis.@ldit_str","text":"@ldit_str -> LongDitStr\n\nLong dit string version of @dit_str macro.\n\n\n\n\n\n","category":"macro"},{"location":"man/bitbasis.html#Base.:==-Union{Tuple{N2}, Tuple{N1}, Tuple{D}, Tuple{BitBasis.SubDitStr{D, N1}, DitStr{D, N2}}} where {D, N1, N2}","page":"BitBasis","title":"Base.:==","text":"==(lhs::SubDitStr{D,N,T}, rhs::DitStr{D,N,T}) -> Bool\n==(lhs::DitStr{D,N,T}, rhs::SubDitStr{D,N,T}) -> Bool\n==(lhs::SubDitStr{D,N,T}, rhs::SubDitStr{D,N,T}) -> Bool\n\nCompare the equality between SubDitStr and DitStr. \n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.allone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"BitBasis","title":"BitBasis.allone","text":"allone(index::Integer, mask::Integer) -> Bool\n\nReturn true if all masked position of index is 1.\n\nExample\n\ntrue if all masked positions are 1.\n\njulia> allone(0b1011, 0b1011)\ntrue\n\njulia> allone(0b1011, 0b1001)\ntrue\n\njulia> allone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.anyone-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"BitBasis","title":"BitBasis.anyone","text":"anyone(index::Integer, mask::Integer) -> Bool\n\nReturn true if any masked position of index is 1.\n\nExample\n\ntrue if any masked positions is 1.\n\njulia> anyone(0b1011, 0b1001)\ntrue\n\njulia> anyone(0b1011, 0b1100)\ntrue\n\njulia> anyone(0b1011, 0b0100)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.baddrs-Tuple{Integer}","page":"BitBasis","title":"BitBasis.baddrs","text":"baddrs(b::Integer) -> Vector\n\nget the locations of nonzeros bits, i.e. the inverse operation of bmask.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.basis-Tuple{DitStr}","page":"BitBasis","title":"BitBasis.basis","text":"basis(ditstr) -> UnitRange{DitStr{D,N,T}}\nbasis(DitStr{D,N,T}) -> UnitRange{DitStr{D,N,T}}\n\nReturns the UnitRange for basis in Hilbert Space of qudits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bdistance-Union{Tuple{Ti}, Tuple{Ti, Ti}} where Ti<:Integer","page":"BitBasis","title":"BitBasis.bdistance","text":"bdistance(i::Integer, j::Integer) -> Int\n\nReturn number of different bits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bfloat-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bfloat","text":"bfloat(b::Integer; nbits::Int=bit_length(b)) -> Float64\n\nfloat view, with current bit numbering. See also bfloat_r.\n\nRef: wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bfloat-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"BitBasis","title":"BitBasis.bfloat","text":"bfloat(b::BitStr) -> Float64\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bfloat_r-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bfloat_r","text":"bfloat_r(b::Integer; nbits::Int=bit_length(b)) -> Float64\n\nfloat view, with reversed bit numbering. See also bfloat.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bfloat_r-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"BitBasis","title":"BitBasis.bfloat_r","text":"bfloat_r(b::BitStr) -> Float64\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bint-Tuple{BitStr}","page":"BitBasis","title":"BitBasis.bint","text":"bint(b::BitStr) -> Integer\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bint-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bint","text":"bint(b; nbits=nothing) -> Int\n\ninteger view, with LSB 0 bit numbering. See also wiki: bit numbering\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bint_r-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bint_r","text":"bint_r(b; nbits::Int) -> Integer\n\ninteger read in inverse order.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bint_r-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"BitBasis","title":"BitBasis.bint_r","text":"bint_r(b::BitStr) -> Integer\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bit_length-Tuple{Integer}","page":"BitBasis","title":"BitBasis.bit_length","text":"bit_length(x::Integer) -> Int\n\nReturn the number of bits required to represent input integer x.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bitarray-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T<:Number","page":"BitBasis","title":"BitBasis.bitarray","text":"bitarray(v::Vector, [nbits::Int]) -> BitArray\nbitarray(v::Int, nbits::Int) -> BitArray\nbitarray(nbits::Int) -> Function\n\nConstruct BitArray from an integer vector, if nbits not supplied, it is 64. If an integer is supplied, it returns a function mapping a Vector/Int to bitarray.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bmask","page":"BitBasis","title":"BitBasis.bmask","text":"bmask(::Type{T}) where T <: Integer -> zero(T)\nbmask([T::Type], positions::Int...) -> T\nbmask([T::Type], range::UnitRange{Int}) -> T\n\nReturn an integer mask of type T where 1 is the position masked according to positions or range. Directly use T will return an empty mask 0.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis.html#BitBasis.breflect","page":"BitBasis","title":"BitBasis.breflect","text":"breflect(b::Integer[, masks::Vector{Integer}]; nbits) -> Integer\n\nReturn left-right reflected integer.\n\nExample\n\nReflect the order of bits.\n\njulia> breflect(0b1011; nbits=4) == 0b1101\ntrue\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis.html#BitBasis.breflect-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"BitBasis","title":"BitBasis.breflect","text":"breflect(bit_str[, masks])\n\nReturn left-right reflected bit string.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.bsizeof-Union{Tuple{Type{T}}, Tuple{T}} where T","page":"BitBasis","title":"BitBasis.bsizeof","text":"bsizeof(::Type)\n\nReturns the size of given type in number of binary digits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.btruncate-Union{Tuple{T}, Tuple{T, Any}} where T<:Integer","page":"BitBasis","title":"BitBasis.btruncate","text":"btruncate(b, n)\n\nTruncate bits b to given length n.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.controldo-Union{Tuple{S}, Tuple{Union{Function, Type}, BitBasis.IterControl{S}}} where S","page":"BitBasis","title":"BitBasis.controldo","text":"controldo(f, itr::IterControl)\n\nExecute f while iterating itr.\n\nnote: Note\nthis is faster but equivalent than using itr as an iterator. See also itercontrol.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.controller-Tuple{Union{UnitRange{T}, NTuple{var\"#s28\", T} where var\"#s28\", Vector{T}, T} where T<:Integer, Union{UnitRange{T}, NTuple{var\"#s28\", T} where var\"#s28\", Vector{T}, T} where T<:Integer}","page":"BitBasis","title":"BitBasis.controller","text":"controller([T=Int, ]cbits, cvals) -> Function\n\nReturn a function that checks whether a basis at cbits takes specific value cvals.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.flip-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"BitBasis","title":"BitBasis.flip","text":"flip(index::Integer, mask::Integer) -> Integer\n\nReturn an Integer with bits at masked position flipped.\n\nExample\n\njulia> flip(0b1011, 0b1011) |> BitStr{4}\n0000 ₍₂₎\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.group_shift!-Tuple{Int64, AbstractVector{Int64}}","page":"BitBasis","title":"BitBasis.group_shift!","text":"group_shift!(nbits, positions)\n\nShift bits on positions together.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.hypercubic-Tuple{Array}","page":"BitBasis","title":"BitBasis.hypercubic","text":"hypercubic(A::Array) -> Array\n\nget the hypercubic representation for an array.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.indicator-Union{Tuple{T}, Tuple{Type{T}, Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.indicator","text":"indicator(::Type{T}, k) -> T\n\nReturn an integer with k-th bit set to 1.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.indices_with-Tuple{Int64, Vector{Int64}, Vector{Int64}}","page":"BitBasis","title":"BitBasis.indices_with","text":"indices_with(n::Int, locs::Vector{Int}, vals::Vector{Int}) -> Vector{Int}\n\nReturn indices with specific positions locs with value vals in a hilbert space of n qubits.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.invorder-Tuple{AbstractVecOrMat}","page":"BitBasis","title":"BitBasis.invorder","text":"invorder(X::AbstractVecOrMat)\n\nInverse the order of given vector/matrix X.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.ismatch-Union{Tuple{T}, Tuple{T, T, T}} where T<:Integer","page":"BitBasis","title":"BitBasis.ismatch","text":"ismatch(index::Integer, mask::Integer, target::Integer) -> Bool\n\nReturn true if bits at positions masked by mask equal to 1 are equal to target.\n\nExample\n\njulia> n = 0b11001; mask = 0b10100; target = 0b10000;\n\njulia> ismatch(n, mask, target)\ntrue\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.itercontrol-Tuple{Int64, AbstractVector, Any}","page":"BitBasis","title":"BitBasis.itercontrol","text":"itercontrol([T=Int], nbits, positions, bit_configs)\n\nReturns an iterator which iterate through controlled subspace of bits.\n\nExample\n\nTo iterate through all the bits satisfy 0xx10x1 where x means an arbitrary bit.\n\njulia> for each in itercontrol(7, [1, 3, 4, 7], (1, 0, 1, 0))\n           println(string(each, base=2, pad=7))\n       end\n0001001\n0001011\n0011001\n0011011\n0101001\n0101011\n0111001\n0111011\n\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.log2dim1-Tuple{Any}","page":"BitBasis","title":"BitBasis.log2dim1","text":"log2dim1(X)\n\nReturns the log2 of the first dimension's size.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.log2i","page":"BitBasis","title":"BitBasis.log2i","text":"log2i(x::Integer) -> Integer\n\nReturn log2(x), this integer version of log2 is fast but only valid for number equal to 2^n.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis.html#BitBasis.neg-Union{Tuple{BitStr{N}}, Tuple{N}} where N","page":"BitBasis","title":"BitBasis.neg","text":"neg(b::BitStr) -> BitStr\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.neg-Union{Tuple{T}, Tuple{T, Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.neg","text":"neg(index::Integer, nbits::Int) -> Integer\n\nReturn an integer with all bits flipped (with total number of bit nbits).\n\nExample\n\njulia> neg(0b1111, 4) |> BitStr{4}\n0000 ₍₂₎\n\njulia> neg(0b0111, 4) |> BitStr{4}\n1000 ₍₂₎\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.next_reordered_basis-Union{Tuple{T}, Tuple{N}, Tuple{T, NTuple{N, T}, NTuple{N, T}}} where {N, T}","page":"BitBasis","title":"BitBasis.next_reordered_basis","text":"next_reordered_basis(basis, takers, differ)\n\nReturns the next reordered basis accroding to current basis.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.onehot-Union{Tuple{T1}, Tuple{N}, Tuple{T}, Tuple{D}, Tuple{Type{T}, DitStr{D, N, T1}}} where {D, T, N, T1}","page":"BitBasis","title":"BitBasis.onehot","text":"onehot([T=Float64], dit_str[; nbatch])\n\nCreate an onehot vector in type Vector{T} or a batch of onehot vector in type Matrix{T}, where index x + 1 is one. One can specify the value of the nonzero entry by inputing a pair.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.packbits-Tuple{AbstractVector}","page":"BitBasis","title":"BitBasis.packbits","text":"packbits(arr::AbstractArray) -> AbstractArray\n\npack bits to integers, usually take a BitArray as input.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.readat-Union{Tuple{T}, Tuple{N}, Tuple{D}, Tuple{DitStr{D, N, T}, Vararg{Integer}}} where {D, N, T}","page":"BitBasis","title":"BitBasis.readat","text":"readat(x, loc...) -> Integer\n\nRead the dit config at given location.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.readbit-Union{Tuple{T}, Tuple{T, Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.readbit","text":"readbit(x, loc...)\n\nRead the bit config at given location.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.reorder","page":"BitBasis","title":"BitBasis.reorder","text":"reorder(X::AbstractArray, orders)\n\nReorder X according to orders.\n\ntip: Tip\nAlthough orders can be any iterable, Tuple is preferred inorder to gain as much performance as possible. But the conversion won't take much anyway.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis.html#BitBasis.setbit-Union{Tuple{T}, Tuple{T, T}} where T<:Integer","page":"BitBasis","title":"BitBasis.setbit","text":"setbit(index::Integer, mask::Integer) -> Integer\n\nset the bit at masked position to 1.\n\nExample\n\njulia> setbit(0b1011, 0b1100) |> BitStr{4}\n1111 ₍₂₎\n\njulia> setbit(0b1011, 0b0100) |> BitStr{4}\n1111 ₍₂₎\n\njulia> setbit(0b1011, 0b0000) |> BitStr{4}\n1011 ₍₂₎\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.swapbits-Union{Tuple{T}, Tuple{T, Int64, Int64}} where T<:Integer","page":"BitBasis","title":"BitBasis.swapbits","text":"swapbits(n::Integer, mask_ij::Integer) -> Integer\nswapbits(n::Integer, i::Int, j::Int) -> Integer\n\nReturn an integer with bits at i and j flipped.\n\nExample\n\njulia> swapbits(0b1011, 0b1100) == 0b0111\ntrue\n\ntip: Tip\nlocations i and j specified by mask could be faster when bmask is not straight forward but known by constant.\n\nwarning: Warning\nmask_ij should only contain two 1, swapbits will not check it, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.unsafe_reorder","page":"BitBasis","title":"BitBasis.unsafe_reorder","text":"unsafe_reorder(X::AbstractArray, orders)\n\nReorder X according to orders.\n\nwarning: Warning\nunsafe_reorder won't check whether the length of orders and the size of first dimension of X match, use at your own risk.\n\n\n\n\n\n","category":"function"},{"location":"man/bitbasis.html#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{N}, Tuple{UnitRange{T}, NTuple{N, T}}} where {N, T}","page":"BitBasis","title":"BitBasis.unsafe_sub","text":"unsafe_sub(a::UnitRange, b::NTuple{N}) -> NTuple{N}\n\nReturns result in type Tuple of a .- b. This will not check the length of a and b, use at your own risk.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{UnitRange{T}, Vector{T}}} where T","page":"BitBasis","title":"BitBasis.unsafe_sub","text":"unsafe_sub(a::UnitRange{T}, b::Vector{T}) where T\n\nReturns a .- b, fallback version when b is a Vector.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.BitStr","page":"BitBasis","title":"BitBasis.BitStr","text":"BitStr{N,T} <: Integer\n\nThe struct for bit string with fixed length N and storage type T. It is an alias of DitStr{2,N,T}.\n\nBitStr{N,T}(integer)\nBitStr64{N}(integer)\nBitStr64(vector)\nLongBitStr{N}(integer)\nLongBitStr(vector)\n\nReturns a BitStr. When the input is an integer, the bits are read from right to left. When the input is a vector, the bits are read from left to right.\n\nExamples\n\nBitStr supports some basic arithmetic operations. It acts like an integer, but supports some frequently used methods for binary basis.\n\njulia> bit\"0101\" * 2\n1010 ₍₂₎\n\njulia> join([bit\"101\" for i in 1:10])\n\"101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎101 ₍₂₎\"\n\njulia> repeat(bit\"101\", 2)\n101101 ₍₂₎\n\njulia> bit\"1101\"[2]\n0\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis.html#BitBasis.DitStr","page":"BitBasis","title":"BitBasis.DitStr","text":"DitStr{D,N,T<:Integer} <: Integer\n\nThe struct for dit string with fixed length N and storage type T, where dit is a extension of dit from binary system to a d-ary system.\n\nDitStr{D,N,T}(integer)\nDitStr{D,N}(integer)\nDitStr{D}(vector)\n\nReturns a DitStr. When the input is an integer, the dits are read from right to left. When the input is a vector, the dits are read from left to right.\n\nExamples\n\njulia> DitStr{3}([1,2,1,1,0])\n01121 ₍₃₎\n\njulia> DitStr{3, 5}(71)\n02122 ₍₃₎\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis.html#BitBasis.DitStr-Union{Tuple{BitBasis.SubDitStr{D, N, T}}, Tuple{T}, Tuple{N}, Tuple{D}} where {D, N, T}","page":"BitBasis","title":"BitBasis.DitStr","text":"DitStr(dit::SubDitStr{D,N,T}) -> DitStr{D,N,T}\n\nRaise type SubDitStr to DitStr.\n\njulia> x = DitStr{3, 5}(71)\n02122 ₍₃₎\n\njulia> sx =  SubDitStr(x, 2, 4)\nSubDitStr{3, 5, Int64}(02122 ₍₃₎, 1, 3)\n\njulia> DitStr(sx)\n212 ₍₃₎\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.IterControl","page":"BitBasis","title":"BitBasis.IterControl","text":"IterControl{S}\nIterControl(n::Int, base::Int, masks, factors) -> IterControl\n\nIterator to iterate through controlled subspace. See also itercontrol.  S is the number of chunks,  n is the size of Hilbert space,  base is the base of counter,  masks and factors are helpers for enumerating over the target Hilbert Space.\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis.html#BitBasis.LongLongUInt","page":"BitBasis","title":"BitBasis.LongLongUInt","text":"LongLongUInt{C} <: Integer\n\nA LongLongUInt{C} is an integer with C UInt numbers to store the value.\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis.html#BitBasis.ReorderedBasis","page":"BitBasis","title":"BitBasis.ReorderedBasis","text":"ReorderedBasis{N, T}\n\nLazy reorderd basis.\n\n\n\n\n\n","category":"type"},{"location":"man/bitbasis.html#BitBasis.ReorderedBasis-Union{Tuple{Tuple{T, Vararg{T, N}}}, Tuple{T}, Tuple{N}} where {N, T<:Integer}","page":"BitBasis","title":"BitBasis.ReorderedBasis","text":"ReorderedBasis(orders::NTuple{N, <:Integer})\n\nReturns a lazy set of reordered basis.\n\n\n\n\n\n","category":"method"},{"location":"man/bitbasis.html#BitBasis.SubDitStr","page":"BitBasis","title":"BitBasis.SubDitStr","text":"SubDitStr{D,N,T<:Integer} <: Integer\n\nThe struct as a SubString-like object for DitStr(SubString is an official implementation of sliced strings, see String for reference). This slicing returns a view into the parent DitStr instead of making a copy (similar to the @views macro for strings).\n\nSubDitStr can be used to describe the qubit configuration within the subspace of the entire Hilbert space.It provides similar getindex, length functions as DitStr. \n\nSubDitStr(dit::DitStr{D,N,T}, i::Int, j::Int)\nSubDitStr(dit::DitStr{D,N,T}, r::AbstractUnitRange{<:Integer})\n\nOr by @views macro for DitStr (this macro makes your life easier by supporting begin and end syntax):\n\n@views dit[i:j]\n\nReturns a SubDitStr.\n\nExamples\n\njulia> x = DitStr{3, 5}(71)\n02122 ₍₃₎\n\njulia> sx =  SubDitStr(x, 2, 4) \nSubDitStr{3, 5, Int64}(02122 ₍₃₎, 1, 3)\n\njulia> @views x[2:end] \nSubDitStr{3, 5, Int64}(02122 ₍₃₎, 1, 4)\n\njulia> sx == dit\"212;3\"\ntrue\n\n\n\n\n\n","category":"type"},{"location":"index.html#Yao","page":"Home","title":"Yao","text":"A General Purpose Quantum Computation Simulation Framework\n\nWelcome to Yao, a Flexible, Extensible, Efficient Framework for Quantum Algorithm Design. Yao (幺) is the Chinese character for normalized but not orthogonal.\n\nWe aim to provide a powerful tool for researchers, students to study and explore quantum computing in near term future, before quantum computer being used in large-scale.","category":"section"},{"location":"index.html#Quick-Starts","page":"Home","title":"Quick Starts","text":"You can learn how to use Yao with some quick examples in this section. There are three badges on the top of each tutorial that allows you to open it in mybinder, preview it in nbviewer or download the tutorial as .zip file, which includes the notebook and the scripts and other related materials.","category":"section"},{"location":"index.html#Contribution","page":"Home","title":"Contribution","text":"If you are interesting in polishing or contributing our tutorial, you can just open a PR in our tutorial repo.","category":"section"},{"location":"index.html#Syntax","page":"Home","title":"Syntax","text":"The tutorials are written with Literate.","category":"section"},{"location":"index.html#Pluto-Notebooks","page":"Home","title":"Pluto Notebooks","text":"There is also a set of Pluto notebooks available in the notebooks folder","category":"section"},{"location":"index.html#Manual","page":"Home","title":"Manual","text":"Pages = [\n    \"man/array_registers.md\",\n    \"man/blocks.md\",\n    \"man/registers.md\",\n    \"man/extending_blocks.md\",\n]\nDepth = 1","category":"section"},{"location":"man/simplification.html#Simplification","page":"Simplification","title":"Simplification","text":"The simplification for YaoBlocks is currently implemented in a limited and straightforward fashion, there is only one interface simplify to call.","category":"section"},{"location":"man/simplification.html#APIs","page":"Simplification","title":"APIs","text":"","category":"section"},{"location":"man/simplification.html#YaoBlocks.Optimise.is_pauli-Tuple","page":"Simplification","title":"YaoBlocks.Optimise.is_pauli","text":"is_pauli(x)\n\nCheck if x is an element of pauli group.\n\n\n\n\n\n","category":"method"},{"location":"man/simplification.html#YaoBlocks.Optimise.replace_block-Tuple{Any, AbstractBlock}","page":"Simplification","title":"YaoBlocks.Optimise.replace_block","text":"replace_block(actor, tree::AbstractBlock) -> AbstractBlock\nreplace_block(pair::Pair{Type{ST}, TT}, tree::AbstractBlock) -> AbstractBlock\n\nreplace blocks in a circuit, where actor is a function that given input block, returns the block to replace, or nothing for skip replacing and visit sibling. If pair is provided, then replace original block with type ST with new block (pair.second).\n\n\n\n\n\n","category":"method"},{"location":"man/simplification.html#YaoBlocks.Optimise.simplify-Tuple{AbstractBlock}","page":"Simplification","title":"YaoBlocks.Optimise.simplify","text":"simplify(block[; rules=__default_simplification_rules__])\n\nSimplify a block tree accroding to given rules, default to use YaoBlocks.Optimise.__default_simplification_rules__.\n\n\n\n\n\n","category":"method"},{"location":"man/simplification.html#YaoBlocks.Optimise.to_basictypes","page":"Simplification","title":"YaoBlocks.Optimise.to_basictypes","text":"to_basictypes(block::AbstractBlock)\n\nconvert gates to basic types\n\n* ChainBlock\n* PutBlock\n* PrimitiveBlock\n\n\n\n\n\n","category":"function"}]
}

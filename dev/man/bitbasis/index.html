<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>BitBasis · Yao.jl</title><link rel="canonical" href="https://quantumbfs.github.io/Yao.jl/latest/man/bitbasis/index.html"/><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/></head><body><nav class="toc"><a href="../../index.html"><img class="logo" src="../../assets/logo.svg" alt="Yao.jl logo"/></a><h1>Yao.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Examples</span><ul><li><a class="toctext" href="../../examples/GHZ/">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="toctext" href="../../examples/QFT/">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="toctext" href="../../examples/QCBM/">Quantum Circuit Born Machine</a></li></ul></li><li><span class="toctext">Manual</span><ul><li><a class="toctext" href="../array_registers/">Array Registers</a></li><li><a class="toctext" href="../blocks/">Blocks</a></li><li><a class="toctext" href="../base/">Base</a></li><li><a class="toctext" href="../registers/">Abstract Registers</a></li><li class="current"><a class="toctext" href>BitBasis</a><ul class="internal"></ul></li><li><a class="toctext" href="../extending_blocks/">Extending Blocks</a></li><li><a class="toctext" href="../benchmarks/">Benchmarks</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Manual</li><li><a href>BitBasis</a></li></ul><a class="edit-page" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/bitbasis.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>BitBasis</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="BitBasis-1" href="#BitBasis-1">BitBasis</a></h1><p>Types and operations for basis represented by bits in linear algebra.</p><p>For more details please ref to <a href="https://quantumbfs.github.io/BitBasis.jl/stable/">BitBasis.jl</a>.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.@bit_str-Tuple{Any}" href="#BitBasis.@bit_str-Tuple{Any}"><code>BitBasis.@bit_str</code></a> — <span class="docstring-category">Macro</span>.</div><div><div><pre><code class="language-julia">@bit_str -&gt; BitStr</code></pre><p>Construct a bit string. such as <code>bit&quot;0000&quot;</code>. The bit strings also supports string <code>bcat</code>. Just use it like normal strings.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; bit&quot;10001&quot;
10001 (17)

julia&gt; bit&quot;100_111_101&quot;
100111101 (317)

julia&gt; bcat(bit&quot;1001&quot;, bit&quot;11&quot;, bit&quot;1110&quot;)
1001111110 (638)

julia&gt; v = collect(1:16);

julia&gt; v[bit&quot;1001&quot;]
10

julia&gt; onehot(bit&quot;1001&quot;)
16-element Array{Float64,1}:
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0
 0.0
 0.0
 0.0
 0.0
</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.allone-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T" href="#BitBasis.allone-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T"><code>BitBasis.allone</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allone(b::BitStr, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if all masked position of index is 1.</p><p><strong>Example</strong></p><p><code>true</code> if all masked positions are 1.</p><pre><code class="language-julia-repl">julia&gt; allone(bit&quot;1011&quot;, 0b1011)
true

julia&gt; allone(bit&quot;1011&quot;, 0b1001)
true

julia&gt; allone(bit&quot;1011&quot;, 0b0100)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.allone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#BitBasis.allone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>BitBasis.allone</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">allone(index::Integer, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if all masked position of index is 1.</p><p><strong>Example</strong></p><p><code>true</code> if all masked positions are 1.</p><pre><code class="language-julia-repl">julia&gt; allone(0b1011, 0b1011)
true

julia&gt; allone(0b1011, 0b1001)
true

julia&gt; allone(0b1011, 0b0100)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.anyone-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T" href="#BitBasis.anyone-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T"><code>BitBasis.anyone</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">anyone(b::BitStr, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if any masked position of index is 1.</p><p><strong>Example</strong></p><p><code>true</code> if any masked positions is 1.</p><pre><code class="language-julia-repl">julia&gt; anyone(bit&quot;1011&quot;, 0b1001)
true

julia&gt; anyone(bit&quot;1011&quot;, 0b1100)
true

julia&gt; anyone(bit&quot;1011&quot;, 0b0100)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.anyone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#BitBasis.anyone-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>BitBasis.anyone</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">anyone(index::Integer, mask::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if any masked position of index is 1.</p><p><strong>Example</strong></p><p><code>true</code> if any masked positions is 1.</p><pre><code class="language-julia-repl">julia&gt; anyone(0b1011, 0b1001)
true

julia&gt; anyone(0b1011, 0b1100)
true

julia&gt; anyone(0b1011, 0b0100)
false</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.baddrs-Tuple{BitStr}" href="#BitBasis.baddrs-Tuple{BitStr}"><code>BitBasis.baddrs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">baddrs(b::Integer) -&gt; Vector</code></pre><p>get the locations of nonzeros bits, i.e. the inverse operation of bmask.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.baddrs-Tuple{Integer}" href="#BitBasis.baddrs-Tuple{Integer}"><code>BitBasis.baddrs</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">baddrs(b::Integer) -&gt; Vector</code></pre><p>get the locations of nonzeros bits, i.e. the inverse operation of bmask.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.basis-Tuple{Union{Int64, AbstractArray}}" href="#BitBasis.basis-Tuple{Union{Int64, AbstractArray}}"><code>BitBasis.basis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">basis([IntType], nbits::Int) -&gt; UnitRange{IntType}
basis([IntType], state::AbstractArray) -&gt; UnitRange{IntType}</code></pre><p>Returns the UnitRange for basis in Hilbert Space of nbits qubits. If an array is supplied, it will return a basis having the same size with the first diemension of array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bdistance-Union{Tuple{Ti}, Tuple{Ti,Ti}} where Ti&lt;:Integer" href="#BitBasis.bdistance-Union{Tuple{Ti}, Tuple{Ti,Ti}} where Ti&lt;:Integer"><code>BitBasis.bdistance</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bdistance(i::Integer, j::Integer) -&gt; Int</code></pre><p>Return number of different bits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bfloat-Tuple{BitStr}" href="#BitBasis.bfloat-Tuple{BitStr}"><code>BitBasis.bfloat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bfloat(b::BitStr) -&gt; Float64</code></pre><p>float view, with MSB 0 bit numbering. See also <a href="https://en.wikipedia.org/wiki/Bit_numbering">wiki: bit numbering</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bfloat-Tuple{Integer}" href="#BitBasis.bfloat-Tuple{Integer}"><code>BitBasis.bfloat</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bfloat(b::Integer; nbits::Int=bit_length(b)) -&gt; Float64</code></pre><p>float view, with current bit numbering. See also <a href="#BitBasis.bfloat_r-Tuple{BitStr}"><code>bfloat_r</code></a>.</p><p>Ref: <a href="https://en.wikipedia.org/wiki/Bit_numbering">wiki: bit numbering</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bfloat_r-Tuple{BitStr}" href="#BitBasis.bfloat_r-Tuple{BitStr}"><code>BitBasis.bfloat_r</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bfloat_r(b::Integer; nbits::Int) -&gt; Float64</code></pre><p>float view, with bits read in inverse order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bfloat_r-Tuple{Integer}" href="#BitBasis.bfloat_r-Tuple{Integer}"><code>BitBasis.bfloat_r</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bfloat_r(b::Integer; nbits::Int=bit_length(b)) -&gt; Float64</code></pre><p>float view, with reversed bit numbering. See also <a href="#BitBasis.bfloat-Tuple{BitStr}"><code>bfloat</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bint-Tuple{BitStr}" href="#BitBasis.bint-Tuple{BitStr}"><code>BitBasis.bint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bint(b; nbits=nothing) -&gt; Int</code></pre><p>integer view, with LSB 0 bit numbering. See also <a href="https://en.wikipedia.org/wiki/Bit_numbering">wiki: bit numbering</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bint-Tuple{Integer}" href="#BitBasis.bint-Tuple{Integer}"><code>BitBasis.bint</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bint(b; nbits=nothing) -&gt; Int</code></pre><p>integer view, with LSB 0 bit numbering. See also <a href="https://en.wikipedia.org/wiki/Bit_numbering">wiki: bit numbering</a></p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bint_r-Tuple{BitStr}" href="#BitBasis.bint_r-Tuple{BitStr}"><code>BitBasis.bint_r</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bint_r(b; nbits::Int) -&gt; Integer</code></pre><p>integer read in inverse order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bint_r-Tuple{Integer}" href="#BitBasis.bint_r-Tuple{Integer}"><code>BitBasis.bint_r</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bint_r(b; nbits::Int) -&gt; Integer</code></pre><p>integer read in inverse order.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bit-Tuple{Integer}" href="#BitBasis.bit-Tuple{Integer}"><code>BitBasis.bit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bit(x[; len=ndigits(x, base=2)])</code></pre><p>Create a <a href="#BitBasis.BitStr"><code>BitStr</code></a> accroding to integer <code>x</code> to given length <code>len</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bit-Tuple{String}" href="#BitBasis.bit-Tuple{String}"><code>BitBasis.bit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bit(string)</code></pre><p>Create a <a href="#BitBasis.BitStr"><code>BitStr</code></a> with given string of bits. See also <a href="#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bit-Tuple{}" href="#BitBasis.bit-Tuple{}"><code>BitBasis.bit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bit(;len)</code></pre><p>Lazy curried version of <a href="#BitBasis.bit-Tuple{Integer}"><code>bit</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bit_length-Tuple{Integer}" href="#BitBasis.bit_length-Tuple{Integer}"><code>BitBasis.bit_length</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bit_length(x::Integer) -&gt; Int</code></pre><p>Return the number of bits required to represent input integer x.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bit_literal-Tuple" href="#BitBasis.bit_literal-Tuple"><code>BitBasis.bit_literal</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bit_literal(xs...)</code></pre><p>Create a <a href="#BitBasis.BitStr"><code>BitStr</code></a> by input bits <code>xs</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; bit_literal(1, 0, 1, 0, 1, 1)
110101 (53)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bitarray-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T&lt;:Number" href="#BitBasis.bitarray-Union{Tuple{T}, Tuple{Array{T,1},Int64}} where T&lt;:Number"><code>BitBasis.bitarray</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bitarray(v::Vector, [nbits::Int]) -&gt; BitArray
bitarray(v::Int, nbits::Int) -&gt; BitArray
bitarray(nbits::Int) -&gt; Function</code></pre><p>Construct BitArray from an integer vector, if nbits not supplied, it is 64. If an integer is supplied, it returns a function mapping a Vector/Int to bitarray.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bmask" href="#BitBasis.bmask"><code>BitBasis.bmask</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bmask(::Type{T}) where T &lt;: Integer -&gt; zero(T)
bmask([T::Type], positions::Int...) -&gt; T
bmask([T::Type], range::UnitRange{Int}) -&gt; T</code></pre><p>Return an integer mask of type <code>T</code> where <code>1</code> is the position masked according to <code>positions</code> or <code>range</code>. Directly use <code>T</code> will return an empty mask <code>0</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.breflect" href="#BitBasis.breflect"><code>BitBasis.breflect</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">breflect(b::Integer[, masks::Vector{Integer}]; nbits) -&gt; Integer</code></pre><p>Return left-right reflected integer.</p><p><strong>Example</strong></p><p>Reflect the order of bits.</p><pre><code class="language-julia-repl">julia&gt; breflect(0b1011; nbits=4) == 0b1101
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.breflect-Tuple{BitStr}" href="#BitBasis.breflect-Tuple{BitStr}"><code>BitBasis.breflect</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">breflect(bit_str[, masks])</code></pre><p>Return left-right reflected bit string.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.bsizeof-Union{Tuple{Type{T}}, Tuple{T}} where T" href="#BitBasis.bsizeof-Union{Tuple{Type{T}}, Tuple{T}} where T"><code>BitBasis.bsizeof</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">bsizeof(::Type)</code></pre><p>Returns the size of given type in number of binary digits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.btruncate-Tuple{Integer,Any}" href="#BitBasis.btruncate-Tuple{Integer,Any}"><code>BitBasis.btruncate</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">truncate(b, n)</code></pre><p>Truncate bits <code>b</code> to given length <code>n</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.controldo-Union{Tuple{S}, Tuple{Union{Function, Type},IterControl{S}}} where S" href="#BitBasis.controldo-Union{Tuple{S}, Tuple{Union{Function, Type},IterControl{S}}} where S"><code>BitBasis.controldo</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">controldo(f, itr::IterControl)</code></pre><p>Execute <code>f</code> while iterating <code>itr</code>.</p><div class="admonition note"><div class="admonition-title">Note</div><div class="admonition-text"><p>this is faster but equivalent than using <code>itr</code> as an iterator. See also <a href="man/@ref"><code>itercontrol</code></a>.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.controller-Tuple{Union{UnitRange{Int64}, Int64, Array{Int64,1}, Tuple{Vararg{Int64,#s14}} where #s14},Union{UnitRange{Int64}, Int64, Array{Int64,1}, Tuple{Vararg{Int64,#s14}} where #s14}}" href="#BitBasis.controller-Tuple{Union{UnitRange{Int64}, Int64, Array{Int64,1}, Tuple{Vararg{Int64,#s14}} where #s14},Union{UnitRange{Int64}, Int64, Array{Int64,1}, Tuple{Vararg{Int64,#s14}} where #s14}}"><code>BitBasis.controller</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">controller(cbits, cvals) -&gt; Function</code></pre><p>Return a function that checks whether a basis at <code>cbits</code> takes specific value <code>cvals</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.flip-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T" href="#BitBasis.flip-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T"><code>BitBasis.flip</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">flip(bit_str, mask::Integer) -&gt; Integer</code></pre><p>Return an <a href="#BitBasis.BitStr"><code>BitStr</code></a> with bits at masked position flipped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; flip(bit&quot;1011&quot;, 0b1011)
0000 (0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.flip-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#BitBasis.flip-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>BitBasis.flip</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">flip(index::Integer, mask::Integer) -&gt; Integer</code></pre><p>Return an Integer with bits at masked position flipped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; flip(0b1011, 0b1011) |&gt; bit(len=4)
0000 (0)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.group_shift!-Tuple{Int64,AbstractArray{Int64,1}}" href="#BitBasis.group_shift!-Tuple{Int64,AbstractArray{Int64,1}}"><code>BitBasis.group_shift!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">group_shift!(nbits, positions)</code></pre><p>Shift bits on <code>positions</code> together.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.hypercubic-Tuple{Array}" href="#BitBasis.hypercubic-Tuple{Array}"><code>BitBasis.hypercubic</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">hypercubic(A::Array) -&gt; Array</code></pre><p>get the hypercubic representation for an array.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.indices_with-Tuple{Int64,Array{Int64,1},Array{Int64,1}}" href="#BitBasis.indices_with-Tuple{Int64,Array{Int64,1},Array{Int64,1}}"><code>BitBasis.indices_with</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">indices_with(n::Int, locs::Vector{Int}, vals::Vector{Int}) -&gt; Vector{Int}</code></pre><p>Return indices with specific positions <code>locs</code> with value <code>vals</code> in a hilbert space of <code>n</code> qubits.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.invorder-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}" href="#BitBasis.invorder-Tuple{Union{AbstractArray{T,1}, AbstractArray{T,2}} where T}"><code>BitBasis.invorder</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">invorder(X::AbstractVecOrMat)</code></pre><p>Inverse the order of given vector/matrix <code>X</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.ismatch-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer,Integer}} where T" href="#BitBasis.ismatch-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer,Integer}} where T"><code>BitBasis.ismatch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ismatch(index::Integer, mask::Integer, target::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if bits at positions masked by <code>mask</code> equal to <code>1</code> are equal to <code>target</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; n = 0b11001; mask = 0b10100; target = 0b10000;

julia&gt; ismatch(n, mask, target)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.ismatch-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer" href="#BitBasis.ismatch-Union{Tuple{T}, Tuple{T,T,T}} where T&lt;:Integer"><code>BitBasis.ismatch</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ismatch(index::Integer, mask::Integer, target::Integer) -&gt; Bool</code></pre><p>Return <code>true</code> if bits at positions masked by <code>mask</code> equal to <code>1</code> are equal to <code>target</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; n = 0b11001; mask = 0b10100; target = 0b10000;

julia&gt; ismatch(n, mask, target)
true</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.log2dim1-Tuple{Any}" href="#BitBasis.log2dim1-Tuple{Any}"><code>BitBasis.log2dim1</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">log2dim1(X)</code></pre><p>Returns the <code>log2</code> of the first dimension&#39;s size.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.log2i" href="#BitBasis.log2i"><code>BitBasis.log2i</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">log2i(x::Integer) -&gt; Integer</code></pre><p>Return log2(x), this integer version of <code>log2</code> is fast but only valid for number equal to 2^n.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.neg-Tuple{BitStr}" href="#BitBasis.neg-Tuple{BitStr}"><code>BitBasis.neg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">neg(bit_str) -&gt; Integer</code></pre><p>Return an <a href="#BitBasis.BitStr"><code>BitStr</code></a> with all bits flipped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; neg(bit&quot;1111&quot;, 4)
0000 (0)

julia&gt; neg(bit&quot;0111&quot;, 4)
1000 (8)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.neg-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer" href="#BitBasis.neg-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>BitBasis.neg</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">neg(index::Integer, nbits::Int) -&gt; Integer</code></pre><p>Return an integer with all bits flipped (with total number of bit <code>nbits</code>).</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; neg(0b1111, 4) |&gt; bit(len=4)
0000 (0)

julia&gt; neg(0b0111, 4) |&gt; bit(len=4)
1000 (8)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.onehot-Union{Tuple{T}, Tuple{Type{T},BitStr}} where T" href="#BitBasis.onehot-Union{Tuple{T}, Tuple{Type{T},BitStr}} where T"><code>BitBasis.onehot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">onehot([T=Float64], bit_str[, nbatch])</code></pre><p>Returns an onehot vector in type <code>Vector{T}</code>, or a batch of onehot vector in type <code>Matrix{T}</code>, where the <code>bit_str</code>-th element is one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.onehot-Union{Tuple{T}, Tuple{Type{T},Int64,Integer}} where T" href="#BitBasis.onehot-Union{Tuple{T}, Tuple{Type{T},Int64,Integer}} where T"><code>BitBasis.onehot</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">onehot([T=Float64], nbits, x::Integer[, nbatch::Int])</code></pre><p>Create an onehot vector in type <code>Vector{T}</code> or a batch of onehot vector in type <code>Matrix{T}</code>, where index <code>x + 1</code> is one.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.packbits-Tuple{AbstractArray{T,1} where T}" href="#BitBasis.packbits-Tuple{AbstractArray{T,1} where T}"><code>BitBasis.packbits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">packbits(arr::AbstractArray) -&gt; AbstractArray</code></pre><p>pack bits to integers, usually take a BitArray as input.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.readbit-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer" href="#BitBasis.readbit-Union{Tuple{T}, Tuple{T,Int64}} where T&lt;:Integer"><code>BitBasis.readbit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">readbit(x, loc...)</code></pre><p>Read the bit config at given location.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.reorder" href="#BitBasis.reorder"><code>BitBasis.reorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">reorder(X::AbstractArray, orders)</code></pre><p>Reorder <code>X</code> according to <code>orders</code>.</p><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>Although <code>orders</code> can be any iterable, <code>Tuple</code> is preferred inorder to gain as much performance as possible. But the conversion won&#39;t take much anyway.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.setbit-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T" href="#BitBasis.setbit-Union{Tuple{T}, Tuple{BitStr{T,N} where N,Integer}} where T"><code>BitBasis.setbit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setbit(b::BitStr, mask::Integer) -&gt; Integer</code></pre><p>set the bit at masked position to 1.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; setbit(bit&quot;1011&quot;, 0b1100)
1111 (15)

julia&gt; setbit(bit&quot;1011&quot;, 0b0100)
1111 (15)

julia&gt; setbit(bit&quot;1011&quot;, 0b0000)
1011 (11)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.setbit-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer" href="#BitBasis.setbit-Union{Tuple{T}, Tuple{T,T}} where T&lt;:Integer"><code>BitBasis.setbit</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">setbit(index::Integer, mask::Integer) -&gt; Integer</code></pre><p>set the bit at masked position to 1.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; setbit(0b1011, 0b1100) |&gt; bit(len=4)
1111 (15)

julia&gt; setbit(0b1011, 0b0100) |&gt; bit(len=4)
1111 (15)

julia&gt; setbit(0b1011, 0b0000) |&gt; bit(len=4)
1011 (11)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.swapbits-Tuple{BitStr,Int64,Int64}" href="#BitBasis.swapbits-Tuple{BitStr,Int64,Int64}"><code>BitBasis.swapbits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swapbits(n::BitStr, mask_ij::Integer) -&gt; BitStr
swapbits(n::BitStr, i::Int, j::Int) -&gt; BitStr</code></pre><p>Return a <a href="#BitBasis.BitStr"><code>BitStr</code></a> with bits at <code>i</code> and <code>j</code> flipped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; swapbits(0b1011, 0b1100) == 0b0111
true</code></pre><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>mask_ij</code> should only contain two <code>1</code>, <code>swapbits</code> will not check it, use at your own risk.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.swapbits-Union{Tuple{T}, Tuple{T,Int64,Int64}} where T&lt;:Integer" href="#BitBasis.swapbits-Union{Tuple{T}, Tuple{T,Int64,Int64}} where T&lt;:Integer"><code>BitBasis.swapbits</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">swapbits(n::Integer, mask_ij::Integer) -&gt; Integer
swapbits(n::Integer, i::Int, j::Int) -&gt; Integer</code></pre><p>Return an integer with bits at <code>i</code> and <code>j</code> flipped.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; swapbits(0b1011, 0b1100) == 0b0111
true</code></pre><div class="admonition tip"><div class="admonition-title">Tip</div><div class="admonition-text"><p>locations <code>i</code> and <code>j</code> specified by mask could be faster when <a href="#BitBasis.bmask"><code>bmask</code></a> is not straight forward but known by constant.</p></div></div><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>mask_ij</code> should only contain two <code>1</code>, <code>swapbits</code> will not check it, use at your own risk.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.to_location-Tuple{Any}" href="#BitBasis.to_location-Tuple{Any}"><code>BitBasis.to_location</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">to_location(x)</code></pre><p>Convert bit configuration <code>x</code> to an index.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; to_location(1)
2

julia&gt; to_location(bit&quot;111&quot;)
111 (7)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.BitStr" href="#BitBasis.BitStr"><code>BitBasis.BitStr</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">BitStr{T}</code></pre><p>String literal for bits.</p><pre><code class="language-none">BitStr(value[, len=ndigits(value)])</code></pre><p>Returns a <code>BitStr</code>, by default the length is set to the minimum length required to represent <code>value</code> as bits.</p><pre><code class="language-none">BitStr(str::String)</code></pre><p>Parse the input string to a BitStr. See <a href="#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a> for more details.</p><p><strong>Example</strong></p><p><code>BitStr</code> supports some basic arithmetic operations. It acts like an integer, but supports some frequently used methods for binary basis.</p><pre><code class="language-julia">julia&gt; bit&quot;101&quot; * 2
1010 (10)

julia&gt; bcat(bit&quot;101&quot; for i in 1:10)
101101101101101101101101101101 (766958445)

julia&gt; repeat(bit&quot;101&quot;, 2)
101101 (45)

julia&gt; bit&quot;1101&quot;[2]
0</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.IterControl" href="#BitBasis.IterControl"><code>BitBasis.IterControl</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">IterControl{S}
IterControl(n::Int, base::Int, masks, ks) -&gt; IterControl</code></pre><p>Iterator to iterate through controlled subspace. See also <a href="man/@ref"><code>itercontrol</code></a>.  <code>S</code> is the number of shifts,  <code>n</code> is the size of Hilbert space,  <code>base</code> is the base of counter,  <code>masks</code> and <code>ks</code> are helpers for enumerating over the target Hilbert Space.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.ReorderedBasis" href="#BitBasis.ReorderedBasis"><code>BitBasis.ReorderedBasis</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ReorderedBasis{N, T}</code></pre><p>Lazy reorderd basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.ReorderedBasis-Union{Tuple{Tuple{Vararg{T,N}}}, Tuple{T}, Tuple{N}} where T&lt;:Integer where N" href="#BitBasis.ReorderedBasis-Union{Tuple{Tuple{Vararg{T,N}}}, Tuple{T}, Tuple{N}} where T&lt;:Integer where N"><code>BitBasis.ReorderedBasis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">ReorderedBasis(orders::NTuple{N, &lt;:Integer})</code></pre><p>Returns a lazy set of reordered basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.next_reordered_basis-Union{Tuple{T}, Tuple{N}, Tuple{T,Tuple{Vararg{T,N}},Tuple{Vararg{T,N}}}} where T where N" href="#BitBasis.next_reordered_basis-Union{Tuple{T}, Tuple{N}, Tuple{T,Tuple{Vararg{T,N}},Tuple{Vararg{T,N}}}} where T where N"><code>BitBasis.next_reordered_basis</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">next_reordered_basis(basis, takers, differ)</code></pre><p>Returns the next reordered basis accroding to current basis.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.unsafe_reorder" href="#BitBasis.unsafe_reorder"><code>BitBasis.unsafe_reorder</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">unsafe_reorder(X::AbstractArray, orders)</code></pre><p>Reorder <code>X</code> according to <code>orders</code>.</p><div class="admonition warning"><div class="admonition-title">Warning</div><div class="admonition-text"><p><code>unsafe_reorder</code> won&#39;t check whether the length of <code>orders</code> and the size of first dimension of <code>X</code> match, use at your own risk.</p></div></div></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{N}, Tuple{UnitRange{T},Tuple{Vararg{T,N}}}} where T where N" href="#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{N}, Tuple{UnitRange{T},Tuple{Vararg{T,N}}}} where T where N"><code>BitBasis.unsafe_sub</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unsafe_sub(a::UnitRange, b::NTuple{N}) -&gt; NTuple{N}</code></pre><p>Returns result in type <code>Tuple</code> of <code>a .- b</code>. This will not check the length of <code>a</code> and <code>b</code>, use at your own risk.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{UnitRange{T},Array{T,1}}} where T" href="#BitBasis.unsafe_sub-Union{Tuple{T}, Tuple{UnitRange{T},Array{T,1}}} where T"><code>BitBasis.unsafe_sub</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">unsafe_sub(a::UnitRange{T}, b::Vector{T}) where T</code></pre><p>Returns <code>a .- b</code>, fallback version when b is a <code>Vector</code>.</p></div></div></section><footer><hr/><a class="previous" href="../registers/"><span class="direction">Previous</span><span class="title">Abstract Registers</span></a><a class="next" href="../extending_blocks/"><span class="direction">Next</span><span class="title">Extending Blocks</span></a></footer></article></body></html>

<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Quantum Registers · Documentation | Yao</title><meta name="title" content="Quantum Registers · Documentation | Yao"/><meta property="og:title" content="Quantum Registers · Documentation | Yao"/><meta property="twitter:title" content="Quantum Registers · Documentation | Yao"/><meta name="description" content="Documentation for Documentation | Yao."/><meta property="og:description" content="Documentation for Documentation | Yao."/><meta property="twitter:description" content="Documentation for Documentation | Yao."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="https://yaoquantum.org/assets/favicon-light.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Documentation | Yao logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Documentation | Yao</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../quick-start.html">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li class="is-active"><a class="tocitem" href="registers.html">Quantum Registers</a><ul class="internal"><li><a class="tocitem" href="#Constructing-quantum-states"><span>Constructing quantum states</span></a></li><li><a class="tocitem" href="#Arithmetic-operations"><span>Arithmetic operations</span></a></li><li><a class="tocitem" href="#Register-operations"><span>Register operations</span></a></li><li><a class="tocitem" href="#Measurement"><span>Measurement</span></a></li><li><a class="tocitem" href="#Density-matrices"><span>Density matrices</span></a></li><li><a class="tocitem" href="#API"><span>API</span></a></li></ul></li><li><a class="tocitem" href="blocks.html">Blocks</a></li><li><a class="tocitem" href="symbolic.html">Symbolic Computation</a></li><li><a class="tocitem" href="cuda.html">CUDA extension - CuYao</a></li><li><a class="tocitem" href="plot.html">Quantum Circuit Visualization</a></li><li><a class="tocitem" href="automatic_differentiation.html">Automatic Differentiation</a></li><li><a class="tocitem" href="yao2einsum.html">Tensor network backend</a></li><li><a class="tocitem" href="simplification.html">Simplification</a></li><li><a class="tocitem" href="bitbasis.html">BitBasis</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/1.prepare-ghz-state/index.html">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="tocitem" href="../generated/examples/2.qft-phase-estimation/index.html">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="tocitem" href="../generated/examples/3.grover-search/index.html">Grover Search</a></li><li><a class="tocitem" href="../generated/examples/4.shor-algorithm/index.html">Shor&#39;s Algorithm</a></li><li><a class="tocitem" href="../generated/examples/5.shor-9-code/index.html">Shor&#39;s 9 qubit code</a></li><li><a class="tocitem" href="../generated/examples/6.quantum-circuit-born-machine/index.html">Quantum Circuit Born Machine</a></li><li><a class="tocitem" href="../generated/examples/7.variation-quantum-eigen-solver/index.html">Variational Quantum Eigen Solver</a></li><li><a class="tocitem" href="../generated/examples/8.riemannian-gradient-flow/index.html">Riemannian gradient flow optimizer</a></li></ul></li><li><a class="tocitem" href="../performancetips.html">Performance Tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="registers.html">Quantum Registers</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="registers.html">Quantum Registers</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumBFS/Yao.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/registers.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="registers"><a class="docs-heading-anchor" href="#registers">Quantum Registers</a><a id="registers-1"></a><a class="docs-heading-anchor-permalink" href="#registers" title="Permalink"></a></h1><h2 id="Constructing-quantum-states"><a class="docs-heading-anchor" href="#Constructing-quantum-states">Constructing quantum states</a><a id="Constructing-quantum-states-1"></a><a class="docs-heading-anchor-permalink" href="#Constructing-quantum-states" title="Permalink"></a></h2><p>A quantum register is a quantum state or a batch of quantum states. Qubits in a Yao register can be active or inactive. Only active qubits are visible to quantum operators, which enables applying quantum operators on a subset of qubits. For example, Suppose we want to run a quantum Fourier transformation circuit of size 4 on qubits <code>(1, 3, 5, 7)</code> with the <a href="registers.html#YaoAPI.focus!"><code>focus!</code></a> function, we first set these qubits to active qubits the rest to inactive, then we apply the circuit on the active qubits, and finally we switch back to the original configuration with the <a href="registers.html#YaoAPI.relax!"><code>relax!</code></a> function.</p><p><code>Yao</code> provides two types of quantum registers <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> and <a href="registers.html#YaoArrayRegister.BatchedArrayReg"><code>BatchedArrayReg</code></a>. Both use matrices as the storage.  For example, for a quantum register with <span>$a$</span> active qubits, <span>$r$</span> remaining qubits and batch size <span>$b$</span>, the storage is as follows.</p><p><img src="../assets/images/regstorage.svg" alt/></p><p>The first dimension of size <span>$2^a$</span> is for active qubits, only this subset of qubits are allowed to interact with quantum operators. Since we reshaped the state vector into a matrix, applying a quantum operator can be conceptually represented as a matrix-matrix multiplication.</p><p>Various quantum states can be created with the following functions.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; using Yao</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = ArrayReg([0, 1, -1+0.0im, 0])  # a unnormalized Bell state |01⟩ - |10⟩</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/2
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; statevec(reg)  # a quantum state is represented as a vector</code><code class="nohighlight hljs ansi" style="display:block;">4-element Vector{ComplexF64}:
  0.0 + 0.0im
  1.0 + 0.0im
 -1.0 + 0.0im
  0.0 + 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg)</code><code class="nohighlight hljs ansi" style="display:block;">00 ₍₂₎   0.0 + 0.0im
01 ₍₂₎   1.0 + 0.0im
10 ₍₂₎   -1.0 + 0.0im
11 ₍₂₎   0.0 + 0.0im</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_zero = zero_state(3)  # create a zero state |000⟩</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_zero)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎   1.0 + 0.0im
001 ₍₂₎   0.0 + 0.0im
010 ₍₂₎   0.0 + 0.0im
011 ₍₂₎   0.0 + 0.0im
100 ₍₂₎   0.0 + 0.0im
101 ₍₂₎   0.0 + 0.0im
110 ₍₂₎   0.0 + 0.0im
111 ₍₂₎   0.0 + 0.0im</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_rand = rand_state(ComplexF32, 3)  # a random state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF32, Array...}
    active qubits: 3/3
    nlevel: 2</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_uniform = uniform_state(ComplexF32, 3)  # a uniform state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF32, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_uniform)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎   0.35355f0 + 0.0f0im
001 ₍₂₎   0.35355f0 + 0.0f0im
010 ₍₂₎   0.35355f0 + 0.0f0im
011 ₍₂₎   0.35355f0 + 0.0f0im
100 ₍₂₎   0.35355f0 + 0.0f0im
101 ₍₂₎   0.35355f0 + 0.0f0im
110 ₍₂₎   0.35355f0 + 0.0f0im
111 ₍₂₎   0.35355f0 + 0.0f0im</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_prod = product_state(bit&quot;110&quot;)  # a product state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; bit&quot;110&quot;[3]  # the bit string is in little-endian format</code><code class="nohighlight hljs ansi" style="display:block;">1</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_prod)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎   0.0 + 0.0im
001 ₍₂₎   0.0 + 0.0im
010 ₍₂₎   0.0 + 0.0im
011 ₍₂₎   0.0 + 0.0im
100 ₍₂₎   0.0 + 0.0im
101 ₍₂₎   0.0 + 0.0im
110 ₍₂₎   1.0 + 0.0im
111 ₍₂₎   0.0 + 0.0im</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_ghz = ghz_state(3)  # a GHZ state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_ghz)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎   0.70711 - 0.0im
001 ₍₂₎   0.0 + 0.0im
010 ₍₂₎   0.0 + 0.0im
011 ₍₂₎   0.0 + 0.0im
100 ₍₂₎   0.0 + 0.0im
101 ₍₂₎   0.0 + 0.0im
110 ₍₂₎   0.0 + 0.0im
111 ₍₂₎   0.70711 - 0.0im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; von_neumann_entropy(reg_ghz, (1, 3)) / log(2) # entanglement entropy between qubits (1, 3) and (2,)</code><code class="nohighlight hljs ansi" style="display:block;">1.0000000000000229</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_rand3 = rand_state(3, nlevel=3)  # a random qutrit state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{3, ComplexF64, Array...}
    active qudits: 3/3
    nlevel: 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_prod3 = product_state(dit&quot;120;3&quot;)  # a qudit product state, what follows &quot;;&quot; symbol denotes the number of levels</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{3, ComplexF64, Array...}
    active qudits: 3/3
    nlevel: 3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_prod3)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₃₎   0.0 + 0.0im
001 ₍₃₎   0.0 + 0.0im
002 ₍₃₎   0.0 + 0.0im
010 ₍₃₎   0.0 + 0.0im
011 ₍₃₎   0.0 + 0.0im
012 ₍₃₎   0.0 + 0.0im
020 ₍₃₎   0.0 + 0.0im
021 ₍₃₎   0.0 + 0.0im
022 ₍₃₎   0.0 + 0.0im
100 ₍₃₎   0.0 + 0.0im
101 ₍₃₎   0.0 + 0.0im
102 ₍₃₎   0.0 + 0.0im
110 ₍₃₎   0.0 + 0.0im
111 ₍₃₎   0.0 + 0.0im
112 ₍₃₎   0.0 + 0.0im
120 ₍₃₎   1.0 + 0.0im
121 ₍₃₎   0.0 + 0.0im
122 ₍₃₎   0.0 + 0.0im
200 ₍₃₎   0.0 + 0.0im
201 ₍₃₎   0.0 + 0.0im
202 ₍₃₎   0.0 + 0.0im
210 ₍₃₎   0.0 + 0.0im
211 ₍₃₎   0.0 + 0.0im
212 ₍₃₎   0.0 + 0.0im
220 ₍₃₎   0.0 + 0.0im
221 ₍₃₎   0.0 + 0.0im
222 ₍₃₎   0.0 + 0.0im</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_batch = rand_state(3; nbatch=2)  # a batch of 2 random qubit states</code><code class="nohighlight hljs ansi" style="display:block;">BatchedArrayReg{2, ComplexF64, Transpose...}
    active qubits: 3/3
    nlevel: 2
    nbatch: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_batch)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎   -0.00131 - 0.2684im; 0.16813 + 0.14023im
001 ₍₂₎   0.30648 - 0.29432im; 0.03173 - 0.23842im
010 ₍₂₎   0.12485 - 0.09021im; -0.64855 + 0.18629im
011 ₍₂₎   0.13148 - 0.35264im; 0.16267 - 0.47im
100 ₍₂₎   0.16153 + 0.35565im; 0.02691 + 0.33801im
101 ₍₂₎   -0.20673 - 0.41949im; 0.06515 + 0.05127im
110 ₍₂₎   0.2543 - 0.1087im; 0.16238 + 0.15649im
111 ₍₂₎   -0.17558 + 0.3216im; 0.05642 - 0.12514im</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg_view = viewbatch(reg_batch, 1)  # view the first state in the batch</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, SubArray...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg_view)</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎   -0.00131 - 0.2684im
001 ₍₂₎   0.30648 - 0.29432im
010 ₍₂₎   0.12485 - 0.09021im
011 ₍₂₎   0.13148 - 0.35264im
100 ₍₂₎   0.16153 + 0.35565im
101 ₍₂₎   -0.20673 - 0.41949im
110 ₍₂₎   0.2543 - 0.1087im
111 ₍₂₎   -0.17558 + 0.3216im</code></pre><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = rand_state(3; nlevel=4, nbatch=2)</code><code class="nohighlight hljs ansi" style="display:block;">BatchedArrayReg{4, ComplexF64, Transpose...}
    active qudits: 3/3
    nlevel: 4
    nbatch: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nqudits(reg)  # the total number of qudits</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nactive(reg)  # the number of active qubits</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nremain(reg)  # the number of remaining qubits</code><code class="nohighlight hljs ansi" style="display:block;">0</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nbatch(reg)  # the batch size</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nlevel(reg)  # the number of levels of each qudit</code><code class="nohighlight hljs ansi" style="display:block;">4</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis(reg)  # the basis of the register</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₄₎:333 ₍₄₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; focus!(reg, 1:2)  # set on the first two qubits as active</code><code class="nohighlight hljs ansi" style="display:block;">BatchedArrayReg{4, ComplexF64, Transpose...}
    active qudits: 2/3
    nlevel: 4
    nbatch: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nactive(reg)  # the number of active qubits</code><code class="nohighlight hljs ansi" style="display:block;">2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; basis(reg)  # the basis of the register</code><code class="nohighlight hljs ansi" style="display:block;">00 ₍₄₎:33 ₍₄₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; relax!(reg)  # set all qubits as active</code><code class="nohighlight hljs ansi" style="display:block;">BatchedArrayReg{4, ComplexF64, Transpose...}
    active qudits: 3/3
    nlevel: 4
    nbatch: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; nactive(reg)  # the number of active qubits</code><code class="nohighlight hljs ansi" style="display:block;">3</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reorder!(reg, (3,1,2))  # reorder the qubits</code><code class="nohighlight hljs ansi" style="display:block;">BatchedArrayReg{4, ComplexF64, Transpose...}
    active qudits: 3/3
    nlevel: 4
    nbatch: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1 = product_state(bit&quot;111&quot;);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg2 = ghz_state(3);</code><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; fidelity(reg1, reg2)  # the fidelity between two states</code><code class="nohighlight hljs ansi" style="display:block;">0.7071067811865476</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; tracedist(reg1, reg2)  # the trace distance between two states</code><code class="nohighlight hljs ansi" style="display:block;">0.7071067811865477</code></pre><h2 id="Arithmetic-operations"><a class="docs-heading-anchor" href="#Arithmetic-operations">Arithmetic operations</a><a id="Arithmetic-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Arithmetic-operations" title="Permalink"></a></h2><p>The list of arithmetic operations for <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> include </p><ul><li><code>+</code></li><li><code>-</code></li><li><code>*</code></li><li><code>/</code> (scalar)</li><li><code>adjoint</code></li></ul><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1 = rand_state(3)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg2 = rand_state(3)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg3 = reg1 + reg2  # addition</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; normalize!(reg3)  # normalize the state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isnormalized(reg3)  # check if the state is normalized</code><code class="nohighlight hljs ansi" style="display:block;">true</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1 - reg2  # subtraction</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1 * 2  # scalar multiplication</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1 / 2  # scalar division</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1&#39;  # adjoint</code><code class="nohighlight hljs ansi" style="display:block;">AdjointRegister{2, ArrayReg{2, ComplexF64, Matrix{ComplexF64}}}(ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2)</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1&#39; * reg1  # inner product</code><code class="nohighlight hljs ansi" style="display:block;">1.0 + 0.0im</code></pre><h2 id="Register-operations"><a class="docs-heading-anchor" href="#Register-operations">Register operations</a><a id="Register-operations-1"></a><a class="docs-heading-anchor-permalink" href="#Register-operations" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg0 = rand_state(3)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; append_qudits!(reg0, 2)  # append 2 qubits</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; insert_qudits!(reg0, 2, 2)  # insert 2 qubits at the 2nd position</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 7/7
    nlevel: 2</code></pre><p>Comparing with using matrix multiplication for quantum simulation, using specialized instructions are much faster and memory efficient. These instructions are specified with the <a href="registers.html#YaoAPI.instruct!"><code>instruct!</code></a> function.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = zero_state(2)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/2
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; instruct!(reg, Val(:H), (1,))  # apply a Hadamard gate on the first qubit</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/2
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; print_table(reg)</code><code class="nohighlight hljs ansi" style="display:block;">00 ₍₂₎   0.70711 + 0.0im
01 ₍₂₎   0.70711 + 0.0im
10 ₍₂₎   0.0 + 0.0im
11 ₍₂₎   0.0 + 0.0im</code></pre><h2 id="Measurement"><a class="docs-heading-anchor" href="#Measurement">Measurement</a><a id="Measurement-1"></a><a class="docs-heading-anchor-permalink" href="#Measurement" title="Permalink"></a></h2><p>We use the <a href="registers.html#YaoAPI.measure!"><code>measure!</code></a> function returns the measurement outcome and collapses the state after the measurement. We also have some &quot;cheating&quot; version <a href="registers.html#YaoAPI.measure"><code>measure</code></a> that does not collapse states to facilitate classical simulation.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure!(reg0, 1)  # measure the qubit, the state collapses</code><code class="nohighlight hljs ansi" style="display:block;">0 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure!(reg0)  # measure all qubits</code><code class="nohighlight hljs ansi" style="display:block;">0010000 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure(reg0, 3)  # measure the qubit at location 3, the state does not collapse (hacky)</code><code class="nohighlight hljs ansi" style="display:block;">1-element Vector{DitStr{2, 1, Int64}}:
 0 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reorder!(reg0, 7:-1:1)  # reorder the qubits</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 7/7
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure!(reg0)</code><code class="nohighlight hljs ansi" style="display:block;">0000100 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; invorder!(reg0)  # reverse the order of qubits</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 7/7
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure!(reg0)</code><code class="nohighlight hljs ansi" style="display:block;">0010000 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; measure!(RemoveMeasured(), reg0, 2:4)  # remove the measured qubits</code><code class="nohighlight hljs ansi" style="display:block;">000 ₍₂₎</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg0</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg1 = ghz_state(3)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; select!(reg1, bit&quot;111&quot;)  # post-select the |111⟩ state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 0/0
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; isnormalized(reg1)  # check if the state is normalized</code><code class="nohighlight hljs ansi" style="display:block;">false</code></pre><h2 id="Density-matrices"><a class="docs-heading-anchor" href="#Density-matrices">Density matrices</a><a id="Density-matrices-1"></a><a class="docs-heading-anchor-permalink" href="#Density-matrices" title="Permalink"></a></h2><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; reg = rand_state(3)</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rho = density_matrix(reg)  # the density matrix of the state</code><code class="nohighlight hljs ansi" style="display:block;">DensityMatrix{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; rand_density_matrix(3)  # a random density matrix</code><code class="nohighlight hljs ansi" style="display:block;">DensityMatrix{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; completely_mixed_state(3)  # a completely mixed state</code><code class="nohighlight hljs ansi" style="display:block;">DensityMatrix{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; partial_tr(rho, 1)  # partial trace on the first qubit</code><code class="nohighlight hljs ansi" style="display:block;">DensityMatrix{2, ComplexF64, Array...}
    active qubits: 2/2
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; purify(rho)  # purify the state</code><code class="nohighlight hljs ansi" style="display:block;">ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/6
    nlevel: 2</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; von_neumann_entropy(rho)  # von Neumann entropy</code><code class="nohighlight hljs ansi" style="display:block;">5.624513604281401e-14</code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; mutual_information(rho, 1, 2)  # mutual information between qubits 1 and 2</code><code class="nohighlight hljs ansi" style="display:block;">0.2659095304711605</code></pre><h2 id="API"><a class="docs-heading-anchor" href="#API">API</a><a id="API-1"></a><a class="docs-heading-anchor-permalink" href="#API" title="Permalink"></a></h2><p>The constructors and functions for quantum registers are listed below.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.AbstractRegister" href="#YaoAPI.AbstractRegister"><code>YaoAPI.AbstractRegister</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractRegister{D}</code></pre><p>Abstract type for quantum registers. Type parameter <code>D</code> is the number of levels in each qudit. For qubits, <code>D = 2</code>.</p><p><strong>Required methods</strong></p><ul><li><p><a href="registers.html#YaoAPI.instruct!"><code>instruct!</code></a></p></li><li><p><a href="registers.html#YaoAPI.nqudits"><code>nqudits</code></a></p></li><li><p><a href="registers.html#YaoAPI.nactive"><code>nactive</code></a></p></li><li><p><a href="registers.html#YaoAPI.insert_qubits!"><code>insert_qubits!</code></a></p></li><li><p><a href="registers.html#YaoAPI.append_qubits!"><code>append_qubits!</code></a></p></li><li><p><a href="registers.html#YaoAPI.focus!"><code>focus!</code></a></p></li><li><p><a href="registers.html#YaoAPI.relax!"><code>relax!</code></a></p></li><li><p><a href="registers.html#YaoAPI.reorder!"><code>reorder!</code></a></p></li><li><p><a href="registers.html#YaoAPI.invorder!"><code>invorder!</code></a></p></li></ul><p><strong>Optional methods</strong></p><ul><li><a href="registers.html#YaoAPI.nlevel"><code>nlevel</code></a></li><li><a href="registers.html#YaoAPI.nremain"><code>nremain</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L3-L29">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.AbstractArrayReg" href="#YaoArrayRegister.AbstractArrayReg"><code>YaoArrayRegister.AbstractArrayReg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AbstractArrayReg</code></pre><p>Abstract type for quantum registers that are represented by an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.ArrayReg" href="#YaoArrayRegister.ArrayReg"><code>YaoArrayRegister.ArrayReg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ArrayReg{D,T,MT&lt;:AbstractMatrix{T}} &lt;: AbstractArrayRegister{D}
ArrayReg{D}(raw)
ArrayReg(raw::AbstractVecOrMat; nlevel=2)
ArrayReg(r::ArrayReg)</code></pre><p>Simulated full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. <code>T</code> is the numerical type for each amplitude, it is <code>ComplexF64</code> by default.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>ArrayReg</code> constructor will not normalize the quantum state. If you need a normalized quantum state remember to use <code>normalize!(register)</code> on the register.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L21-L35">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.BatchedArrayReg" href="#YaoArrayRegister.BatchedArrayReg"><code>YaoArrayRegister.BatchedArrayReg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">BatchedArrayReg{D,T,MT&lt;:AbstractMatrix{T}} &lt;: AbstractArrayReg{D}
BatchedArrayReg(raw, nbatch; nlevel=2)
BatchedArrayReg{D}(raw, nbatch)</code></pre><p>Simulated batched full amplitude register type, it uses an array to represent corresponding one or a batch of quantum states. <code>T</code> is the numerical type for each amplitude, it is <code>ComplexF64</code> by default.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>BatchedArrayReg</code> constructor will not normalize the quantum state. If you need a normalized quantum state remember to use <code>normalize!(register)</code> on the register.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L58-L71">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.arrayreg" href="#YaoArrayRegister.arrayreg"><code>YaoArrayRegister.arrayreg</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">arrayreg(state; nbatch::Union{Integer,NoBatch}=NoBatch(), nlevel::Integer=2)</code></pre><p>Create an array register, if nbatch is a integer, it will return a <code>BatchedArrayReg</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L135-L139">source</a></section><section><div><pre><code class="language-julia hljs">arrayreg([T=ComplexF64], bit_str; nbatch=NoBatch())</code></pre><p>Construct an array register from bit string literal. For bit string literal please read <a href="bitbasis.html#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; arrayreg(bit&quot;1010&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; arrayreg(ComplexF32, bit&quot;1010&quot;)
ArrayReg{2, ComplexF32, Array...}
    active qubits: 4/4
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L193-L212">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.product_state" href="#YaoArrayRegister.product_state"><code>YaoArrayRegister.product_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">product_state([T=ComplexF64], dit_str; nbatch=NoBatch(), no_transpose_storage=false)
product_state([T=ComplexF64], nbits::Int, val::Int; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)
product_state([T=ComplexF64], vector; nbatch=NoBatch(), nlevel=2, no_transpose_storage=false)</code></pre><p>Create an <a href="registers.html#YaoArrayRegister.ArrayReg"><code>ArrayReg</code></a> of product state. The configuration can be specified with a dit string, which can be defined with <a href="bitbasis.html#BitBasis.@bit_str-Tuple{Any}"><code>@bit_str</code></a> or <a href="bitbasis.html#BitBasis.@dit_str-Tuple{Any}"><code>@dit_str</code></a>. Or equivalently, it can be specified explicitly with <code>nbits</code>, <code>val</code> and <code>nlevel</code>. See also <a href="registers.html#YaoArrayRegister.zero_state"><code>zero_state</code></a>, <a href="registers.html#YaoArrayRegister.rand_state"><code>rand_state</code></a>, <a href="registers.html#YaoArrayRegister.uniform_state"><code>uniform_state</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(dit&quot;120;3&quot;; nbatch=2)
BatchedArrayReg{3, ComplexF64, Transpose...}
    active qudits: 3/3
    nlevel: 3
    nbatch: 2

julia&gt; measure(reg)
1×2 Matrix{BitBasis.DitStr64{3, 3}}:
 120 ₍₃₎  120 ₍₃₎

julia&gt; product_state(bit&quot;100&quot;; nbatch=2);

julia&gt; r1 = product_state(ComplexF32, bit&quot;001&quot;; nbatch=2);

julia&gt; r2 = product_state(ComplexF32, [1, 0, 0]; nbatch=2);

julia&gt; r3 = product_state(ComplexF32, 3, 0b001; nbatch=2);

julia&gt; r1 ≈ r2   # because we read bit strings from right to left, vectors from left to right.
true

julia&gt; r1 ≈ r3
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L455-L492">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.zero_state" href="#YaoArrayRegister.zero_state"><code>YaoArrayRegister.zero_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())</code></pre><p>Create an <a href="registers.html#YaoArrayRegister.AbstractArrayReg"><code>AbstractArrayReg</code></a> that initialized to state <span>$|0\rangle^{\otimes n}$</span>. See also <a href="registers.html#YaoArrayRegister.product_state"><code>product_state</code></a>, <a href="registers.html#YaoArrayRegister.rand_state"><code>rand_state</code></a>, <a href="registers.html#YaoArrayRegister.uniform_state"><code>uniform_state</code></a> and <a href="registers.html#YaoArrayRegister.ghz_state"><code>ghz_state</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; zero_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; zero_state(ComplexF32, 4)
ArrayReg{2, ComplexF32, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; zero_state(ComplexF32, 4; nbatch=3)
BatchedArrayReg{2, ComplexF32, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 3</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L527-L552">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.zero_state_like" href="#YaoArrayRegister.zero_state_like"><code>YaoArrayRegister.zero_state_like</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">zero_state_like(register, n) -&gt; AbstractRegister</code></pre><p>Create a register initialized to zero from an existing one.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = rand_state(3; nbatch=2);

julia&gt; zero_state_like(reg, 2)
BatchedArrayReg{2, ComplexF64, Array...}
    active qubits: 2/2
    nlevel: 2
    nbatch: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L268-L284">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.rand_state" href="#YaoArrayRegister.rand_state"><code>YaoArrayRegister.rand_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_state([T=ComplexF64], n::Int; nbatch=NoBatch(), no_transpose_storage=false)</code></pre><p>Create a random <a href="registers.html#YaoArrayRegister.AbstractArrayReg"><code>AbstractArrayReg</code></a> with total number of qudits <code>n</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; rand_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; rand_state(ComplexF64, 4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; rand_state(ComplexF64, 4; nbatch=2)
BatchedArrayReg{2, ComplexF64, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L582-L606">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.uniform_state" href="#YaoArrayRegister.uniform_state"><code>YaoArrayRegister.uniform_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">uniform_state([T=ComplexF64], n; nbatch=NoBatch(), no_transpose_storage=false)</code></pre><p>Create a uniform state:</p><p class="math-container">\[\frac{1}{\sqrt{2^n}} \sum_{k=0}^{2^{n}-1} |k\rangle.\]</p><p>This state can also be created by applying <code>H</code> (Hadmard gate) on <span>$|00⋯00⟩$</span> state.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; uniform_state(4; nbatch=2)
BatchedArrayReg{2, ComplexF64, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 2

julia&gt; uniform_state(ComplexF32, 4; nbatch=2)
BatchedArrayReg{2, ComplexF32, Transpose...}
    active qubits: 4/4
    nlevel: 2
    nbatch: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L622-L646">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.ghz_state" href="#YaoArrayRegister.ghz_state"><code>YaoArrayRegister.ghz_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">ghz_state([T=ComplexF64], n::Int; nbatch::Int=NoBatch())</code></pre><p>Create a GHZ state (or a cat state) that defined as</p><p class="math-container">\[\frac{|0\rangle^{\otimes n} + |1\rangle^{\otimes n}}{\sqrt{2}}.\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; ghz_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L556-L573">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.clone" href="#YaoAPI.clone"><code>YaoAPI.clone</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">clone(register, n)</code></pre><p>Create an <a href="@ref"><code>ArrayReg</code></a> by cloning the original <code>register</code> for <code>n</code> times on batch dimension. This function is only for emulation.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; clone(arrayreg(bit&quot;101&quot;; nbatch=3), 4)
BatchedArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2
    nbatch: 12</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L782-L797">source</a></section></article><p>The following functions are for querying the properties of a quantum register.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.nqudits" href="#YaoAPI.nqudits"><code>YaoAPI.nqudits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nqudits(register) -&gt; Int</code></pre><p>Returns the total number of qudits in <code>register</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L77-L81">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.nqubits" href="#YaoAPI.nqubits"><code>YaoAPI.nqubits</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nqubits(register) -&gt; Int</code></pre><p>Returns the (total) number of qubits. See <a href="registers.html#YaoAPI.nactive"><code>nactive</code></a>, <a href="registers.html#YaoAPI.nremain"><code>nremain</code></a> for more details.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L69-L74">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.nactive" href="#YaoAPI.nactive"><code>YaoAPI.nactive</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nactive(register) -&gt; Int</code></pre><p>Returns the number of active qudits in <code>register</code>. Here, active qudits means the system qubits that operators can be applied on.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L61-L66">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.nremain" href="#YaoAPI.nremain"><code>YaoAPI.nremain</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nremain(register) -&gt; Int</code></pre><p>Returns the number of inactive qudits in <code>register</code>. It equals to subtracting <a href="registers.html#YaoAPI.nqudits"><code>nqudits</code></a> and <a href="registers.html#YaoAPI.nactive"><code>nactive</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L84-L89">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.nbatch" href="#YaoArrayRegister.nbatch"><code>YaoArrayRegister.nbatch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nbatch(register) -&gt; Union{Int,NoBatch()}</code></pre><p>Returns the number of batches.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L782-L786">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.nlevel" href="#YaoAPI.nlevel"><code>YaoAPI.nlevel</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">nlevel(x)</code></pre><p>Number of levels in each qudit.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; nlevel(X)
2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/blocks.jl#L137-L148">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.focus!" href="#YaoAPI.focus!"><code>YaoAPI.focus!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">focus!(register, locs) -&gt; register
focus!(locs...) -&gt; f(register) -&gt; register</code></pre><p>Set the active qubits to focused locations, usually used to execute a subroutine. If <code>register</code> is not provided, returns a lambda that takes a register as input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;01101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; focus!(reg, (1,3,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/5
    nlevel: 2

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 111 ₍₂₎
 111 ₍₂₎
 111 ₍₂₎

julia&gt; measure(apply(reg, put(3, 2=&gt;X)); nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 101 ₍₂₎
 101 ₍₂₎
 101 ₍₂₎</code></pre><p>Here, we prepare a product state and only look at the qubits 1, 3 and 4. The measurement results are all ones. With the focued register, we can apply a block of size 3 on it, even though the number of qubits is 5.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L195-L230">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.focus" href="#YaoAPI.focus"><code>YaoAPI.focus</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">focus(f, register, locs)</code></pre><p>Call a callable <code>f</code> under the context of <code>focus</code>. See also <a href="registers.html#YaoAPI.focus!"><code>focus!</code></a>.</p><p><strong>Examples</strong></p><p>To print the focused register</p><pre><code class="language-julia-repl hljs">julia&gt; r = arrayreg(bit&quot;101100&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 6/6
    nlevel: 2

julia&gt; focus(x-&gt;(println(x);x), r, (1, 2));
ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/6
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L233-L253">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.relax!" href="#YaoAPI.relax!"><code>YaoAPI.relax!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relax!(register[, locs]; to_nactive=nqudits(register)) -&gt; register
relax!(locs::Int...; to_nactive=nqudits(register)) -&gt; f(register) -&gt; register</code></pre><p>Inverse transformation of <a href="registers.html#YaoAPI.focus!"><code>focus!</code></a>, where <code>to_nactive</code> is the number  of active bits for target register. If the register is not provided, returns a lambda function that takes a register as input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;01101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; focus!(reg, (1,3,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/5
    nlevel: 2

julia&gt; relax!(reg, (1,3,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L256-L282">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.exchange_sysenv" href="#YaoArrayRegister.exchange_sysenv"><code>YaoArrayRegister.exchange_sysenv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">exchange_sysenv(reg::AbstractArrayReg) -&gt; AbstractRegister</code></pre><p>Exchange system (focused qubits) and environment (remaining qubits).</p><pre><code class="language-julia-repl hljs">julia&gt; reg = rand_state(5)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; focus!(reg, (2,4))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/5
    nlevel: 2

julia&gt; exchange_sysenv(reg)
ArrayReg{2, ComplexF64, Adjoint...}
    active qubits: 3/5
    nlevel: 2</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/focus.jl#L135-L156">source</a></section></article><p>The following functions are for querying the state of a quantum register.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.state" href="#YaoArrayRegister.state"><code>YaoArrayRegister.state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">state(register::AbstractArrayReg) -&gt; Matrix</code></pre><p>Returns the raw array storage of <code>register</code>. See also <a href="registers.html#YaoArrayRegister.statevec"><code>statevec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L378-L382">source</a></section><section><div><pre><code class="language-julia hljs">state(ρ::DensityMatrix) -&gt; Matrix</code></pre><p>Return the raw state of density matrix <code>ρ</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/density_matrix.jl#L4-L8">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BitBasis.basis" href="#BitBasis.basis"><code>BitBasis.basis</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">basis(ditstr) -&gt; UnitRange{DitStr{D,N,T}}
basis(DitStr{D,N,T}) -&gt; UnitRange{DitStr{D,N,T}}</code></pre><p>Returns the <code>UnitRange</code> for basis in Hilbert Space of qudits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/BitBasis.jl/blob/v0.9.7/src/DitStr.jl#L312-L317">source</a></section><section><div><pre><code class="language-julia hljs">basis(register) -&gt; UnitRange</code></pre><p>Returns an <code>UnitRange</code> of the all the bits in the Hilbert space of given register.</p><pre><code class="language-julia-repl hljs">julia&gt; collect(basis(rand_state(3)))
8-element Vector{DitStr{2, 3, Int64}}:
 000 ₍₂₎
 001 ₍₂₎
 010 ₍₂₎
 011 ₍₂₎
 100 ₍₂₎
 101 ₍₂₎
 110 ₍₂₎
 111 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L818-L835">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.statevec" href="#YaoArrayRegister.statevec"><code>YaoArrayRegister.statevec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">statevec(r::ArrayReg) -&gt; array</code></pre><p>Return a state matrix/vector by droping the last dimension of size 1 (i.e. <code>nactive(r) = nqudits(r)</code>). See also <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>.</p><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>statevec</code> is not type stable. It may cause performance slow down.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L388-L397">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.relaxedvec" href="#YaoArrayRegister.relaxedvec"><code>YaoArrayRegister.relaxedvec</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">relaxedvec(r::AbstractArrayReg) -&gt; AbstractArray</code></pre><p>Return a vector representation of state, with all qudits activated. See also <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>, <a href="registers.html#YaoArrayRegister.statevec"><code>statevec</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L400-L405">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="BitBasis.hypercubic" href="#BitBasis.hypercubic"><code>BitBasis.hypercubic</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">hypercubic(A::Array) -&gt; Array</code></pre><p>get the hypercubic representation for an array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/BitBasis.jl/blob/v0.9.7/src/utils.jl#L84-L88">source</a></section><section><div><pre><code class="language-julia hljs">hypercubic(r::ArrayReg) -&gt; AbstractArray</code></pre><p>Return the hypercubic representation (high dimensional tensor) of this register, only active qudits are considered. See also <a href="registers.html#YaoArrayRegister.rank3"><code>rank3</code></a> and <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L409-L414">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.rank3" href="#YaoArrayRegister.rank3"><code>YaoArrayRegister.rank3</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rank3(r::ArrayReg)</code></pre><p>Return the rank 3 tensor representation of state, the 3 dimensions are (activated space, remaining space, batch dimension). See also <a href="registers.html#BitBasis.hypercubic"><code>hypercubic</code></a> and <a href="registers.html#YaoArrayRegister.state"><code>state</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L418-L423">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.viewbatch" href="#YaoAPI.viewbatch"><code>YaoAPI.viewbatch</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">viewbatch(register, i::Int) -&gt; AbstractRegister</code></pre><p>Returns the <code>i</code>-th single register of a batched register. The returned instance is a view of the original register, i.e. inplace operation changes the original register directly.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = zero_state(5; nbatch=2);

julia&gt; apply!(viewbatch(reg, 2), put(5, 2=&gt;X));

julia&gt; measure(reg; nshots=3)
3×2 Matrix{DitStr{2, 5, Int64}}:
 00000 ₍₂₎  00010 ₍₂₎
 00000 ₍₂₎  00010 ₍₂₎
 00000 ₍₂₎  00010 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L92-L111">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.transpose_storage" href="#YaoArrayRegister.transpose_storage"><code>YaoArrayRegister.transpose_storage</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">transpose_storage(register) -&gt; register</code></pre><p>Transpose the register storage. Sometimes transposed storage provides better performance for batched simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L216-L220">source</a></section></article><p>The following functions are for arithmetic operations on quantum registers.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.AdjointArrayReg" href="#YaoArrayRegister.AdjointArrayReg"><code>YaoArrayRegister.AdjointArrayReg</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">AdjointArrayReg{D,T,MT} = AdjointRegister{D,&lt;:AbstractArrayReg{D,T,MT}}</code></pre><p>Adjoint array register type, it is used to represent the bra in the Dirac notation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L151-L155">source</a></section></article><p>We also have some faster inplace versions of arithematic operations</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.regadd!" href="#YaoArrayRegister.regadd!"><code>YaoArrayRegister.regadd!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regadd!(target, source)</code></pre><p>Inplace version of <code>+</code> that accumulates <code>source</code> to <code>target</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/operations.jl#L86-L90">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.regsub!" href="#YaoArrayRegister.regsub!"><code>YaoArrayRegister.regsub!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regsub!(target, source)</code></pre><p>Inplace version of <code>-</code> that subtract <code>source</code> from <code>target</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/operations.jl#L93-L97">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.regscale!" href="#YaoArrayRegister.regscale!"><code>YaoArrayRegister.regscale!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">regscale!(target, x)</code></pre><p>Inplace version of multiplying a scalar <code>x</code> to target.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/operations.jl#L100-L104">source</a></section></article><p>We also define the following functions for state normalization, and distance measurement.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="LinearAlgebra.normalize!" href="#LinearAlgebra.normalize!"><code>LinearAlgebra.normalize!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">normalize!(r::AbstractArrayReg)</code></pre><p>Normalize the register <code>r</code> by its 2-norm. It changes the register directly.</p><p><strong>Examples</strong></p><p>The following code creates a normalized GHZ state.</p><pre><code class="language-julia hljs">julia&gt; reg = product_state(bit&quot;000&quot;) + product_state(bit&quot;111&quot;);

julia&gt; norm(reg)
1.4142135623730951

julia&gt; isnormalized(reg)
false

julia&gt; normalize!(reg);

julia&gt; isnormalized(reg)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/operations.jl#L15-L39">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.isnormalized" href="#YaoArrayRegister.isnormalized"><code>YaoArrayRegister.isnormalized</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">isnormalized(r::ArrayReg) -&gt; Bool</code></pre><p>Returns true if the register <code>r</code> is normalized.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/operations.jl#L2-L6">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.fidelity" href="#YaoAPI.fidelity"><code>YaoAPI.fidelity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">fidelity(register1, register2) -&gt; Real/Vector{&lt;:Real}
fidelity&#39;(pair_or_reg1, pair_or_reg2) -&gt; (g1, g2)</code></pre><p>Return the fidelity between two states. Calcuate the fidelity between <code>r1</code> and <code>r2</code>, if <code>r1</code> or <code>r2</code> is not pure state (<code>nactive(r) != nqudits(r)</code>), the fidelity is calcuated by purification. See also: http://iopscience.iop.org/article/10.1088/1367-2630/aa6a4b/meta</p><p>Obtain the gradient with respect to registers and circuit parameters. For pair input <code>ψ=&gt;circuit</code>, the returned gradient is a pair of <code>gψ=&gt;gparams</code>, with <code>gψ</code> the gradient of input state and <code>gparams</code> the gradients of circuit parameters. For register input, the return value is a register.</p><p><strong>Definition</strong></p><p>The fidelity of two quantum state for qudits is defined as:</p><p class="math-container">\[F(ρ, σ) = tr(\sqrt{\sqrt{ρ}σ\sqrt{ρ}})\]</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>This definition is different from <a href="https://en.wikipedia.org/wiki/Fidelity_of_quantum_states">the one in Wiki</a> by a square.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg1 = uniform_state(3);

julia&gt; reg2 = zero_state(3);

julia&gt; fidelity(reg1, reg2)
0.35355339059327373</code></pre><p><strong>References</strong></p><ul><li>Jozsa R. Fidelity for mixed quantum states[J]. Journal of modern optics, 1994, 41(12): 2315-2323.</li><li>Nielsen M A, Chuang I. Quantum computation and quantum information[J]. 2002.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The original definition of fidelity <span>$F$</span> was from &quot;transition probability&quot;, defined by Jozsa in 1994, it is the square of what we use here.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L606-L652">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.tracedist" href="#YaoAPI.tracedist"><code>YaoAPI.tracedist</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">tracedist(register1, register2)</code></pre><p>Return the trace distance of <code>register1</code> and <code>register2</code>.</p><p><strong>Definition</strong></p><p>Trace distance is defined as following:</p><p class="math-container">\[\frac{1}{2} || A - B ||_{\rm tr}\]</p><p>It takes values between 0 and 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg1 = uniform_state(3);

julia&gt; reg2 = zero_state(3);

julia&gt; tracedist(reg1, reg2)
0.9354143466934852</code></pre><p><strong>References</strong></p><ul><li>https://en.wikipedia.org/wiki/Trace_distance</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L655-L683">source</a></section></article><p>The following functions are for adding and reordering qubits in a quantum register.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.insert_qudits!" href="#YaoAPI.insert_qudits!"><code>YaoAPI.insert_qudits!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_qudits!(register, loc::Int, nqudits::Int) -&gt; register
insert_qudits!(loc::Int, nqudits::Int) -&gt; λ(register)</code></pre><p>Insert qudits to given register in state |0&gt;. i.e. |psi&gt; -&gt; join(|psi&gt;, |0...&gt;, |psi&gt;), increased bits have higher indices.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;01101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; insert_qudits!(reg, 2, 2)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 7/7
    nlevel: 2

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 7, Int64}}:
 0110001 ₍₂₎
 0110001 ₍₂₎
 0110001 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L156-L183">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.insert_qubits!" href="#YaoAPI.insert_qubits!"><code>YaoAPI.insert_qubits!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">insert_qubits!(register, loc::Int, nqubits::Int=1) -&gt; register
insert_qubits!(loc::Int, nqubits::Int=1) -&gt; λ(register)</code></pre><p>Insert <code>n</code> qubits to given register in state |0&gt;. It is an alias of <a href="registers.html#YaoAPI.insert_qudits!"><code>insert_qudits!</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L186-L192">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.append_qudits!" href="#YaoAPI.append_qudits!"><code>YaoAPI.append_qudits!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append_qudits!(register, n::Int) -&gt; register
append_qudits!(n::Int) -&gt; λ(register)</code></pre><p>Add <code>n</code> qudits to given register in state |0&gt;. i.e. |psi&gt; -&gt; |000&gt; ⊗ |psi&gt;, increased bits have higher indices.</p><p>If only an integer is provided, then returns a lambda function.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;01101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 5/5
    nlevel: 2

julia&gt; append_qudits!(reg, 2)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 7/7
    nlevel: 2

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 7, Int64}}:
 0001101 ₍₂₎
 0001101 ₍₂₎
 0001101 ₍₂₎</code></pre><p>Note here, we read the bit string from right to left.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L115-L144">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.append_qubits!" href="#YaoAPI.append_qubits!"><code>YaoAPI.append_qubits!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">append_qubits!(register, n::Int) -&gt; register
append_qubits!(n::Int) -&gt; λ(register)</code></pre><p>Add <code>n</code> qudits to given register in state |0&gt;. It is an alias of <a href="registers.html#YaoAPI.append_qudits!"><code>append_qudits!</code></a> function.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L147-L153">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.reorder!" href="#YaoAPI.reorder!"><code>YaoAPI.reorder!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">reorder!(reigster, orders)</code></pre><p>Reorder the locations of register by input orders. For a 3-qubit register, an order <code>(i, j, k)</code> specifies the following reordering of qubits</p><ul><li>move the first qubit go to <code>i</code>,</li><li>move the second qubit go to <code>j</code>,</li><li>move the third qubit go to <code>k</code>.</li></ul><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The convention of <code>reorder!</code> is different from the <code>permutedims</code> function, one can use the <code>sortperm</code> function to relate the permutation order and the order in this function.</p></div></div><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;010101&quot;);

julia&gt; reorder!(reg, (1,4,2,5,3,6));

julia&gt; measure(reg)
1-element Vector{DitStr{2, 6, Int64}}:
 000111 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L292-L315">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.invorder!" href="#YaoAPI.invorder!"><code>YaoAPI.invorder!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">invorder!(register)</code></pre><p>Inverse the locations of the register.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;010101&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 6/6
    nlevel: 2

julia&gt; measure(invorder!(reg); nshots=3)
3-element Vector{DitStr{2, 6, Int64}}:
 101010 ₍₂₎
 101010 ₍₂₎
 101010 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L318-L337">source</a></section></article><p>The <code>instruct!</code> function is for applying quantum operators on a quantum register.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.instruct!" href="#YaoAPI.instruct!"><code>YaoAPI.instruct!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">instruct!([nlevel=Val(2), ]state, operator, locs[, control_locs, control_configs, theta])</code></pre><p>Unified interface for applying an operator to a quantum state. It modifies the <code>state</code> directly.</p><p><strong>Arguments</strong></p><ul><li><code>nlevel</code> is the number of levels in each qudit,</li><li><code>state</code> is a vector or matrix representing the quantum state, where the first dimension is the active qubit dimension, the second is the batch dimension.</li><li><code>operator</code> is a quantum operator, which can be <code>Val(GATE_SYMBOL)</code> or a matrix.</li><li><code>locs::Tuple</code> is a tuple for specifying the locations this gate applied.</li><li><code>control_locs::Tuple</code> and <code>control_configs</code> are tuples for specifying the control locations and control values.</li><li><code>theta::Real</code> is the parameter for the gate, e.g. <code>Val(:Rx)</code> gate takes a real number of its parameter.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L43-L57">source</a></section></article><p>The following functions are for measurement and post-selection.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.measure!" href="#YaoAPI.measure!"><code>YaoAPI.measure!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure!([postprocess,] [operator, ]register[, locs]; rng=Random.GLOBAL_RNG)</code></pre><p>Measure current active qudits or qudits at <code>locs</code>. If the operator is not provided, it will measure on the computational basis and collapse to a product state. Otherwise, the quantum state collapse to the subspace corresponds to the resulting eigenvalue of the observable.</p><p><strong>Arguments</strong></p><ul><li><code>postprocess</code> is the postprocessing method, it can be<ul><li><code>NoPostProcess()</code> (default).</li><li><code>ResetTo(config)</code>, reset to result state to <code>config</code>. It can not be used if <code>operator</code> is provided, because measuring an operator in general does not return a product state.</li><li><code>RemoveMeasured()</code>, remove the measured qudits from the register. It is also incompatible with the <code>operator</code> argument.</li></ul></li><li><code>operator::AbstractBlock</code> is the operator to measure.</li><li><code>register::AbstractRegister</code> is the quantum state.</li><li><code>locs</code> is the qubits to performance the measurement. If <code>locs</code> is not provided, all current active qudits are measured (regarding to active qudits,</li></ul><p>see <a href="registers.html#YaoAPI.focus!"><code>focus!</code></a> and <a href="registers.html#YaoAPI.relax!"><code>relax!</code></a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>rng</code> is the random number generator.</li></ul><p><strong>Examples</strong></p><p>The following example measures a random state on the computational basis and reset it to a certain bitstring value.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = rand_state(3);

julia&gt; measure!(ResetTo(bit&quot;011&quot;), reg)
110 ₍₂₎

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 011 ₍₂₎
 011 ₍₂₎
 011 ₍₂₎

julia&gt; measure!(RemoveMeasured(), reg, (1,2))
11 ₍₂₎

julia&gt; reg  # removed qubits are not usable anymore
ArrayReg{2, ComplexF64, Array...}
    active qubits: 1/1
    nlevel: 2</code></pre><p>Measuring an operator will project the state to the subspace associated with the returned eigenvalue.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = uniform_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; print_table(reg)
000 ₍₂₎   0.35355 + 0.0im
001 ₍₂₎   0.35355 + 0.0im
010 ₍₂₎   0.35355 + 0.0im
011 ₍₂₎   0.35355 + 0.0im
100 ₍₂₎   0.35355 + 0.0im
101 ₍₂₎   0.35355 + 0.0im
110 ₍₂₎   0.35355 + 0.0im
111 ₍₂₎   0.35355 + 0.0im

julia&gt; measure!(repeat(3, Z, 1:3), reg)
-1.0 + 0.0im

julia&gt; print_table(reg)
000 ₍₂₎   0.0 + 0.0im
001 ₍₂₎   0.5 + 0.0im
010 ₍₂₎   0.5 + 0.0im
011 ₍₂₎   0.0 + 0.0im
100 ₍₂₎   0.5 + 0.0im
101 ₍₂₎   0.0 + 0.0im
110 ₍₂₎   0.0 + 0.0im
111 ₍₂₎   0.5 + 0.0im</code></pre><p>Here, we measured the parity operator, as a result,  the resulting state collapsed to the subspace with either even or odd parity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L441-L520">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.measure" href="#YaoAPI.measure"><code>YaoAPI.measure</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">measure([, operator], register[, locs]; nshots=1, rng=Random.GLOBAL_RNG) -&gt; Vector{Int}</code></pre><p>Measure a quantum state and return measurement results of qudits. This measurement function a cheating version of <code>measure!</code> that does not collapse the input state. It also does not need to recompute the quantum state for performing multiple shots measurement.</p><p><strong>Arguments</strong></p><ul><li><code>operator::AbstractBlock</code> is the operator to measure.</li><li><code>register::AbstractRegister</code> is the quantum state.</li><li><code>locs</code> is the qubits to performance the measurement. If <code>locs</code> is not provided, all current active qudits are measured (regarding to active qudits,</li></ul><p>see <a href="registers.html#YaoAPI.focus!"><code>focus!</code></a> and <a href="registers.html#YaoAPI.relax!"><code>relax!</code></a>).</p><p><strong>Keyword arguments</strong></p><ul><li><code>nshots::Int</code> is the number of shots.</li><li><code>rng</code> is the random number generator.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;110&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; measure(reg; nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 110 ₍₂₎
 110 ₍₂₎
 110 ₍₂₎

julia&gt; measure(reg, (2,3); nshots=3)
3-element Vector{DitStr{2, 2, Int64}}:
 11 ₍₂₎
 11 ₍₂₎
 11 ₍₂₎</code></pre><p>The following example switches to the X basis for measurement.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = apply!(product_state(bit&quot;100&quot;), repeat(3, H, 1:3))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; measure(repeat(3, X, 1:3), reg; nshots=3)
3-element Vector{ComplexF64}:
 -1.0 + 0.0im
 -1.0 + 0.0im
 -1.0 + 0.0im

julia&gt; reg = apply!(product_state(bit&quot;101&quot;), repeat(3, H, 1:3))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; measure(repeat(3, X, 1:3), reg; nshots=3)
3-element Vector{ComplexF64}:
 1.0 - 0.0im
 1.0 - 0.0im
 1.0 - 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L375-L438">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.select!" href="#YaoAPI.select!"><code>YaoAPI.select!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select!(dest::AbstractRegister, src::AbstractRegister, bits::Integer...) -&gt; AbstractRegister
select!(register::AbstractRegister, bits::Integer...) -&gt; register
select!(b::Integer) -&gt; f(register)</code></pre><p>select a subspace of given quantum state based on input eigen state <code>bits</code>. See also <a href="registers.html#YaoAPI.select"><code>select</code></a> for the non-inplace version. If the register is not provided, it returns a lambda expression that takes a register as the input.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = ghz_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; select!(reg, bit&quot;111&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 0/0
    nlevel: 2

julia&gt; norm(reg)
0.7071067811865476</code></pre><p>The selection only works on the activated qubits, for example</p><pre><code class="nohighlight hljs">julia&gt; reg = focus!(ghz_state(3), (1, 2))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 2/3
    nlevel: 2

julia&gt; select!(reg, bit&quot;11&quot;)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 0/1
    nlevel: 2

julia&gt; statevec(reg)
1×2 Matrix{ComplexF64}:
 0.0+0.0im  0.707107+0.0im</code></pre><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>Developers should overload <code>select!(r::RegisterType, bits::NTuple{N, &lt;:Integer})</code> and do not assume <code>bits</code> has specific number of bits (e.g <code>Int64</code>), or it will restrict the its maximum available number of qudits.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L523-L571">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.select" href="#YaoAPI.select"><code>YaoAPI.select</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">select(register, bits) -&gt; AbstractRegister</code></pre><p>The non-inplace version of <a href="registers.html#YaoAPI.select!"><code>select!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L574-L578">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.collapseto!" href="#YaoAPI.collapseto!"><code>YaoAPI.collapseto!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">collapseto!(register, config)</code></pre><p>Set the <code>register</code> to bit string literal <code>bit_str</code> (or an equivalent integer). About bit string literal, see more in <a href="@ref"><code>@bit_str</code></a>. This interface is only for emulation.</p><p><strong>Examples</strong></p><p>The following code collapse a random state to a certain state.</p><pre><code class="language-julia-repl hljs">julia&gt; measure(collapseto!(rand_state(3), bit&quot;001&quot;); nshots=3)
3-element Vector{DitStr{2, 3, Int64}}:
 001 ₍₂₎
 001 ₍₂₎
 001 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L340-L358">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.probs" href="#YaoAPI.probs"><code>YaoAPI.probs</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">probs(register) -&gt; Vector</code></pre><p>Returns the probability distribution of computation basis, aka <span>$|&lt;x|ψ&gt;|^2$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; reg = product_state(bit&quot;101&quot;);

julia&gt; reg |&gt; probs
8-element Vector{Float64}:
 0.0
 0.0
 0.0
 0.0
 0.0
 1.0
 0.0
 0.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L582-L603">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.most_probable" href="#YaoArrayRegister.most_probable"><code>YaoArrayRegister.most_probable</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">most_probable(reg::ArrayReg{D, T} where T, n::Int64) -&gt; Any
</code></pre><p>Find <code>n</code> most probable qubit configurations in a quantum register and return these configurations as a vector of <code>DitStr</code> instances.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; most_probable(ghz_state(3), 2)
2-element Vector{DitStr{2, 3, Int64}}:
 000 ₍₂₎
 111 ₍₂₎</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L791">source</a></section></article><p>The following functions are for density matrices.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.DensityMatrix" href="#YaoAPI.DensityMatrix"><code>YaoAPI.DensityMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">DensityMatrix{D,T,MT&lt;:AbstractMatrix{T}} &lt;: AbstractRegister{D}
DensityMatrix{D}(state::AbstractMatrix)
DensityMatrix(state::AbstractMatrix; nlevel=2)</code></pre><p>Density matrix type, where <code>state</code> is a matrix. Type parameter <code>D</code> is the number of levels, it can also be specified by a keyword argument <code>nlevel</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L712-L719">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.density_matrix" href="#YaoAPI.density_matrix"><code>YaoAPI.density_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">density_matrix(register_or_rho[, locations])</code></pre><p>Returns the reduced density matrix for qubits at <code>locations</code> (default: all qubits).</p><p><strong>Examples</strong></p><p>The following code gets the single site reduce density matrix for the GHZ state.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = ghz_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; density_matrix(reg, (2,)).state
2×2 Matrix{ComplexF64}:
 0.5+0.0im  0.0+0.0im
 0.0-0.0im  0.5+0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L759-L779">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.rand_density_matrix" href="#YaoArrayRegister.rand_density_matrix"><code>YaoArrayRegister.rand_density_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">rand_density_matrix([T=ComplexF64], n::Int; nlevel::Int=2, pure::Bool=false)</code></pre><p>Generate a random density matrix by partial tracing half of the pure state.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>The generated density matrix is not strict hermitian due to rounding error. If you need to check hermicity, do not use <code>ishermitian</code> consider using <code>isapprox(dm.state, dm.state&#39;)</code> or explicit mark it as <code>Hermitian</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/density_matrix.jl#L26-L36">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.completely_mixed_state" href="#YaoArrayRegister.completely_mixed_state"><code>YaoArrayRegister.completely_mixed_state</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">completely_mixed_state([T=ComplexF64], n::Int; nlevel::Int=2)</code></pre><p>Generate the completely mixed state with density matrix <code>I(n) ./ nlevel^n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/density_matrix.jl#L46-L50">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.partial_tr" href="#YaoAPI.partial_tr"><code>YaoAPI.partial_tr</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">partial_tr(ρ, locs) -&gt; DensityMatrix</code></pre><p>Return a density matrix which is the partial traced on <code>locs</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L285-L289">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoAPI.purify" href="#YaoAPI.purify"><code>YaoAPI.purify</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">purify(r::DensityMatrix; nbit_env::Int=nactive(r)) -&gt; ArrayReg</code></pre><p>Get a purification of target density matrix.</p><p><strong>Examples</strong></p><p>The following example shows how to measure a local operator on the register, reduced density matrix and the purified register. Their results should be consistent.</p><pre><code class="language-julia-repl hljs">julia&gt; reg = ghz_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; r = density_matrix(reg, (2,));

julia&gt; preg = purify(r)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 1/2
    nlevel: 2

julia&gt; isapprox(expect(Z + Y, preg), 0.0; atol=1e-10)
true

julia&gt; isapprox(expect(Z + Y, r), 0.0; atol=1e-10)
true

julia&gt; isapprox(expect(put(3, 2=&gt;(Z + Y)), reg), 0.0; atol=1e-10)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoAPI/src/registers.jl#L724-L756">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.von_neumann_entropy" href="#YaoArrayRegister.von_neumann_entropy"><code>YaoArrayRegister.von_neumann_entropy</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">von_neumann_entropy(reg::AbstractArrayReg, part)
von_neumann_entropy(ρ::DensityMatrix)</code></pre><p>The entanglement entropy between <code>part</code> and the rest part in quantum state <code>reg</code>. If the input is a density matrix, it returns the entropy of a mixed state.</p><p><strong>Example</strong></p><p>The Von Neumann entropy of any segment of GHZ state is <span>$\log 2$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; von_neumann_entropy(ghz_state(3), (1,2))
0.6931471805599612</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L752-L767">source</a></section><section><div><pre><code class="language-julia hljs">von_neumann_entropy(rho) -&gt; Real</code></pre><p>Return the von-Neumann entropy for the input density matrix:</p><p class="math-container">\[-{\rm Tr}(\rho\ln\rho)\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/density_matrix.jl#L124-L132">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoArrayRegister.mutual_information" href="#YaoArrayRegister.mutual_information"><code>YaoArrayRegister.mutual_information</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">mutual_information(register_or_rho, part1, part2)</code></pre><p>Returns the mutual information between subsystems <code>part1</code> and <code>part2</code> of the input quantum register or density matrix:</p><p class="math-container">\[S(\rho_A) + S(\rho_B) - S(\rho_{AB})\]</p><p><strong>Example</strong></p><p>The mutual information of a GHZ state of any two disjoint parts is always equal to <span>$\log 2$</span>.</p><pre><code class="language-julia-repl hljs">julia&gt; mutual_information(ghz_state(4), (1,), (3,4))
0.6931471805599132</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/0eb5dbbd9a4768dd4235e3f6e872953ed7dd046f/lib/YaoArrayRegister/src/register.jl#L729-L746">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../quick-start.html">« Quick Start</a><a class="docs-footer-nextpage" href="blocks.html">Blocks »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.8.1 on <span class="colophon-date" title="Tuesday 4 March 2025 00:23">Tuesday 4 March 2025</span>. Using Julia version 1.11.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

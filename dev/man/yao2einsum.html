<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Tensor Network Backend · Documentation | Yao</title><meta name="title" content="Tensor Network Backend · Documentation | Yao"/><meta property="og:title" content="Tensor Network Backend · Documentation | Yao"/><meta property="twitter:title" content="Tensor Network Backend · Documentation | Yao"/><meta name="description" content="Documentation for Documentation | Yao."/><meta property="og:description" content="Documentation for Documentation | Yao."/><meta property="twitter:description" content="Documentation for Documentation | Yao."/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="https://yaoquantum.org/assets/favicon-light.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Documentation | Yao logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Documentation | Yao</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../quick-start.html">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="registers.html">Quantum Registers</a></li><li><a class="tocitem" href="blocks.html">Blocks</a></li><li><a class="tocitem" href="symbolic.html">Symbolic Computation</a></li><li><a class="tocitem" href="cuda.html">CUDA extension - CuYao</a></li><li><a class="tocitem" href="plot.html">Quantum Circuit Visualization</a></li><li><a class="tocitem" href="automatic_differentiation.html">Automatic Differentiation</a></li><li class="is-active"><a class="tocitem" href="yao2einsum.html">Tensor Network Backend</a><ul class="internal"><li><a class="tocitem" href="#Overview"><span>Overview</span></a></li><li><a class="tocitem" href="#Basic-Usage"><span>Basic Usage</span></a></li><li><a class="tocitem" href="#Tutorial:-Quantum-Fourier-Transform-Example"><span>Tutorial: Quantum Fourier Transform Example</span></a></li><li><a class="tocitem" href="#API-Reference"><span>API Reference</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="paulipropagation.html">Pauli Propagation Backend</a></li><li><a class="tocitem" href="simplification.html">Simplification</a></li><li><a class="tocitem" href="bitbasis.html">BitBasis</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/1.prepare-ghz-state/index.html">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="tocitem" href="../generated/examples/2.qft-phase-estimation/index.html">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="tocitem" href="../generated/examples/3.grover-search/index.html">Grover Search</a></li><li><a class="tocitem" href="../generated/examples/4.shor-algorithm/index.html">Shor&#39;s Algorithm</a></li><li><a class="tocitem" href="../generated/examples/5.shor-9-code/index.html">Shor&#39;s 9 qubit code</a></li><li><a class="tocitem" href="../generated/examples/6.quantum-circuit-born-machine/index.html">Quantum Circuit Born Machine</a></li><li><a class="tocitem" href="../generated/examples/7.variation-quantum-eigen-solver/index.html">Variational Quantum Eigen Solver</a></li><li><a class="tocitem" href="../generated/examples/8.riemannian-gradient-flow/index.html">Riemannian gradient flow optimizer</a></li><li><a class="tocitem" href="../generated/examples/9.noisy-simulation/index.html">Noisy Simulation</a></li></ul></li><li><a class="tocitem" href="../performancetips.html">Performance Tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="yao2einsum.html">Tensor Network Backend</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="yao2einsum.html">Tensor Network Backend</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/QuantumBFS/Yao.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/yao2einsum.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Tensor-Network-Backend"><a class="docs-heading-anchor" href="#Tensor-Network-Backend">Tensor Network Backend</a><a id="Tensor-Network-Backend-1"></a><a class="docs-heading-anchor-permalink" href="#Tensor-Network-Backend" title="Permalink"></a></h1><p>Simulating quantum circuits using tensor networks is a powerful approach that has been extensively studied in quantum computing literature<sup class="footnote-reference"><a id="citeref-Markov2008" href="#footnote-Markov2008">[Markov2008]</a></sup><sup class="footnote-reference"><a id="citeref-Pan2022" href="#footnote-Pan2022">[Pan2022]</a></sup>. The <code>YaoToEinsum</code> package provides a convenient and efficient way to convert Yao circuits into tensor networks, enabling advanced analysis, optimization, and simulation of quantum circuits.</p><h2 id="Overview"><a class="docs-heading-anchor" href="#Overview">Overview</a><a id="Overview-1"></a><a class="docs-heading-anchor-permalink" href="#Overview" title="Permalink"></a></h2><p>Tensor networks represent quantum circuits as collections of interconnected tensors, where quantum gates become tensors and quantum states are represented as tensor contractions. This representation offers several advantages:</p><ul><li><strong>Scalability</strong>: Efficient simulation of certain quantum circuits</li><li><strong>Flexibility</strong>: Easy manipulation and analysis of quantum operations</li><li><strong>Optimization</strong>: Advanced contraction order optimization for better performance</li></ul><h2 id="Basic-Usage"><a class="docs-heading-anchor" href="#Basic-Usage">Basic Usage</a><a id="Basic-Usage-1"></a><a class="docs-heading-anchor-permalink" href="#Basic-Usage" title="Permalink"></a></h2><h3 id="Converting-Circuits-to-Tensor-Networks"><a class="docs-heading-anchor" href="#Converting-Circuits-to-Tensor-Networks">Converting Circuits to Tensor Networks</a><a id="Converting-Circuits-to-Tensor-Networks-1"></a><a class="docs-heading-anchor-permalink" href="#Converting-Circuits-to-Tensor-Networks" title="Permalink"></a></h3><p>The primary function for circuit conversion is:</p><pre><code class="language-julia hljs">using Yao, LuxorGraphPlot

yao2einsum(circuit; initial_state=Dict(), final_state=Dict(), optimizer=TreeSA())</code></pre><p>This function transforms a <a href="https://github.com/QuantumBFS/Yao.jl"><code>Yao</code></a> circuit into a tensor network represented in Einstein summation (einsum) notation, returning a <code>TensorNetwork</code> object.</p><p><strong>Parameters:</strong></p><ul><li><code>initial_state</code>: Dictionary specifying the initial quantum state. Unspecified qubits remain as open indices</li><li><code>final_state</code>: Dictionary specifying the final measurement state. Unspecified qubits remain as open indices  </li><li><code>optimizer</code>: Contraction order optimization algorithm. Default is <code>TreeSA()</code> developed in <sup class="footnote-reference"><a id="citeref-Kalachev2021" href="#footnote-Kalachev2021">[Kalachev2021]</a></sup><sup class="footnote-reference"><a id="citeref-Liu2023" href="#footnote-Liu2023">[Liu2023]</a></sup>. For more optimization algorithms, see <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractionOrders.jl</a></li></ul><h2 id="Tutorial:-Quantum-Fourier-Transform-Example"><a class="docs-heading-anchor" href="#Tutorial:-Quantum-Fourier-Transform-Example">Tutorial: Quantum Fourier Transform Example</a><a id="Tutorial:-Quantum-Fourier-Transform-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Tutorial:-Quantum-Fourier-Transform-Example" title="Permalink"></a></h2><p>In this tutorial, we demonstrate how to convert a Quantum Fourier Transform (QFT) circuit to a tensor network and use it for several common tasks:</p><ol><li>Obtaining the matrix representation of the circuit</li><li>Computing probability amplitudes of specific states</li><li>Computing expectation values of observables</li><li>Simulating noisy circuits with density matrices</li></ol><h3 id="Step-1:-Create-the-Circuit"><a class="docs-heading-anchor" href="#Step-1:-Create-the-Circuit">Step 1: Create the Circuit</a><a id="Step-1:-Create-the-Circuit-1"></a><a class="docs-heading-anchor-permalink" href="#Step-1:-Create-the-Circuit" title="Permalink"></a></h3><p>First, let&#39;s create a 10-qubit Quantum Fourier Transform circuit:</p><pre><code class="language-julia hljs">using Yao, LuxorGraphPlot
using Yao.EasyBuild: qft_circuit

n = 4
circuit = qft_circuit(n)  # Create a QFT circuit for n qubits</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36">nqubits: 4</span>
<span class="sgr34"><span class="sgr1">chain</span></span>
├─ <span class="sgr34"><span class="sgr1">chain</span></span>
│  ├─ <span class="sgr36"><span class="sgr1">put on (1)</span></span>
│  │  └─ H
│  ├─ <span class="sgr31"><span class="sgr1">control(2)</span></span>
│  │  └─ <span class="sgr37"><span class="sgr1">(1,)</span></span> shift(1.5707963267948966)
│  ├─ <span class="sgr31"><span class="sgr1">control(3)</span></span>
│  │  └─ <span class="sgr37"><span class="sgr1">(1,)</span></span> shift(0.7853981633974483)
│  └─ <span class="sgr31"><span class="sgr1">control(4)</span></span>
│     └─ <span class="sgr37"><span class="sgr1">(1,)</span></span> shift(0.39269908169872414)
├─ <span class="sgr34"><span class="sgr1">chain</span></span>
│  ├─ <span class="sgr36"><span class="sgr1">put on (2)</span></span>
│  │  └─ H
│  ├─ <span class="sgr31"><span class="sgr1">control(3)</span></span>
│  │  └─ <span class="sgr37"><span class="sgr1">(2,)</span></span> shift(1.5707963267948966)
│  └─ <span class="sgr31"><span class="sgr1">control(4)</span></span>
│     └─ <span class="sgr37"><span class="sgr1">(2,)</span></span> shift(0.7853981633974483)
├─ <span class="sgr34"><span class="sgr1">chain</span></span>
│  ├─ <span class="sgr36"><span class="sgr1">put on (3)</span></span>
│  │  └─ H
│  └─ <span class="sgr31"><span class="sgr1">control(4)</span></span>
│     └─ <span class="sgr37"><span class="sgr1">(3,)</span></span> shift(1.5707963267948966)
└─ <span class="sgr34"><span class="sgr1">chain</span></span>
   └─ <span class="sgr36"><span class="sgr1">put on (4)</span></span>
      └─ H
</code></pre><h3 id="Case-1:-Matrix-Representation"><a class="docs-heading-anchor" href="#Case-1:-Matrix-Representation">Case 1: Matrix Representation</a><a id="Case-1:-Matrix-Representation-1"></a><a class="docs-heading-anchor-permalink" href="#Case-1:-Matrix-Representation" title="Permalink"></a></h3><p>Now we convert the circuit to a tensor network representation:</p><pre><code class="language-julia hljs">network = Yao.yao2einsum(circuit)  # Convert circuit to tensor network
viznet(network)  # Visualize the network structure</code></pre><img src="yao2einsum-fad181fa.svg" alt="Example block output"/><p>This creates a tensor network where each quantum gate becomes a tensor node, and the connections represent shared indices between tensors.</p><p>We can contract the tensor network to obtain the full matrix representation of the circuit:</p><pre><code class="language-julia hljs"># Contract the network and reshape to get the unitary matrix
matrix_from_network = reshape(Yao.contract(network), 1&lt;&lt;n, 1&lt;&lt;n)
matrix_from_yao = Yao.mat(circuit)

# Verify they are equivalent
matrix_from_network ≈ matrix_from_yao</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Case-2:-Computing-Probability-Amplitudes"><a class="docs-heading-anchor" href="#Case-2:-Computing-Probability-Amplitudes">Case 2: Computing Probability Amplitudes</a><a id="Case-2:-Computing-Probability-Amplitudes-1"></a><a class="docs-heading-anchor-permalink" href="#Case-2:-Computing-Probability-Amplitudes" title="Permalink"></a></h3><p>For many applications, we&#39;re interested in specific probability amplitudes rather than the full matrix. Here we compute the probability amplitude for measuring all qubits in the |0⟩ state after applying the QFT to the |0⟩ state:</p><pre><code class="language-julia hljs"># Create a network with fixed initial and final states
network_with_states = Yao.yao2einsum(circuit;
    initial_state=Dict([i=&gt;0 for i=1:n]),  # Start in |00...0⟩
    final_state=Dict([i=&gt;0 for i=1:n]),    # Measure in |00...0⟩ basis
    optimizer=Yao.YaoToEinsum.TreeSA()
)
viznet(network_with_states)</code></pre><img src="yao2einsum-a221e8a1.svg" alt="Example block output"/><pre><code class="language-julia hljs"># Contract the network to get the amplitude
amplitude_from_network = Yao.contract(network_with_states)[]

# Compare with direct Yao computation
initial_state = Yao.zero_state(n)
final_state = initial_state |&gt; circuit
amplitude_from_yao = (Yao.zero_state(n)&#39; * final_state)[]

amplitude_from_network ≈ amplitude_from_yao</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">true</code></pre><h3 id="Case-3:-Computing-Observable-Expectation-Values"><a class="docs-heading-anchor" href="#Case-3:-Computing-Observable-Expectation-Values">Case 3: Computing Observable Expectation Values</a><a id="Case-3:-Computing-Observable-Expectation-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Case-3:-Computing-Observable-Expectation-Values" title="Permalink"></a></h3><p>Tensor networks are particularly useful for computing expectation values of observables. Here we compute the expectation value of a Pauli-Z operator on the first qubit after applying the QFT:</p><pre><code class="language-julia hljs"># Define the observable (Pauli-Y on first qubit)
observable = put(n, 1=&gt;Y)

# Create tensor network for expectation value computation
# We need to use the `DensityMatrixMode` to sandwich the circuit between the initial state and the observable
network_obs = Yao.yao2einsum(circuit;
    initial_state=Dict(1=&gt;0, 2=&gt;1, 3=&gt;1, 4=&gt;1),  # Start in |0111⟩
    observable = observable,     # Measure expectation value
    mode = DensityMatrixMode()
)
viznet(network_obs)</code></pre><img src="yao2einsum-65c7f507.svg" alt="Example block output"/><p>Contract to get the expectation value</p><pre><code class="language-julia hljs">res_network = real(Yao.contract(network_obs)[])</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.38268343236508956</code></pre><p>Compare with direct Yao computation</p><pre><code class="language-julia hljs">state_after_circuit = product_state(bit&quot;1110&quot;) |&gt; circuit
res_exact = real(expect(observable, state_after_circuit))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0.3826834323650897</code></pre><h3 id="Case-4:-Noisy-Circuit-Simulation"><a class="docs-heading-anchor" href="#Case-4:-Noisy-Circuit-Simulation">Case 4: Noisy Circuit Simulation</a><a id="Case-4:-Noisy-Circuit-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Case-4:-Noisy-Circuit-Simulation" title="Permalink"></a></h3><p>YaoToEinsum supports simulation of noisy quantum circuits using different representations. We demonstrate both density matrix and Pauli basis modes for simulating decoherence:</p><pre><code class="language-julia hljs"># Create a simpler circuit for noisy simulation
n_small = 3
γ = 0.1  # damping parameter

# Create amplitude damping channels
damping_channel = quantum_channel(AmplitudeDampingError(γ))

# Build noisy circuit: gate followed by noise on the same qubits
noisy_circuit = chain(n_small,
    put(1=&gt;X), put(1=&gt;damping_channel),
    put(2=&gt;H), put(2=&gt;damping_channel),
    cnot(1,2), put(1=&gt;damping_channel), put(2=&gt;damping_channel),
    put(3=&gt;Z), put(3=&gt;damping_channel)
)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi"><span class="sgr36">nqubits: 3</span>
<span class="sgr34"><span class="sgr1">chain</span></span>
├─ <span class="sgr36"><span class="sgr1">put on (1)</span></span>
│  └─ X
├─ <span class="sgr36"><span class="sgr1">put on (1)</span></span>
│  └─ <span class="sgr1">kraus_channel</span>
│     ├─ <span class="sgr31">A0</span>
│     └─ <span class="sgr31">A1</span>
├─ <span class="sgr36"><span class="sgr1">put on (2)</span></span>
│  └─ H
├─ <span class="sgr36"><span class="sgr1">put on (2)</span></span>
│  └─ <span class="sgr1">kraus_channel</span>
│     ├─ <span class="sgr31">A0</span>
│     └─ <span class="sgr31">A1</span>
├─ <span class="sgr31"><span class="sgr1">control(1)</span></span>
│  └─ <span class="sgr37"><span class="sgr1">(2,)</span></span> X
├─ <span class="sgr36"><span class="sgr1">put on (1)</span></span>
│  └─ <span class="sgr1">kraus_channel</span>
│     ├─ <span class="sgr31">A0</span>
│     └─ <span class="sgr31">A1</span>
├─ <span class="sgr36"><span class="sgr1">put on (2)</span></span>
│  └─ <span class="sgr1">kraus_channel</span>
│     ├─ <span class="sgr31">A0</span>
│     └─ <span class="sgr31">A1</span>
├─ <span class="sgr36"><span class="sgr1">put on (3)</span></span>
│  └─ Z
└─ <span class="sgr36"><span class="sgr1">put on (3)</span></span>
   └─ <span class="sgr1">kraus_channel</span>
      ├─ <span class="sgr31">A0</span>
      └─ <span class="sgr31">A1</span>
</code></pre><h4 id="Density-Matrix-Mode"><a class="docs-heading-anchor" href="#Density-Matrix-Mode">Density Matrix Mode</a><a id="Density-Matrix-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Density-Matrix-Mode" title="Permalink"></a></h4><p>Simulate using density matrix representation</p><pre><code class="language-julia hljs">network_dm = Yao.yao2einsum(noisy_circuit;
    mode=DensityMatrixMode(),
    initial_state=Dict([i=&gt;0 for i=1:n_small]),
    observable=put(n_small, 1=&gt;Z)
)
viznet(network_dm)</code></pre><img src="yao2einsum-c6428d3e.svg" alt="Example block output"/><p>Contract to get the final density matrix</p><pre><code class="language-julia hljs">res_network = contract(network_dm)[]</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.6199999999999997 + 0.0im</code></pre><p>Compare with direct Yao simulation</p><pre><code class="language-julia hljs">initial_dm = density_matrix(zero_state(n_small))
res_exact = expect(put(n_small, 1=&gt;Z), apply(initial_dm, noisy_circuit))</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">-0.6199999999999998</code></pre><h4 id="Pauli-Basis-Mode"><a class="docs-heading-anchor" href="#Pauli-Basis-Mode">Pauli Basis Mode</a><a id="Pauli-Basis-Mode-1"></a><a class="docs-heading-anchor-permalink" href="#Pauli-Basis-Mode" title="Permalink"></a></h4><p>Simulate using Pauli basis representation</p><pre><code class="language-julia hljs">network_pauli = Yao.yao2einsum(noisy_circuit;
    mode=PauliBasisMode(),
    initial_state=Dict([i=&gt;0 for i=1:n_small]),
    observable=put(n_small, 1=&gt;Z)
)
viznet(network_pauli)</code></pre><img src="yao2einsum-a386cc2b.svg" alt="Example block output"/><p>Contract to get Pauli coefficients and verify the result</p><pre><code class="language-julia hljs">res_pauli = Yao.contract(network_pauli)</code></pre><pre class="documenter-example-output"><code class="nohighlight hljs ansi">0-dimensional Array{ComplexF64, 0}:
-0.6199999999999996 + 0.0im</code></pre><h2 id="API-Reference"><a class="docs-heading-anchor" href="#API-Reference">API Reference</a><a id="API-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#API-Reference" title="Permalink"></a></h2><p>The following functions and types are exported by <code>YaoToEinsum</code>:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoToEinsum.yao2einsum" href="#YaoToEinsum.yao2einsum"><code>YaoToEinsum.yao2einsum</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">yao2einsum(circuit; initial_state=Dict(), final_state=Dict(), optimizer=TreeSA(), mode=VectorMode(), observable=nothing, slicer=nothing)</code></pre><p>Transform a Yao <code>circuit</code> to a generalized tensor network (einsum) notation. The return value is a <a href="yao2einsum.html#YaoToEinsum.TensorNetwork"><code>TensorNetwork</code></a> instance that corresponds to the following tensor network:</p><p>1). If mode is <code>VectorMode()</code>, the tensor network will be like:</p><pre><code class="language-julia hljs">&lt;initial_state| ─── circuit ─── |final_state&gt;</code></pre><p>2). If the mode is <code>DensityMatrixMode()</code>, the tensor network will be like:</p><pre><code class="language-julia hljs">&lt;final_state| ─── circuit ─── |initial_state&gt;&lt;initial_state| ─── circuit ─── |final_state&gt;</code></pre><p>where the <code>circuit</code> may contain noise channels.</p><p>3). In the <code>DensityMatrixMode()</code>, if <code>observable</code> is specified, compute <code>tr(rho, observable)</code> instead.</p><pre><code class="language-julia hljs">┌── circuit ─── |initial_state&gt;&lt;initial_state| ─── circuit ─── observable ──┐
└───────────────────────────────────────────────────────────────────────────┘</code></pre><p>4). <code>PauliBasisMode()</code> is similar to the <code>DensityMatrixMode()</code> mode, but the basis will be rotated to the Pauli basis.</p><p><strong>Arguments</strong></p><ul><li><code>mode</code> is the mapping mode, which can be <code>DensityMatrixMode()</code>, <code>PauliBasisMode()</code>, or <code>VectorMode()</code>.</li><li><code>circuit</code> is a Yao block as the input.</li><li><code>initial_state</code> and <code>final_state</code> are dictionaries to specify the initial states and final states (taking conjugate).<ul><li>In the first interface, a state is specified as an integer, e.g. <code>Dict(1=&gt;1, 2=&gt;1, 3=&gt;0, 4=&gt;1)</code> specifies a product state <code>|1⟩⊗|1⟩⊗|0⟩⊗|1⟩</code>.</li><li>In the second interface, a state is specified as an <code>ArrayReg</code>, e.g. <code>Dict(1=&gt;rand_state(1), 2=&gt;rand_state(1))</code>.</li></ul></li><li><code>observable</code> is a Yao block to specify the observable. If it is specified, the final state must be unspecified.</li></ul><p>If any qubit in initial state or final state is not specified, it will be treated as a free leg in the tensor network.</p><ul><li><code>optimizer</code> is the optimizer used to optimize the tensor network. The default is <code>TreeSA()</code>.</li><li><code>slicer</code> is the slicer used to slice the tensor network and reduce the memory usage, e.g. to reduce the largest tensor rank to 30, use <code>TreeSASlicer(score=OMEinsum.ScoreFunction(sc_target=30))</code>.</li></ul><p>Please check <a href="https://github.com/TensorBFS/OMEinsumContractionOrders.jl">OMEinsumContractors.jl</a> for more information.</p><pre><code class="language-julia-repl hljs">julia&gt; using Yao

julia&gt; c = chain(3, put(3, 2=&gt;X), put(3, 1=&gt;Y), control(3, 1, 3=&gt;Y))
nqubits: 3
chain
├─ put on (2)
│  └─ X
├─ put on (1)
│  └─ Y
└─ control(1)
   └─ (3,) Y


julia&gt; yao2einsum(c; initial_state=Dict(1=&gt;0, 2=&gt;1), final_state=Dict(1=&gt;ArrayReg([0.6, 0.8im]), 2=&gt;1))
TensorNetwork
Time complexity: 2^4.700439718141093
Space complexity: 2^2.0
Read-write complexity: 2^6.0</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/2674c2db6d8703cd5ba11ae29fb96e6453c2c30d/lib/YaoToEinsum/src/circuitmap.jl#L294-L352">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoToEinsum.TensorNetwork" href="#YaoToEinsum.TensorNetwork"><code>YaoToEinsum.TensorNetwork</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">TensorNetwork</code></pre><p>A (generalized) tensor network representation of a quantum circuit.</p><p><strong>Fields</strong></p><ul><li><code>code::AbstractEinsum</code>: The einsum code.</li><li><code>tensors::Vector</code>: The tensors in the network.</li><li><code>label_to_qubit::Dict{Int, Int}</code>: Map from variable label to qubit index (negative for dual, absent for non-qubit)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/2674c2db6d8703cd5ba11ae29fb96e6453c2c30d/lib/YaoToEinsum/src/Core.jl#L6-L15">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.optimize_code" href="#OMEinsumContractionOrders.optimize_code"><code>OMEinsumContractionOrders.optimize_code</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">optimize_code(c::TensorNetwork, optimizer=TreeSA(); slicer=nothing)</code></pre><p>Optimize the code of the tensor network.</p><p><strong>Arguments</strong></p><ul><li><code>c::TensorNetwork</code>: The tensor network.</li><li><code>optimizer::Optimizer</code>: The optimizer to use, default is <code>OMEinsum.TreeSA()</code>.</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>slicer</code>: The slicer to use, default is <code>nothing</code>. It can be e.g. <code>OMEinsum.TreeSASlicer(score=OMEinsum.ScoreFunction(sc_target=30))</code>.</li></ul><p>For more, please check <a href="https://tensorbfs.github.io/OMEinsumContractionOrders.jl/dev/">OMEinsumContractionOrders documentation</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/2674c2db6d8703cd5ba11ae29fb96e6453c2c30d/lib/YaoToEinsum/src/Core.jl#L48-L61">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="OMEinsumContractionOrders.contraction_complexity" href="#OMEinsumContractionOrders.contraction_complexity"><code>OMEinsumContractionOrders.contraction_complexity</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contraction_complexity(c::TensorNetwork)</code></pre><p>Return the contraction complexity of the tensor network.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/2674c2db6d8703cd5ba11ae29fb96e6453c2c30d/lib/YaoToEinsum/src/Core.jl#L68-L72">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="YaoToEinsum.contract" href="#YaoToEinsum.contract"><code>YaoToEinsum.contract</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">contract(c::TensorNetwork)</code></pre><p>Contract the tensor network, and return the result tensor.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/2674c2db6d8703cd5ba11ae29fb96e6453c2c30d/lib/YaoToEinsum/src/Core.jl#L39-L43">source</a></section></article><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-Markov2008"><a class="tag is-link" href="#citeref-Markov2008">Markov2008</a>Markov, Igor L., and Yaoyun Shi. &quot;Simulating quantum computation by contracting tensor networks.&quot; SIAM Journal on Computing 38.3 (2008): 963-981.</li><li class="footnote" id="footnote-Pan2022"><a class="tag is-link" href="#citeref-Pan2022">Pan2022</a>Pan, Feng, and Pan Zhang. &quot;Simulation of quantum circuits using the big-batch tensor network method.&quot; Physical Review Letters 128.3 (2022): 030501.</li><li class="footnote" id="footnote-Kalachev2021"><a class="tag is-link" href="#citeref-Kalachev2021">Kalachev2021</a>Kalachev, Gleb, Pavel Panteleev, and Man-Hong Yung. &quot;Recursive multi-tensor contraction for xeb verification of quantum circuits.&quot; arXiv preprint arXiv:2108.05665 (2021).</li><li class="footnote" id="footnote-Liu2023"><a class="tag is-link" href="#citeref-Liu2023">Liu2023</a>Liu, Jin-Guo, et al. &quot;Computing solution space properties of combinatorial optimization problems via generic tensor networks.&quot; SIAM Journal on Scientific Computing 45.3 (2023): A1239-A1270.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="automatic_differentiation.html">« Automatic Differentiation</a><a class="docs-footer-nextpage" href="paulipropagation.html">Pauli Propagation Backend »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.15.0 on <span class="colophon-date" title="Friday 24 October 2025 01:58">Friday 24 October 2025</span>. Using Julia version 1.12.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>

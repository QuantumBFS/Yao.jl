<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Blocks · Documentation | Yao</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/indigo.css" rel="stylesheet" type="text/css"/><link href="https://yaoquantum.org/assets/favicon-light.ico" rel="icon" type="image/x-icon"/></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../index.html"><img src="../assets/logo.png" alt="Documentation | Yao logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../index.html">Documentation | Yao</a></span></div><form class="docs-search" action="../search.html"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../index.html">Home</a></li><li><a class="tocitem" href="../quick-start.html">Quick Start</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="registers.html">Quantum Registers</a></li><li class="is-active"><a class="tocitem" href="blocks.html">Blocks</a><ul class="internal"><li><a class="tocitem" href="#Primitive-Blocks"><span>Primitive Blocks</span></a></li><li><a class="tocitem" href="#Composite-Blocks"><span>Composite Blocks</span></a></li><li><a class="tocitem" href="#Error-and-Exceptions"><span>Error and Exceptions</span></a></li><li><a class="tocitem" href="#Extending-Blocks"><span>Extending Blocks</span></a></li><li><a class="tocitem" href="#APIs"><span>APIs</span></a></li></ul></li><li><a class="tocitem" href="symbolic.html">Symbolic Computation</a></li><li><a class="tocitem" href="automatic_differentiation.html">Automatic Differentiation</a></li><li><a class="tocitem" href="simplification.html">Simplification</a></li><li><a class="tocitem" href="bitbasis.html">BitBasis</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../generated/examples/1.prepare-ghz-state/index.html">Prepare Greenberger–Horne–Zeilinger state with Quantum Circuit</a></li><li><a class="tocitem" href="../generated/examples/2.qft-phase-estimation/index.html">Quantum Fourier Transformation and Phase Estimation</a></li><li><a class="tocitem" href="../generated/examples/3.grover-search/index.html">Grover Search</a></li><li><a class="tocitem" href="../generated/examples/4.shor-algorithm/index.html">Shor&#39;s Algorithm</a></li><li><a class="tocitem" href="../generated/examples/5.shor-9-code/index.html">Shor&#39;s 9 qubit code</a></li><li><a class="tocitem" href="../generated/examples/6.quantum-circuit-born-machine/index.html">Quantum Circuit Born Machine</a></li><li><a class="tocitem" href="../generated/examples/7.variation-quantum-eigen-solver/index.html">Variational Quantum Eigen Solver</a></li></ul></li><li><a class="tocitem" href="../performancetips.html">Performance Tips</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href="blocks.html">Blocks</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href="blocks.html">Blocks</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/QuantumBFS/Yao.jl/blob/master/docs/src/man/blocks.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Blocks"><a class="docs-heading-anchor" href="#Blocks">Blocks</a><a id="Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Blocks" title="Permalink"></a></h1><p><strong>Blocks</strong> are the basic building blocks of a quantum circuit in Yao. It simply means a quantum operator, thus, all the blocks have matrices in principal and one can get its matrix by <a href="blocks.html#YaoAPI.mat-Tuple{AbstractBlock}"><code>mat</code></a>. The basic blocks required to build an arbitrary quantum circuit is defined in the component package <a href="man/@ref"><code>YaoBlocks</code></a>.</p><p>Block Tree serves as an intermediate representation for Yao to analysis, optimize the circuit, then it will be lowered to instructions like for simulations, blocks will be lowered to <a href="registers.html#YaoAPI.instruct!"><code>instruct!</code></a> calls.</p><p>The structure of blocks is the same with a small type system, it consists of two basic kinds of blocks: <a href="man/@ref"><code>CompositeBlock</code></a> (like composite types), and <a href="man/@ref"><code>PrimitiveBlock</code></a> (like primitive types). By combining these two kinds of blocks together, we&#39;ll be able to construct a quantum circuit and represent it in a tree data structure.</p><h2 id="Primitive-Blocks"><a class="docs-heading-anchor" href="#Primitive-Blocks">Primitive Blocks</a><a id="Primitive-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Primitive-Blocks" title="Permalink"></a></h2><p>Primitive blocks are subtypes of <a href="man/@ref"><code>PrimitiveBlock</code></a>, they are the leaf nodes in a block tree, thus primitive types do not have subtypes.</p><p>We provide the following primitive blocks:</p><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.GeneralMatrixBlock" href="#YaoBlocks.GeneralMatrixBlock"><code>YaoBlocks.GeneralMatrixBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GeneralMatrixBlock{D, MT} &lt;: PrimitiveBlock{D}
GeneralMatrixBlock{D}(m, n, A, tag=&quot;matblock(...)&quot;)
GeneralMatrixBlock(A; nlevel=2, tag=&quot;matblock(...)&quot;)</code></pre><p>General matrix gate wraps a matrix operator to quantum gates. This is the most general form of a quantum gate.</p><p><strong>Arguments</strong></p><ul><li><code>m</code> and <code>n</code> are the number of dits in row and column.</li><li><code>A</code> is a matrix.</li><li><code>tag</code> is the printed information.</li><li><code>D</code> and <code>nlevel</code> are the number of levels in each qudit.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/general_matrix_gate.jl#L3-L17">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.IdentityGate" href="#YaoBlocks.IdentityGate"><code>YaoBlocks.IdentityGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">IdentityGate{D} &lt;: TrivialGate{D}</code></pre><p>The identity gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/identity_gate.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Measure" href="#YaoBlocks.Measure"><code>YaoBlocks.Measure</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Measure{D,K, OT, LT, PT, RNG} &lt;: PrimitiveBlock{D}
Measure(n::Int; rng=Random.GLOBAL_RNG, operator=ComputationalBasis(), locs=1:n, resetto=nothing, remove=false, nlevel=2)</code></pre><p>Measure operator, currently only qudits are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/measure.jl#L4-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Measure-Union{Tuple{Int64}, Tuple{RNG}, Tuple{OT}} where {OT, RNG}" href="#YaoBlocks.Measure-Union{Tuple{Int64}, Tuple{RNG}, Tuple{OT}} where {OT, RNG}"><code>YaoBlocks.Measure</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Measure(n::Int; rng=Random.GLOBAL_RNG, operator=ComputationalBasis(), locs=AllLocs(), resetto=nothing, remove=false)</code></pre><p>Create a <code>Measure</code> block with number of qudits <code>n</code>.</p><p><strong>Examples</strong></p><p>You can create a <code>Measure</code> block on given basis (default is the computational basis).</p><pre><code class="language-julia-repl hljs">julia&gt; Measure(4)
Measure(4)</code></pre><p>Or you could specify which qudits you are going to measure</p><pre><code class="language-julia-repl hljs">julia&gt; Measure(4; locs=1:3)
Measure(4;locs=(1, 2, 3))</code></pre><p>by default this will collapse the current register to measure results.</p><pre><code class="language-julia-repl hljs">julia&gt; r = normalize!(arrayreg(bit&quot;000&quot;) + arrayreg(bit&quot;111&quot;))
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; state(r)
8×1 Matrix{ComplexF64}:
 0.7071067811865475 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
                0.0 + 0.0im
 0.7071067811865475 + 0.0im

julia&gt; r |&gt; Measure(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; state(r)
8×1 Matrix{ComplexF64}:
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 0.0 + 0.0im
 1.0 + 0.0im</code></pre><p>But you can also specify the target bit configuration you want to collapse to with keyword <code>resetto</code>.</p><p>```jldoctest; setup=:(using Yao) julia&gt; m = Measure(4; resetto=bit&quot;0101&quot;) Measure(4;postprocess=ResetTo{BitStr{4,Int64}}(0101 ₍₂₎))</p><p>julia&gt; m.postprocess ResetTo{BitStr{4,Int64}}(0101 ₍₂₎)```</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/measure.jl#L72-L137">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.PhaseGate" href="#YaoBlocks.PhaseGate"><code>YaoBlocks.PhaseGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PhaseGate</code></pre><p>Global phase gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/phase_gate.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.RotationGate" href="#YaoBlocks.RotationGate"><code>YaoBlocks.RotationGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RotationGate{D,T,GT&lt;:AbstractBlock{D}} &lt;: PrimitiveBlock{D}</code></pre><p>RotationGate, with GT both hermitian and isreflexive.</p><p><strong>Definition</strong></p><p>Expression <code>rot(G, θ)</code> defines the following gate</p><p class="math-container">\[\cos \frac{\theta}{2}I - i \sin \frac{\theta}{2} G\]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/rotation_gate.jl#L3-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.ShiftGate" href="#YaoBlocks.ShiftGate"><code>YaoBlocks.ShiftGate</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ShiftGate &lt;: PrimitiveBlock</code></pre><p>Phase shift gate.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/shift_gate.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.TimeEvolution" href="#YaoBlocks.TimeEvolution"><code>YaoBlocks.TimeEvolution</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">TimeEvolution{D, TT, GT} &lt;: PrimitiveBlock{D}</code></pre><p>TimeEvolution, where GT is block type. input matrix should be hermitian.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p><code>TimeEvolution</code> contructor check hermicity of the input block by default, but sometimes it can be slow. Turn off the check manually by specifying optional parameter <code>check_hermicity = false</code>.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/time_evolution.jl#L3-L13">source</a></section></article><h2 id="Composite-Blocks"><a class="docs-heading-anchor" href="#Composite-Blocks">Composite Blocks</a><a id="Composite-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Composite-Blocks" title="Permalink"></a></h2><p>Composite blocks are subtypes of <a href="man/@ref"><code>CompositeBlock</code></a>, they are the composition of blocks.</p><p>We provide the following composite blocks:</p><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.AbstractAdd" href="#YaoBlocks.AbstractAdd"><code>YaoBlocks.AbstractAdd</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">AbstractAdd{D} &lt;: CompositeBlock{D}</code></pre><p>The abstract add interface, aimed to support Hamiltonian types.</p><p><strong>Required Interfaces</strong></p><ul><li><code>chsubblocks</code></li><li><code>subblocks</code></li></ul><p><strong>Provides</strong></p><ul><li><code>unsafe_apply!</code> and its backward</li><li><code>mat</code> and its backward</li><li><code>adjoint</code></li><li><code>occupied_locs</code></li><li><code>getindex</code> over dit strings</li><li><code>ishermitian</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/add.jl#L4-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Add" href="#YaoBlocks.Add"><code>YaoBlocks.Add</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Add{D} &lt;: AbstractAdd{D}
Add(blocks::AbstractBlock...) -&gt; Add</code></pre><p>Type for block addition.</p><pre><code class="language-julia-repl hljs">julia&gt; X + X
nqubits: 1
+
├─ X
└─ X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/add.jl#L23-L36">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.CachedBlock" href="#YaoBlocks.CachedBlock"><code>YaoBlocks.CachedBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CachedBlock{ST, BT, D} &lt;: TagBlock{BT, D}</code></pre><p>A label type that tags an instance of type <code>BT</code>. It forwards every methods of the block it contains, except <a href="blocks.html#YaoAPI.mat-Tuple{AbstractBlock}"><code>mat</code></a> and <a href="man/@ref"><code>apply!</code></a>, it will cache the matrix form whenever the program has.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/tag/cache.jl#L38-L45">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.ChainBlock" href="#YaoBlocks.ChainBlock"><code>YaoBlocks.ChainBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">ChainBlock{D} &lt;: CompositeBlock{D}</code></pre><p><code>ChainBlock</code> is a basic construct tool to create user defined blocks horizontically. It is a <code>Vector</code> like composite type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/chain.jl#L3-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Daggered" href="#YaoBlocks.Daggered"><code>YaoBlocks.Daggered</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Daggered{BT, D} &lt;: TagBlock{BT,D}</code></pre><p>Wrapper block allowing to execute the inverse of a block of quantum circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/tag/dagger.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Daggered-Union{Tuple{BT}, Tuple{D}} where {D, BT&lt;:AbstractBlock{D}}" href="#YaoBlocks.Daggered-Union{Tuple{BT}, Tuple{D}} where {D, BT&lt;:AbstractBlock{D}}"><code>YaoBlocks.Daggered</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Daggered(block)</code></pre><p>Create a <a href="blocks.html#YaoBlocks.Daggered"><code>Daggered</code></a> block. Let <span>$G$</span> be a input block, <code>G&#39;</code> or <code>Daggered(block)</code> in code represents <span>$G^\dagger$</span>.</p><p><strong>Examples</strong></p><p>The inverse QFT is not hermitian, thus it will be tagged with a <code>Daggered</code> block.</p><pre><code class="language-julia-repl hljs">julia&gt; A(i, j) = control(i, j=&gt;shift(2π/(1&lt;&lt;(i-j+1))));

julia&gt; B(n, i) = chain(n, i==j ? put(i=&gt;H) : A(j, i) for j in i:n);

julia&gt; qft(n) = chain(B(n, i) for i in 1:n);

julia&gt; struct QFT &lt;: PrimitiveBlock{2} n::Int end

julia&gt; YaoBlocks.nqudits(q::QFT) = q.n


julia&gt; circuit(q::QFT) = qft(nqubits(q));

julia&gt; YaoBlocks.mat(x::QFT) = mat(circuit(x));

julia&gt; QFT(2)&#39;
 [†]QFT</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/tag/dagger.jl#L12-L41">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.KronBlock" href="#YaoBlocks.KronBlock"><code>YaoBlocks.KronBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">KronBlock{D,M,MT&lt;:NTuple{M,Any}} &lt;: CompositeBlock{D}</code></pre><p>composite block that combine blocks by kronecker product.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/kron.jl#L5-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.PutBlock" href="#YaoBlocks.PutBlock"><code>YaoBlocks.PutBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PutBlock{D,C,GT&lt;:AbstractBlock} &lt;: AbstractContainer{GT,D}</code></pre><p>Type for putting a block at given locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/put_block.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.RepeatedBlock" href="#YaoBlocks.RepeatedBlock"><code>YaoBlocks.RepeatedBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">RepeatedBlock{D,C,GT&lt;:AbstractBlock} &lt;: AbstractContainer{GT,D}</code></pre><p>Repeat the same block on given locations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/repeated.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Scale" href="#YaoBlocks.Scale"><code>YaoBlocks.Scale</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Scale{S &lt;: Union{Number, Val}, D, BT &lt;: AbstractBlock{D}} &lt;: TagBlock{BT, D}
Scale(factor, block)</code></pre><p>Multiply a block with a scalar factor, which can be a number or a <code>Val</code>. If the factor is a number, it is regarded as a parameter that can be changed dynamically. If the factor is a <code>Val</code>, it is regarded as a constant.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; 2 * X
[scale: 2] X

julia&gt; im * Z
[+im] Z

julia&gt; -im * Z
[-im] Z

julia&gt; -Z
[-] Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/tag/scale.jl#L3-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Subroutine" href="#YaoBlocks.Subroutine"><code>YaoBlocks.Subroutine</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">Subroutine{D, BT &lt;: AbstractBlock, C} &lt;: AbstractContainer{BT, D}</code></pre><p>Subroutine node on given locations. This allows you to shoehorn a smaller circuit to a larger one.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/subroutine.jl#L3-L8">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.UnitaryChannel" href="#YaoBlocks.UnitaryChannel"><code>YaoBlocks.UnitaryChannel</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">UnitaryChannel{D, W&lt;:AbstractVector} &lt;: CompositeBlock{D}
UnitaryChannel(operators, probs)</code></pre><p>Create a unitary channel, where <code>probs</code> is a real vector that sum up to 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/unitary_channel.jl#L7-L12">source</a></section></article><h2 id="Error-and-Exceptions"><a class="docs-heading-anchor" href="#Error-and-Exceptions">Error and Exceptions</a><a id="Error-and-Exceptions-1"></a><a class="docs-heading-anchor-permalink" href="#Error-and-Exceptions" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.islocs_conflict-Tuple{Union{Vector{T}, Tuple{Vararg{T, N}} where N} where T}" href="#YaoBlocks.islocs_conflict-Tuple{Union{Vector{T}, Tuple{Vararg{T, N}} where N} where T}"><code>YaoBlocks.islocs_conflict</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islocs_conflict(locs) -&gt; Bool</code></pre><p>Check if the input locations has conflicts.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/error.jl#L56-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.islocs_inbounds-Tuple{Int64, Union{Vector{T}, Tuple{Vararg{T, N}} where N} where T}" href="#YaoBlocks.islocs_inbounds-Tuple{Int64, Union{Vector{T}, Tuple{Vararg{T, N}} where N} where T}"><code>YaoBlocks.islocs_inbounds</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">islocs_inbounds(n, locs) -&gt; Bool</code></pre><p>Check if the input locations are inside given bounds <code>n</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/error.jl#L44-L48">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.@assert_locs_inbounds-Tuple{Any, Any, Vararg{Any}}" href="#YaoBlocks.@assert_locs_inbounds-Tuple{Any, Any, Vararg{Any}}"><code>YaoBlocks.@assert_locs_inbounds</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@assert_locs_inbounds &lt;number of total qudits&gt; &lt;locations list&gt; [&lt;msg&gt;]</code></pre><p>Assert if all the locations are inbounds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/error.jl#L92-L96">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.@assert_locs_safe-Tuple{Any, Any, Vararg{Any}}" href="#YaoBlocks.@assert_locs_safe-Tuple{Any, Any, Vararg{Any}}"><code>YaoBlocks.@assert_locs_safe</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@assert_locs_safe &lt;number of total qudits&gt; &lt;locations list&gt; [&lt;msg&gt;]</code></pre><p>Assert if all the locations are:     - inbounds.     - do not have any conflict.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/error.jl#L106-L112">source</a></section></article><h2 id="Extending-Blocks"><a class="docs-heading-anchor" href="#Extending-Blocks">Extending Blocks</a><a id="Extending-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Extending-Blocks" title="Permalink"></a></h2><p>Blocks are defined as a sub-type system inside Julia, you could extend it by defining new Julia types by subtyping abstract types we provide. But we also provide some handy tools to help you create your own blocks.</p><h3 id="Define-Custom-Constant-Blocks"><a class="docs-heading-anchor" href="#Define-Custom-Constant-Blocks">Define Custom Constant Blocks</a><a id="Define-Custom-Constant-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Custom-Constant-Blocks" title="Permalink"></a></h3><p>Constant blocks are used quite often and in numerical simulation we would expect it to be a real constant in the program, which means it won&#39;t allocate new memory when we try to get its matrix for several times, and it won&#39;t change with parameters.</p><p>In Yao, you can simply define a constant block with <a href="man/@ref"><code>@const_gate</code></a>, with the corresponding matrix:</p><pre><code class="nohighlight hljs ansi" style="display:block;"></code><br/><code class="language-julia-repl hljs" style="display:block;">julia&gt; @const_gate Rand = rand(ComplexF64, 4, 4)</code><code class="nohighlight hljs ansi" style="display:block;"></code></pre><p>This will automatically create a type <code>RandGate{T}</code> and a constant binding <code>Rand</code> to the instance of <code>RandGate{ComplexF64}</code>, and it will also bind a Julia constant for the given matrix, so when you call <code>mat(Rand)</code>, no allocation will happen.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated mat(Rand)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: mat not defined</code></pre><p>If you want to use other data type like <code>ComplexF32</code>, you could directly call <code>Rand(ComplexF32)</code>, which will create a new instance with data type <code>ComplexF32</code>.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; Rand(ComplexF32)</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Rand not defined</code></pre><p>But remember this won&#39;t bind the matrix, it only binds <strong>the matrix you give</strong></p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @allocated mat(Rand(ComplexF32))</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: UndefVarError: Rand not defined</code></pre><p>so if you want to make the matrix call <code>mat</code> for <code>ComplexF32</code> to have zero allocation as well, you need to do it explicitly.</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; @const_gate Rand::ComplexF32</code><code class="nohighlight hljs ansi" style="display:block;">ERROR: LoadError: UndefVarError: @const_gate not defined
in expression starting at REPL[1]:1</code></pre><h3 id="Define-Custom-Blocks"><a class="docs-heading-anchor" href="#Define-Custom-Blocks">Define Custom Blocks</a><a id="Define-Custom-Blocks-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Custom-Blocks" title="Permalink"></a></h3><p>Primitive blocks are the most basic block to build a quantum circuit, if a primitive block has a certain structure, like containing tweakable parameters, it cannot be defined as a constant, thus create a new type by subtyping <a href="man/@ref"><code>PrimitiveBlock</code></a> is necessary</p><pre><code class="language-julia hljs">using YaoBlocks

mutable struct PhaseGate{T &lt;: Real} &lt;: PrimitiveBlock{1}
    theta::T
end</code></pre><p>If your insterested block is a composition of other blocks, you should define a <a href="man/@ref"><code>CompositeBlock</code></a>, e.g</p><pre><code class="language-julia hljs">struct ChainBlock{N} &lt;: CompositeBlock{N}
    blocks::Vector{AbstractBlock{N}}
end</code></pre><p>Besides types, there are several interfaces you could define for a block, but don&#39;t worry, they should just error if it doesn&#39;t work.</p><h3 id="Define-the-matrix"><a class="docs-heading-anchor" href="#Define-the-matrix">Define the matrix</a><a id="Define-the-matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Define-the-matrix" title="Permalink"></a></h3><p>The matrix form of a block is the minimal requirement to make a custom block functional, defining it is super simple, e.g for phase gate:</p><pre><code class="language-julia hljs">mat(::Type{T}, gate::PhaseGate) where T = exp(T(im * gate.theta)) * Matrix{Complex{T}}(I, 2, 2)</code></pre><p>Or for composite blocks, you could just calculate the matrix by call <code>mat</code> on its subblocks.</p><pre><code class="language-julia hljs">mat(::Type{T}, c::ChainBlock) where T = prod(x-&gt;mat(T, x), reverse(c.blocks))</code></pre><p>The rest will just work, but might be slow since you didn&#39;t define any specification for this certain block.</p><h3 id="Define-how-blocks-are-applied-to-registers"><a class="docs-heading-anchor" href="#Define-how-blocks-are-applied-to-registers">Define how blocks are applied to registers</a><a id="Define-how-blocks-are-applied-to-registers-1"></a><a class="docs-heading-anchor-permalink" href="#Define-how-blocks-are-applied-to-registers" title="Permalink"></a></h3><p>Although, having its matrix is already enough for applying a block to register, we could improve the performance or dispatch to other actions by overloading <a href="man/@ref"><code>apply!</code></a> interface, e.g we can use specialized instruction to make X gate (a builtin gate defined <code>@const_gate</code>) faster:</p><pre><code class="language-julia hljs">function apply!(r::ArrayReg, x::XGate)
    nactive(r) == 1 || throw(QubitMismatchError(&quot;register size $(nactive(r)) mismatch with block size $N&quot;))
    instruct!(matvec(r.state), Val(:X), (1, ))
    return r
end</code></pre><p>In Yao, this interface allows us to provide more aggressive specialization on different patterns of quantum circuits to accelerate the simulation etc.</p><h3 id="Define-Parameters"><a class="docs-heading-anchor" href="#Define-Parameters">Define Parameters</a><a id="Define-Parameters-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Parameters" title="Permalink"></a></h3><p>If you want to use some member of the block to be parameters, you need to declare them explicitly</p><pre><code class="language-julia hljs">niparams(::Type{&lt;:PhaseGate}) = 1
getiparams(x::PhaseGate) = x.theta
setiparams!(r::PhaseGate, param::Real) = (r.theta = param; r)</code></pre><h3 id="Define-Adjoint"><a class="docs-heading-anchor" href="#Define-Adjoint">Define Adjoint</a><a id="Define-Adjoint-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Adjoint" title="Permalink"></a></h3><p>Since blocks are actually quantum operators, it makes sense to call their <code>adjoint</code> as well. We provide <a href="blocks.html#YaoBlocks.Daggered"><code>Daggered</code></a> for general purpose, but some blocks may have more specific transformation rules for adjoints, e.g</p><pre><code class="language-julia hljs">Base.adjoint(x::PhaseGate) = PhaseGate(-x.theta)</code></pre><h3 id="Define-Cache-Keys"><a class="docs-heading-anchor" href="#Define-Cache-Keys">Define Cache Keys</a><a id="Define-Cache-Keys-1"></a><a class="docs-heading-anchor-permalink" href="#Define-Cache-Keys" title="Permalink"></a></h3><p>To enable cache, you should define <code>cache_key</code>, e.g for phase gate, we only cares about its phase, instead of the whole instance</p><pre><code class="language-julia hljs">cache_key(gate::PhaseGate) = gate.theta</code></pre><h2 id="APIs"><a class="docs-heading-anchor" href="#APIs">APIs</a><a id="APIs-1"></a><a class="docs-heading-anchor-permalink" href="#APIs" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="Base.:|&gt;-Tuple{AbstractRegister, AbstractBlock}" href="#Base.:|&gt;-Tuple{AbstractRegister, AbstractBlock}"><code>Base.:|&gt;</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">|&gt;(register, circuit) -&gt; register</code></pre><p>Apply a quantum circuits to register, which modifies the register directly.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">julia&gt; arrayreg(bit&quot;0&quot;) |&gt; X |&gt; Y</code></pre><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p><code>|&gt;</code> is equivalent to <a href="man/@ref"><code>apply!</code></a>, which means it has side effects. You need to use <a href="man/@ref"><code>apply</code></a> if you do not want to change it in-place.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L52-L67">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron-Tuple{Int64, Vararg{Pair{&lt;:Any, &lt;:AbstractBlock}}}" href="#Base.kron-Tuple{Int64, Vararg{Pair{&lt;:Any, &lt;:AbstractBlock}}}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron(n, locs_and_blocks::Pair{&lt;:Any, &lt;:AbstractBlock}...) -&gt; KronBlock</code></pre><p>Returns a <code>n</code>-qudit <a href="blocks.html#YaoBlocks.KronBlock"><code>KronBlock</code></a>. The inputs contains a list of location-block pairs, where a location can be an integer or a range. It is conceptually a <a href="blocks.html#YaoBlocks.chain-Tuple{Int64}"><code>chain</code></a> of <a href="blocks.html#YaoBlocks.put-Tuple{Pair}"><code>put</code></a> block without address conflicts, but it has a richer type information that can be useful for various purposes such as more efficient <a href="blocks.html#YaoAPI.mat-Tuple{AbstractBlock}"><code>mat</code></a> function.</p><p>Let <span>$I$</span> be a <span>$2\times 2$</span> identity matrix, <span>$G$</span> and <span>$H$</span> be two <span>$2\times 2$</span> matrix, the matrix representation of <code>kron(n, i=&gt;G, j=&gt;H)</code> (assume <span>$j &gt; i$</span>) is defined as</p><p class="math-container">\[I^{\otimes n-j} \otimes H \otimes I^{\otimes j-i-1} \otimes G \otimes I^{i-1}\]</p><p>For multiple locations, the expression can be complicated.</p><p><strong>Examples</strong></p><p>Use <code>kron</code> to construct a <code>KronBlock</code>, it will put an <code>X</code> gate on the <code>1</code>st qubit, and a <code>Y</code> gate on the <code>3</code>rd qubit.</p><pre><code class="language-julia-repl hljs">julia&gt; kron(4, 1=&gt;X, 3=&gt;Y)
nqubits: 4
kron
├─ 1=&gt;X
└─ 3=&gt;Y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/kron.jl#L60-L88">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron-Tuple{Vararg{AbstractBlock}}" href="#Base.kron-Tuple{Vararg{AbstractBlock}}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron(blocks::AbstractBlock...)
kron(n, itr)</code></pre><p>Return a <a href="blocks.html#YaoBlocks.KronBlock"><code>KronBlock</code></a>, with total number of qubits <code>n</code>, and <code>blocks</code> should use all the locations on <code>n</code> wires in quantum circuits.</p><p><strong>Examples</strong></p><p>You can use kronecker product to composite small blocks to a large blocks.</p><pre><code class="language-julia-repl hljs">julia&gt; kron(X, Y, Z, Z)
nqubits: 4
kron
├─ 1=&gt;X
├─ 2=&gt;Y
├─ 3=&gt;Z
└─ 4=&gt;Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/kron.jl#L92-L112">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.kron-Tuple{Vararg{Pair{&lt;:Any, &lt;:AbstractBlock}}}" href="#Base.kron-Tuple{Vararg{Pair{&lt;:Any, &lt;:AbstractBlock}}}"><code>Base.kron</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">kron(blocks...) -&gt; f(n)
kron(itr) -&gt; f(n)</code></pre><p>Return a lambda, which will take the total number of qubits as input.</p><p><strong>Examples</strong></p><p>If you don&#39;t know the number of qubit yet, or you are just too lazy, it is fine.</p><pre><code class="language-julia-repl hljs">julia&gt; kron(put(1=&gt;X) for _ in 1:2)
(n -&gt; kron(n, ((n  -&gt;  put(n, 1 =&gt; X)), (n  -&gt;  put(n, 1 =&gt; X)))...))

julia&gt; kron(X for _ in 1:2)
nqubits: 2
kron
├─ 1=&gt;X
└─ 2=&gt;X

julia&gt; kron(1=&gt;X, 3=&gt;Y)
(n -&gt; kron(n, (1 =&gt; X, 3 =&gt; Y)...))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/kron.jl#L133-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat-Tuple{AbstractBlock, Any}" href="#Base.repeat-Tuple{AbstractBlock, Any}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat(x::AbstractBlock, locs)</code></pre><p>Lazy curried version of <a href="blocks.html#Base.repeat-Tuple{AbstractBlock, Any}"><code>repeat</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/repeated.jl#L113-L117">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.repeat-Tuple{Int64, AbstractBlock, Vararg{Int64}}" href="#Base.repeat-Tuple{Int64, AbstractBlock, Vararg{Int64}}"><code>Base.repeat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">repeat(n, subblock::AbstractBlock[, locs]) -&gt; RepeatedBlock{n}</code></pre><p>Create a <code>n</code>-qudit <a href="blocks.html#YaoBlocks.RepeatedBlock"><code>RepeatedBlock</code></a> block, which is conceptually a [<code>kron</code>] block with all gates being the same. If <code>locs</code> is provided, repeat on <code>locs</code>, otherwise repeat on all locations. Let <span>$G$</span> be a <span>$2\times 2$</span> matrix, the matrix representation of <code>repeat(n, X)</code> is</p><p class="math-container">\[X^{\otimes n}\]</p><p>The <code>RepeatedBlock</code> can be used to accelerate repeated applying certain gate types: <code>X</code>, <code>Y</code>, <code>Z</code>, <code>S</code>, <code>T</code>, <code>Sdag</code>, and <code>Tdag</code>.</p><p><strong>Examples</strong></p><p>This will create a repeat block which puts 4 X gates on each location.</p><pre><code class="language-julia-repl hljs">julia&gt; repeat(4, X)
nqubits: 4
repeat on (1, 2, 3, 4)
└─ X</code></pre><p>You can also specify the location</p><pre><code class="language-julia-repl hljs">julia&gt; repeat(4, X, (1, 2))
nqubits: 4
repeat on (1, 2)
└─ X</code></pre><p>But repeat won&#39;t copy the gate, thus, if it is a gate with parameter, e.g a <code>phase(0.1)</code>, the parameter will change simultaneously.</p><pre><code class="language-julia-repl hljs">julia&gt; g = repeat(4, phase(0.1))
nqubits: 4
repeat on (1, 2, 3, 4)
└─ phase(0.1)

julia&gt; g.content
phase(0.1)

julia&gt; g.content.theta = 0.2
0.2

julia&gt; g
nqubits: 4
repeat on (1, 2, 3, 4)
└─ phase(0.2)</code></pre><p>Repeat over certain gates will provide speed up.</p><pre><code class="language-julia hljs">julia&gt; reg = rand_state(20);

julia&gt; @time apply!(reg, repeat(20, X));
  0.002252 seconds (5 allocations: 656 bytes)

julia&gt; @time apply!(reg, chain([put(20, i=&gt;X) for i=1:20]));
  0.049362 seconds (82.48 k allocations: 4.694 MiB, 47.11% compilation time)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/repeated.jl#L39-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.ishermitian-Tuple{Any}" href="#LinearAlgebra.ishermitian-Tuple{Any}"><code>LinearAlgebra.ishermitian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">ishermitian(op::AbstractBlock) -&gt; Bool</code></pre><p>Returns true if <code>op</code> is hermitian.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L11-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.chcontent-Tuple{AbstractContainer, Any}" href="#YaoAPI.chcontent-Tuple{AbstractContainer, Any}"><code>YaoAPI.chcontent</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chcontent(x, blk)</code></pre><p>Create a similar block of <code>x</code> and change its content to blk.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/composite.jl#L9-L13">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.chsubblocks-Tuple{AbstractBlock, Any}" href="#YaoAPI.chsubblocks-Tuple{AbstractBlock, Any}"><code>YaoAPI.chsubblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chsubblocks(composite_block, itr)</code></pre><p>Change the sub-blocks of a <a href="man/@ref"><code>CompositeBlock</code></a> with given iterator <code>itr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L89-L93">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.content-Tuple{AbstractContainer}" href="#YaoAPI.content-Tuple{AbstractContainer}"><code>YaoAPI.content</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">content(x)</code></pre><p>Returns the content of <code>x</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/composite.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.dispatch!-Tuple{Union{Nothing, Function}, AbstractBlock, Any}" href="#YaoAPI.dispatch!-Tuple{Union{Nothing, Function}, AbstractBlock, Any}"><code>YaoAPI.dispatch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispatch!(x::AbstractBlock, collection)</code></pre><p>Dispatch parameters in collection to block tree <code>x</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>it will try to dispatch the parameters in collection first.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L287-L295">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.expect-Tuple{AbstractBlock, DensityMatrix}" href="#YaoAPI.expect-Tuple{AbstractBlock, DensityMatrix}"><code>YaoAPI.expect</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">expect(op::AbstractBlock, reg) -&gt; Vector
expect(op::AbstractBlock, reg =&gt; circuit) -&gt; Vector
expect(op::AbstractBlock, density_matrix) -&gt; Vector</code></pre><p>Get the expectation value of an operator, the second parameter can be a register <code>reg</code> or a pair of input register and circuit <code>reg =&gt; circuit</code>.</p><p>expect&#39;(op::AbstractBlock, reg=&gt;circuit) -&gt; Pair expect&#39;(op::AbstractBlock, reg) -&gt; AbstracRegister</p><p>Obtain the gradient with respect to registers and circuit parameters. For pair input, the second return value is a pair of <code>gψ=&gt;gparams</code>, with <code>gψ</code> the gradient of input state and <code>gparams</code> the gradients of circuit parameters. For register input, the return value is a register.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For batched register, <code>expect(op, reg=&gt;circuit)</code> returns a vector of size number of batch as output. However, one can not differentiate over a vector loss, so <code>expect&#39;(op, reg=&gt;circuit)</code> accumulates the gradient over batch, rather than returning a batched gradient of parameters.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/blocktools.jl#L76-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.getiparams-Tuple{AbstractBlock}" href="#YaoAPI.getiparams-Tuple{AbstractBlock}"><code>YaoAPI.getiparams</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getiparams(block)</code></pre><p>Returns the intrinsic parameters of node <code>block</code>, default is an empty tuple.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L153-L157">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.iparams_eltype-Tuple{AbstractBlock}" href="#YaoAPI.iparams_eltype-Tuple{AbstractBlock}"><code>YaoAPI.iparams_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">iparams_eltype(block)</code></pre><p>Return the element type of <a href="blocks.html#YaoAPI.getiparams-Tuple{AbstractBlock}"><code>getiparams</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L231-L235">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.mat-Tuple{AbstractBlock}" href="#YaoAPI.mat-Tuple{AbstractBlock}"><code>YaoAPI.mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mat([T=ComplexF64], blk)</code></pre><p>Returns the matrix form of given block.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L115-L119">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.mat-Tuple{GeneralMatrixBlock}" href="#YaoAPI.mat-Tuple{GeneralMatrixBlock}"><code>YaoAPI.mat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">mat(A::GeneralMatrixBlock)</code></pre><p>Return the matrix of general matrix block.</p><div class="admonition is-category-warn"><header class="admonition-header">Warn</header><div class="admonition-body"><p>Instead of converting it to the default data type <code>ComplexF64</code>, this will return its contained matrix.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/general_matrix_gate.jl#L57-L66">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.operator_fidelity-Tuple{AbstractBlock, AbstractBlock}" href="#YaoAPI.operator_fidelity-Tuple{AbstractBlock, AbstractBlock}"><code>YaoAPI.operator_fidelity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">operator_fidelity(b1::AbstractBlock, b2::AbstractBlock) -&gt; Number</code></pre><p>Operator fidelity defined as</p><p class="math-container">\[F^2 = \frac{1}{d^2}\left[{\rm Tr}(b1^\dagger b2)\right]\]</p><p>Here, <code>d</code> is the size of the Hilbert space. Note this quantity is independant to global phase. See arXiv: 0803.2940v2, Equation (2) for reference.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/blocktools.jl#L140-L151">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.parameters-Tuple{AbstractBlock}" href="#YaoAPI.parameters-Tuple{AbstractBlock}"><code>YaoAPI.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters(block)</code></pre><p>Returns all the parameters contained in block tree with given root <code>block</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L198-L202">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.parameters_eltype-Tuple{AbstractBlock}" href="#YaoAPI.parameters_eltype-Tuple{AbstractBlock}"><code>YaoAPI.parameters_eltype</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters_eltype(x)</code></pre><p>Return the element type of <a href="blocks.html#YaoAPI.parameters-Tuple{AbstractBlock}"><code>parameters</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L238-L242">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.setiparams!" href="#YaoAPI.setiparams!"><code>YaoAPI.setiparams!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setiparams!([f], block, itr)
setiparams!([f], block, params...)</code></pre><p>Set the parameters of <code>block</code>. When <code>f</code> is provided, set parameters of <code>block</code> to the value in <code>collection</code> mapped by <code>f</code>. <code>iter</code> can be an iterator or a symbol, the symbol can be <code>:zero</code>, <code>:random</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L160-L167">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoAPI.subblocks-Tuple{AbstractBlock}" href="#YaoAPI.subblocks-Tuple{AbstractBlock}"><code>YaoAPI.subblocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subblocks(x)</code></pre><p>Returns an iterator of the sub-blocks of a composite block. Default is empty.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Rx-Tuple{Any}" href="#YaoBlocks.Rx-Tuple{Any}"><code>YaoBlocks.Rx</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Rx(theta)</code></pre><p>Return a <a href="blocks.html#YaoBlocks.RotationGate"><code>RotationGate</code></a> on X axis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Rx(0.1)
rot(X, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/rotation_gate.jl#L33-L44">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Ry-Tuple{Any}" href="#YaoBlocks.Ry-Tuple{Any}"><code>YaoBlocks.Ry</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Ry(theta)</code></pre><p>Return a <a href="blocks.html#YaoBlocks.RotationGate"><code>RotationGate</code></a> on Y axis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Ry(0.1)
rot(Y, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/rotation_gate.jl#L47-L58">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.Rz-Tuple{Any}" href="#YaoBlocks.Rz-Tuple{Any}"><code>YaoBlocks.Rz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">Rz(theta)</code></pre><p>Return a <a href="blocks.html#YaoBlocks.RotationGate"><code>RotationGate</code></a> on Z axis.</p><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; Rz(0.1)
rot(Z, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/rotation_gate.jl#L61-L72">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.applymatrix-Tuple{Any, AbstractBlock}" href="#YaoBlocks.applymatrix-Tuple{Any, AbstractBlock}"><code>YaoBlocks.applymatrix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">applymatrix(g::AbstractBlock) -&gt; Matrix</code></pre><p>Transform the apply! function of specific block to dense matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L96-L100">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cache" href="#YaoBlocks.cache"><code>YaoBlocks.cache</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cache(x[, level=1; recursive=false])</code></pre><p>Create a <a href="blocks.html#YaoBlocks.CachedBlock"><code>CachedBlock</code></a> with given block <code>x</code>, which will cache the matrix of <code>x</code> for the first time it calls <a href="blocks.html#YaoAPI.mat-Tuple{AbstractBlock}"><code>mat</code></a>, and use the cached matrix in the following calculations.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cache(control(3, 1, 2=&gt;X))
nqubits: 3
[cached] control(1)
   └─ (2,) X


julia&gt; chain(cache(control(3, 1, 2=&gt;X)), repeat(H))
nqubits: 3
chain
└─ [cached] control(1)
      └─ (2,) X
</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/tag/cache.jl#L106-L128">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cache_key-Tuple{AbstractBlock}" href="#YaoBlocks.cache_key-Tuple{AbstractBlock}"><code>YaoBlocks.cache_key</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cache_key(block)</code></pre><p>Returns the key that identify the matrix cache of this block. By default, we use the returns of <a href="blocks.html#YaoAPI.parameters-Tuple{AbstractBlock}"><code>parameters</code></a> as its key.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L347-L352">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cache_type-Tuple{Type{&lt;:AbstractBlock}}" href="#YaoBlocks.cache_type-Tuple{Type{&lt;:AbstractBlock}}"><code>YaoBlocks.cache_type</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cache_type(::Type) -&gt; DataType</code></pre><p>Return the element type that a <a href="man/@ref"><code>CacheFragment</code></a> will use.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L339-L344">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.chain-Tuple{Int64}" href="#YaoBlocks.chain-Tuple{Int64}"><code>YaoBlocks.chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain(n)</code></pre><p>Return an empty <a href="blocks.html#YaoBlocks.ChainBlock"><code>ChainBlock</code></a> which can be used like a list of blocks.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chain(2)
nqubits: 2
chain


julia&gt; chain(2; nlevel=3)
nqudits: 2
chain

</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/chain.jl#L88-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.chain-Tuple{}" href="#YaoBlocks.chain-Tuple{}"><code>YaoBlocks.chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain()</code></pre><p>Return an lambda <code>n-&gt;chain(n)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/chain.jl#L110-L114">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.chain-Union{Tuple{Vararg{AbstractBlock{D}}}, Tuple{D}} where D" href="#YaoBlocks.chain-Union{Tuple{Vararg{AbstractBlock{D}}}, Tuple{D}} where D"><code>YaoBlocks.chain</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chain(blocks...) -&gt; ChainBlock
chain(n) -&gt; ChainBlock</code></pre><p>Return a <a href="blocks.html#YaoBlocks.ChainBlock"><code>ChainBlock</code></a> which chains a list of blocks with the same number of qudits. Let <span>$G_i$</span> be a sequence of n-qudit blocks, the matrix representation of block <code>chain(G_1, G_2, ..., G_m)</code> is</p><p class="math-container">\[G_m G_{m-1}\ldots G_1\]</p><p>It is almost equivalent to matrix multiplication except the order is reversed. We make its order different from regular matrix multiplication because quantum circuits can be represented more naturally in this form.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; chain(X, Y, Z)
nqubits: 1
chain
├─ X
├─ Y
└─ Z

julia&gt; chain(2, put(1=&gt;X), put(2=&gt;Y), cnot(2, 1))
nqubits: 2
chain
├─ put on (1)
│  └─ X
├─ put on (2)
│  └─ Y
└─ control(2)
   └─ (1,) X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/chain.jl#L25-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.chmeasureoperator-Union{Tuple{D}, Tuple{Measure{D, K} where K, AbstractBlock}} where D" href="#YaoBlocks.chmeasureoperator-Union{Tuple{D}, Tuple{Measure{D, K} where K, AbstractBlock}} where D"><code>YaoBlocks.chmeasureoperator</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">chmeasureoperator(m::Measure, op::AbstractBlock)</code></pre><p>change the measuring <code>operator</code>. It will also discard existing measuring results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/measure.jl#L51-L55">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cleanup-Tuple{EntryTable}" href="#YaoBlocks.cleanup-Tuple{EntryTable}"><code>YaoBlocks.cleanup</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cleanup(entries::EntryTable; zero_threshold=0.0)</code></pre><p>Clean up the entry table by 1) sort entries, 2) merge items and 3) clean up zeros. Any value with amplitude ≤ <code>zero_threshold</code> will be regarded as zero.</p><pre><code class="language-julia-repl hljs">julia&gt; et = EntryTable([bit&quot;000&quot;,bit&quot;011&quot;,bit&quot;101&quot;,bit&quot;101&quot;,bit&quot;011&quot;,bit&quot;110&quot;,bit&quot;110&quot;,bit&quot;011&quot;,], [1.0 + 0.0im,-1, 1,1,1,-1,1,1,-1])
EntryTable{DitStr{2, 3, Int64}, ComplexF64}:
  000 ₍₂₎   1.0 + 0.0im
  011 ₍₂₎   -1.0 + 0.0im
  101 ₍₂₎   1.0 + 0.0im
  101 ₍₂₎   1.0 + 0.0im
  011 ₍₂₎   1.0 + 0.0im
  110 ₍₂₎   -1.0 + 0.0im
  110 ₍₂₎   1.0 + 0.0im
  011 ₍₂₎   1.0 + 0.0im


julia&gt; cleanup(et)
EntryTable{DitStr{2, 3, Int64}, ComplexF64}:
  000 ₍₂₎   1.0 + 0.0im
  011 ₍₂₎   1.0 + 0.0im
  101 ₍₂₎   2.0 + 0.0im</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L205-L230">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cnot-Tuple{Int64, Any, Int64}" href="#YaoBlocks.cnot-Tuple{Int64, Any, Int64}"><code>YaoBlocks.cnot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cnot([n, ]ctrl_locs, location)</code></pre><p>Return a speical <a href="man/@ref"><code>ControlBlock</code></a>, aka CNOT gate with number of active qubits <code>n</code> and locs of control qubits <code>ctrl_locs</code>, and <code>location</code> of <code>X</code> gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cnot(3, (2, 3), 1)
nqubits: 3
control(2, 3)
└─ (1,) X

julia&gt; cnot(2, 1)
(n -&gt; cnot(n, 2, 1))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/control.jl#L108-L125">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.collect_blocks-Union{Tuple{T}, Tuple{Type{T}, AbstractBlock}} where T&lt;:AbstractBlock" href="#YaoBlocks.collect_blocks-Union{Tuple{T}, Tuple{Type{T}, AbstractBlock}} where T&lt;:AbstractBlock"><code>YaoBlocks.collect_blocks</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">collect_blocks(block_type, root)</code></pre><p>Return a <a href="blocks.html#YaoBlocks.ChainBlock"><code>ChainBlock</code></a> with all block of <code>block_type</code> in root.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/blocktools.jl#L64-L68">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.control-Tuple{Any, Pair}" href="#YaoBlocks.control-Tuple{Any, Pair}"><code>YaoBlocks.control</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">control(ctrl_locs, target) -&gt; f(n)</code></pre><p>Return a lambda that takes the number of total active qubits as input. See also <a href="blocks.html#YaoBlocks.control-Tuple{Any, Pair}"><code>control</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; control((2, 3), 1=&gt;X)
(n -&gt; control(n, (2, 3), 1 =&gt; X))

julia&gt; control(2, 1=&gt;X)
(n -&gt; control(n, 2, 1 =&gt; X))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/control.jl#L89-L104">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.control-Tuple{Int64, Any, Pair}" href="#YaoBlocks.control-Tuple{Int64, Any, Pair}"><code>YaoBlocks.control</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">control(n, ctrl_locs, locations =&gt; subblock)</code></pre><p>Return a <code>n</code>-qubit <a href="man/@ref"><code>ControlBlock</code></a>, where the control locations <code>ctrl_locs</code> and the subblock <code>locations</code> in the third argument can be an integer, a tuple or a range, and the size of the subblock should match the length of <code>locations</code>. Let <span>$I$</span> be the <span>$2 \times 2$</span> identity matrix, <span>$G$</span> be a <span>$2 \times 2$</span> subblock, <span>$P_0=|0\rangle\langle 0|$</span> and <span>$P_1=|1\rangle\langle 1|$</span> be two single qubit projection operators to subspace <span>$|0\rangle$</span> and <span>$|1\rangle$</span>, <span>$i$</span> and <span>$j$</span> be two integers that <span>$i&gt;j$</span>. The matrix representation of <code>control(n, i, j=&gt;G)</code> is</p><p class="math-container">\[\begin{align}
&amp;I^{\otimes n-i} P_0 \otimes I^{\otimes i-j-1} \otimes I\otimes I^{\otimes j-1}
+\\
&amp; I^{\otimes n-i} P_1 \otimes I^{\otimes i-j-1} \otimes G\otimes I^{\otimes j-1}
\end{align}\]</p><p>The multi-controlled multi-qubit controlled block is more complicated, it means apply the gate when control qubits are all ones. Each control location can take a negative sign to represent the inverse control, meaning only when this qubit is <code>0</code>, the controlled gate is applied.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; control(4, (1, 2), 3=&gt;X)
nqubits: 4
control(1, 2)
└─ (3,) X

julia&gt; control(4, 1, 3=&gt;X)
nqubits: 4
control(1)
└─ (3,) X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/control.jl#L50-L84">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cunmat" href="#YaoBlocks.cunmat"><code>YaoBlocks.cunmat</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">cunmat(nbit::Int, cbits::NTuple{C, Int}, cvals::NTuple{C, Int}, U0::AbstractMatrix, locs::NTuple{M, Int}) where {C, M} -&gt; AbstractMatrix</code></pre><p>control-unitary matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/routines.jl#L1-L5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.cz-Tuple{Int64, Any, Int64}" href="#YaoBlocks.cz-Tuple{Int64, Any, Int64}"><code>YaoBlocks.cz</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">cz([n, ]ctrl_locs, location)</code></pre><p>Return a speical <a href="man/@ref"><code>ControlBlock</code></a>, aka CZ gate with number of active qubits <code>n</code> and locs of control qubits <code>ctrl_locs</code>, and <code>location</code> of <code>Z</code> gate. See also <a href="blocks.html#YaoBlocks.cnot-Tuple{Int64, Any, Int64}"><code>cnot</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; cz(2, 1, 2)
nqubits: 2
control(1)
└─ (2,) Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/control.jl#L129-L144">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.decode_sign-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N" href="#YaoBlocks.decode_sign-Union{Tuple{Tuple{Vararg{Int64, N}}}, Tuple{N}} where N"><code>YaoBlocks.decode_sign</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">decode_sign(ctrls...)</code></pre><p>Decode signs into control sequence on control or inversed control.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/control.jl#L22-L26">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.dispatch-Tuple{Union{Nothing, Function}, AbstractBlock, Any}" href="#YaoBlocks.dispatch-Tuple{Union{Nothing, Function}, AbstractBlock, Any}"><code>YaoBlocks.dispatch</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">dispatch(x::AbstractBlock, collection)</code></pre><p>Dispatch parameters in collection to block tree <code>x</code>, the generic non-inplace version.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>it will try to dispatch the parameters in collection first.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L435-L443">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.dump_gate" href="#YaoBlocks.dump_gate"><code>YaoBlocks.dump_gate</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">dump_gate(blk::AbstractBlock) -&gt; Expr</code></pre><p>convert a gate to a YaoScript expression for serization. The fallback is <code>GateTypeName(fields...)</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/treeutils/dump.jl#L1-L6">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.eigenbasis-Union{Tuple{AbstractBlock{D}}, Tuple{D}} where D" href="#YaoBlocks.eigenbasis-Union{Tuple{AbstractBlock{D}}, Tuple{D}} where D"><code>YaoBlocks.eigenbasis</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">eigenbasis(op::AbstractBlock)</code></pre><p>Return the <code>eigenvalue</code> and <code>eigenvectors</code> of target operator. By applying <code>eigenvector</code>&#39; to target state, one can swith the basis to the eigenbasis of this operator. However, <code>eigenvalues</code> does not have a specific form.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/measure_ops.jl#L2-L9">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.gate_expr-Union{Tuple{G}, Tuple{Val{G}, Any, Any}} where G" href="#YaoBlocks.gate_expr-Union{Tuple{G}, Tuple{Val{G}, Any, Any}} where G"><code>YaoBlocks.gate_expr</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">gate_expr(::Val{G}, args, info)</code></pre><p>Obtain the gate constructior from its YaoScript expression. <code>G</code> is a symbol for the gate type, the default constructor is <code>G(args...)</code>. <code>info</code> contains the informations about the number of qubit and Yao version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/treeutils/load.jl#L191-L198">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.getcol-Tuple{LuxurySparse.SDSparseMatrixCSC, Int64}" href="#YaoBlocks.getcol-Tuple{LuxurySparse.SDSparseMatrixCSC, Int64}"><code>YaoBlocks.getcol</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">getcol(csc::SDparseMatrixCSC, icol::Int) -&gt; (View, View)</code></pre><p>get specific col of a CSC matrix, returns a slice of (rowval, nzval)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/routines.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.igate-Tuple{Int64}" href="#YaoBlocks.igate-Tuple{Int64}"><code>YaoBlocks.igate</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">igate(n::Int; nlevel=2)</code></pre><p>The constructor for <a href="blocks.html#YaoBlocks.IdentityGate"><code>IdentityGate</code></a>. Let <span>$I_d$</span> be a <span>$d \times d$</span> identity matrix, <code>igate(n; nlevel=d)</code> is defined as <span>$I_d^{\otimes n}$</span>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; igate(2)
igate(2)

julia&gt; igate(2; nlevel=3)
igate(2;nlevel=3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/identity_gate.jl#L27-L42">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.isclean-Tuple{EntryTable}" href="#YaoBlocks.isclean-Tuple{EntryTable}"><code>YaoBlocks.isclean</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">isclean(entries::EntryTable; zero_threshold=0.0)</code></pre><p>Return true if the entries are ordered, unique and amplitudes are nonzero. Any value with amplitude ≤ <code>zero_threshold</code> will be regarded as zero.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L266-L271">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.map_address" href="#YaoBlocks.map_address"><code>YaoBlocks.map_address</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">map_address(block::AbstractBlock, info::AddressInfo) -&gt; AbstractBlock</code></pre><p>map the locations in <code>block</code> to target locations.</p><p><strong>Example</strong></p><p><code>map_address</code> can be used to embed a sub-circuit to a larger one.</p><pre><code class="language-julia-repl hljs">julia&gt; c = chain(5, repeat(H, 1:5), put(2=&gt;X), kron(1=&gt;X, 3=&gt;Y))
nqubits: 5
chain
├─ repeat on (1, 2, 3, 4, 5)
│  └─ H
├─ put on (2)
│  └─ X
└─ kron
   ├─ 1=&gt;X
   └─ 3=&gt;Y


julia&gt; map_address(c, AddressInfo(10, [6,7,8,9,10]))
nqubits: 10
chain
├─ repeat on (6, 7, 8, 9, 10)
│  └─ H
├─ put on (7)
│  └─ X
└─ kron
   ├─ 6=&gt;X
   └─ 8=&gt;Y</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/treeutils/address_manipulate.jl#L13-L46">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.matblock-Tuple{AbstractMatrix}" href="#YaoBlocks.matblock-Tuple{AbstractMatrix}"><code>YaoBlocks.matblock</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">matblock(mat_or_block; nlevel=2, tag=&quot;matblock(...)&quot;)</code></pre><p>Create a <a href="blocks.html#YaoBlocks.GeneralMatrixBlock"><code>GeneralMatrixBlock</code></a> with a matrix <code>m</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; matblock(ComplexF64[0 1;1 0])
matblock(...)</code></pre><p>!!!warn</p><pre><code class="nohighlight hljs">Instead of converting it to the default data type `ComplexF64`,
this will return its contained matrix when calling `mat`.</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/general_matrix_gate.jl#L35-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.num_nonzero" href="#YaoBlocks.num_nonzero"><code>YaoBlocks.num_nonzero</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">num_nonzero(nbits, nctrls, U, [N])</code></pre><p>Return number of nonzero entries of the matrix form of control-U gate. <code>nbits</code> is the number of qubits, and <code>nctrls</code> is the number of control qubits.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/routines.jl#L33-L38">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.parameters!-Tuple{Any, AbstractBlock}" href="#YaoBlocks.parameters!-Tuple{Any, AbstractBlock}"><code>YaoBlocks.parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters!(out, block)</code></pre><p>Append all the parameters contained in block tree with given root <code>block</code> to <code>out</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L205-L210">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.parameters_range-Tuple{AbstractBlock}" href="#YaoBlocks.parameters_range-Tuple{AbstractBlock}"><code>YaoBlocks.parameters_range</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">parameters_range(block)</code></pre><p>Return the range of real parameters present in <code>block</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>It may not be the case that <code>length(parameters_range(block)) == nparameters(block)</code>.</p></div></div><p><strong>Example</strong></p><pre><code class="language-julia-repl hljs">julia&gt; YaoBlocks.parameters_range(RotationGate(X, 0.1))
1-element Vector{Tuple{Float64, Float64}}:
 (0.0, 6.283185307179586)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L379-L394">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.parse_block" href="#YaoBlocks.parse_block"><code>YaoBlocks.parse_block</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">parse_block(n, ex)</code></pre><p>This function parse the julia object <code>ex</code> to a quantum block, it defines the syntax of high level interfaces. <code>ex</code> can be a function takes number of qubits <code>n</code> as input or it can be a pair.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/blocktools.jl#L3-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.phase-Tuple{Real}" href="#YaoBlocks.phase-Tuple{Real}"><code>YaoBlocks.phase</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">phase(theta)</code></pre><p>Returns a global phase gate. Defined with following matrix form:</p><p class="math-container">\[e^{iθ} I\]</p><p><strong>Examples</strong></p><p>You can create a global phase gate with a phase (a real number).</p><pre><code class="language-julia-repl hljs">julia&gt; phase(0.1)
phase(0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/phase_gate.jl#L13-L30">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.popdispatch!-Tuple{AbstractBlock, Vector}" href="#YaoBlocks.popdispatch!-Tuple{AbstractBlock, Vector}"><code>YaoBlocks.popdispatch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">popdispatch!(block, list)</code></pre><p>Pop the first <a href="man/@ref"><code>nparameters</code></a> parameters of list, then dispatch them to the block tree <code>block</code>. See also <a href="blocks.html#YaoAPI.dispatch!-Tuple{Union{Nothing, Function}, AbstractBlock, Any}"><code>dispatch!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L319-L324">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.popdispatch!-Tuple{Function, AbstractBlock, Vector}" href="#YaoBlocks.popdispatch!-Tuple{Function, AbstractBlock, Vector}"><code>YaoBlocks.popdispatch!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">popdispatch!(f, block, list)</code></pre><p>Pop the first <a href="man/@ref"><code>nparameters</code></a> parameters of list, map them with a function <code>f</code>, then dispatch them to the block tree <code>block</code>. See also <a href="blocks.html#YaoAPI.dispatch!-Tuple{Union{Nothing, Function}, AbstractBlock, Any}"><code>dispatch!</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L305-L310">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.postwalk-Tuple{Union{Function, Type}, AbstractBlock}" href="#YaoBlocks.postwalk-Tuple{Union{Function, Type}, AbstractBlock}"><code>YaoBlocks.postwalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">postwalk(f, src::AbstractBlock)</code></pre><p>Walk the tree and call <code>f</code> after the children are visited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/blocktools.jl#L48-L52">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.prewalk-Tuple{Union{Function, Type}, AbstractBlock}" href="#YaoBlocks.prewalk-Tuple{Union{Function, Type}, AbstractBlock}"><code>YaoBlocks.prewalk</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">prewalk(f, src::AbstractBlock)</code></pre><p>Walk the tree and call <code>f</code> once the node is visited.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/blocktools.jl#L35-L39">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.print_annotation-Tuple{IO, Any, Any, Any, Any}" href="#YaoBlocks.print_annotation-Tuple{IO, Any, Any, Any, Any}"><code>YaoBlocks.print_annotation</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_annotation(io, root, node, child, k)</code></pre><p>Print the annotation of <code>k</code>-th <code>child</code> of node, aka the <code>k</code>-th element of <code>subblocks(node)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/layout.jl#L44-L49">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.print_prefix-Tuple{IO, Any, Any, Any}" href="#YaoBlocks.print_prefix-Tuple{IO, Any, Any, Any}"><code>YaoBlocks.print_prefix</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_prefix(io, depth, charset, active_levels)</code></pre><p>print prefix of a tree node in a single line.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/layout.jl#L16-L20">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.print_subtypetree" href="#YaoBlocks.print_subtypetree"><code>YaoBlocks.print_subtypetree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_subtypetree(::Type[, level=1, indent=4])</code></pre><p>Print subtype tree, <code>level</code> specify the depth of the tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L10-L14">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.print_title-Tuple{IO, AbstractBlock}" href="#YaoBlocks.print_title-Tuple{IO, AbstractBlock}"><code>YaoBlocks.print_title</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_title(io, block)</code></pre><p>Print the title of given <code>block</code> of an <a href="man/@ref"><code>AbstractBlock</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/layout.jl#L31-L35">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.print_tree" href="#YaoBlocks.print_tree"><code>YaoBlocks.print_tree</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">print_tree(io, root, node[, depth=1, active_levels=()]; kwargs...)</code></pre><p>Print the block tree.</p><p><strong>Keywords</strong></p><ul><li><code>maxdepth</code>: max tree depth to print</li><li><code>charset</code>: default is (&#39;├&#39;,&#39;└&#39;,&#39;│&#39;,&#39;─&#39;). See also <a href="man/@ref"><code>BlockTreeCharSet</code></a>.</li><li><code>title</code>: control whether to print the title, <code>true</code> or <code>false</code>, default is <code>true</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/layout.jl#L72-L82">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.print_tree-Tuple{Any}" href="#YaoBlocks.print_tree-Tuple{Any}"><code>YaoBlocks.print_tree</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">print_tree([io=stdout], root)</code></pre><p>Print the block tree.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/layout.jl#L52-L56">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.projector-Tuple{Any}" href="#YaoBlocks.projector-Tuple{Any}"><code>YaoBlocks.projector</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">projector(x)</code></pre><p>Return projector on <code>0</code> or projector on <code>1</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L3-L7">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.pswap-Tuple{Int64, Int64, Int64, Real}" href="#YaoBlocks.pswap-Tuple{Int64, Int64, Int64, Real}"><code>YaoBlocks.pswap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">pswap(n::Int, i::Int, j::Int, α::Real)
pswap(i::Int, j::Int, α::Real) -&gt; f(n)</code></pre><p>parametrized swap gate.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; pswap(2, 1, 2, 0.1)
nqubits: 2
put on (1, 2)
└─ rot(SWAP, 0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/put_block.jl#L168-L182">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.put-Tuple{Pair}" href="#YaoBlocks.put-Tuple{Pair}"><code>YaoBlocks.put</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">put(pair) -&gt; f(n)</code></pre><p>Lazy curried version of <a href="blocks.html#YaoBlocks.put-Tuple{Pair}"><code>put</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; put(1=&gt;X)
(n -&gt; put(n, 1 =&gt; X))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/put_block.jl#L67-L78">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.put-Union{Tuple{M}, Tuple{Int64, Pair{Tuple{Vararg{Int64, M}}, &lt;:AbstractBlock}}} where M" href="#YaoBlocks.put-Union{Tuple{M}, Tuple{Int64, Pair{Tuple{Vararg{Int64, M}}, &lt;:AbstractBlock}}} where M"><code>YaoBlocks.put</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">put(n::Int, locations =&gt; subblock) =&gt; PutBlock</code></pre><p>Create a <code>n</code>-qudit <a href="blocks.html#YaoBlocks.PutBlock"><code>PutBlock</code></a>. The second argument is a pair of locations and subblock, where the locations can be a tuple, an integer or a range and the subblock size should match the length of locations. Let <span>$I$</span> be a <span>$2\times 2$</span> identity matrix and <span>$G$</span> be a <span>$2\times 2$</span> matrix, the matrix representation of <code>put(n, i=&gt;G)</code> is defined as</p><p class="math-container">\[I^{\otimes n-i} \otimes G \otimes I^{\otimes i-1}\]</p><p>For multiple locations, the expression can be complicated,  which corresponds to the matrix representation of multi-qubit gate applied on <code>n</code>-qubit space in quantum computing.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; put(4, 1=&gt;X)
nqubits: 4
put on (1)
└─ X</code></pre><p>If you want to put a multi-qubit gate on specific locations, you need to write down all possible locations.</p><pre><code class="language-julia-repl hljs">julia&gt; put(4, (1, 3)=&gt;kron(X, Y))
nqubits: 4
put on (1, 3)
└─ kron
   ├─ 1=&gt;X
   └─ 2=&gt;Y</code></pre><p>The outter locations creates a scope which make it seems to be a contiguous two qubits for the block inside <code>PutBlock</code>.</p><div class="admonition is-category-tips"><header class="admonition-header">Tips</header><div class="admonition-body"><p>It is better to use <a href="blocks.html#YaoBlocks.subroutine-Tuple{AbstractBlock, Any}"><code>subroutine</code></a> instead of <code>put</code> for large blocks, since put will use the matrix of its contents directly instead of making use of what&#39;s in it. <code>put</code> is more efficient for small blocks.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/put_block.jl#L21-L60">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.rand_hermitian-Tuple{Int64}" href="#YaoBlocks.rand_hermitian-Tuple{Int64}"><code>YaoBlocks.rand_hermitian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_hermitian([T=ComplexF64], N::Int) -&gt; Matrix</code></pre><p>Create a random hermitian matrix.</p><pre><code class="language-julia-repl hljs">julia&gt; ishermitian(rand_hermitian(2))
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L65-L74">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.rand_unitary-Tuple{Int64}" href="#YaoBlocks.rand_unitary-Tuple{Int64}"><code>YaoBlocks.rand_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rand_unitary([T=ComplexF64], N::Int) -&gt; Matrix</code></pre><p>Create a random unitary matrix.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; isunitary(rand_unitary(2))
true

julia&gt; eltype(rand_unitary(ComplexF32, 2))
ComplexF32 (alias for Complex{Float32})</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L37-L51">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.rmlines-Tuple{Expr}" href="#YaoBlocks.rmlines-Tuple{Expr}"><code>YaoBlocks.rmlines</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rmlines(ex)</code></pre><p>Remove <code>LineNumberNode</code> from an <code>Expr</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L23-L27">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.rot-Tuple{AbstractBlock, Any}" href="#YaoBlocks.rot-Tuple{AbstractBlock, Any}"><code>YaoBlocks.rot</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">rot(U, theta)</code></pre><p>Return a <a href="blocks.html#YaoBlocks.RotationGate"><code>RotationGate</code></a> on U axis.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/rotation_gate.jl#L75-L79">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.setcol!-Tuple{SparseMatrixCSC, Int64, AbstractVector, Any}" href="#YaoBlocks.setcol!-Tuple{SparseMatrixCSC, Int64, AbstractVector, Any}"><code>YaoBlocks.setcol!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">setcol!(csc::SparseMatrixCSC, icol::Int, rowval::AbstractVector, nzval) -&gt; SparseMatrixCSC</code></pre><p>set specific col of a CSC matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/routines.jl#L18-L22">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.setiparams" href="#YaoBlocks.setiparams"><code>YaoBlocks.setiparams</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">setiparams([f], block, itr)
setiparams([f], block, params...)</code></pre><p>Set the parameters of <code>block</code>, the non-inplace version. When <code>f</code> is provided, set parameters of <code>block</code> to the value in <code>collection</code> mapped by <code>f</code>. <code>iter</code> can be an iterator or a symbol, the symbol can be <code>:zero</code>, <code>:random</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/abstract_block.jl#L170-L177">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.shift-Tuple{Any}" href="#YaoBlocks.shift-Tuple{Any}"><code>YaoBlocks.shift</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">shift(θ)</code></pre><p>Create a <a href="blocks.html#YaoBlocks.ShiftGate"><code>ShiftGate</code></a> with phase <code>θ</code>.</p><p class="math-container">\[\begin{pmatrix}
1 &amp; 0\\
0 &amp; e^{i\theta}
\end{pmatrix}\]</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; shift(0.1)
shift(0.1)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/shift_gate.jl#L15-L33">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.simple_commute_eachother-Union{Tuple{Vector{&lt;:AbstractBlock{D}}}, Tuple{D}} where D" href="#YaoBlocks.simple_commute_eachother-Union{Tuple{Vector{&lt;:AbstractBlock{D}}}, Tuple{D}} where D"><code>YaoBlocks.simple_commute_eachother</code></a> — <span class="docstring-category">Method</span></header><section><div><p>Return true if operators commute to each other.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/measure_ops.jl#L21-L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.sprand_hermitian-Tuple{Int64, Any}" href="#YaoBlocks.sprand_hermitian-Tuple{Int64, Any}"><code>YaoBlocks.sprand_hermitian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sprand_hermitian([T=ComplexF64], N, density)</code></pre><p>Create a sparse random hermitian matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L82-L86">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.sprand_unitary-Tuple{Int64, Real}" href="#YaoBlocks.sprand_unitary-Tuple{Int64, Real}"><code>YaoBlocks.sprand_unitary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">sprand_unitary([T=ComplexF64], N::Int, density) -&gt; SparseMatrixCSC</code></pre><p>Create a random sparse unitary matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/utils.jl#L55-L59">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.subroutine-Tuple{AbstractBlock, Any}" href="#YaoBlocks.subroutine-Tuple{AbstractBlock, Any}"><code>YaoBlocks.subroutine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subroutine(block, locs) -&gt; f(n)</code></pre><p>Lazy curried version of <a href="blocks.html#YaoBlocks.subroutine-Tuple{AbstractBlock, Any}"><code>subroutine</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/subroutine.jl#L85-L89">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.subroutine-Tuple{Int64, AbstractBlock, Any}" href="#YaoBlocks.subroutine-Tuple{Int64, AbstractBlock, Any}"><code>YaoBlocks.subroutine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">subroutine(n, block, locs)</code></pre><p>Create a <code>n</code>-qudit <a href="blocks.html#YaoBlocks.Subroutine"><code>Subroutine</code></a> block, where the <code>subblock</code> is a subprogram of size <code>m</code>, and <code>locs</code> is a tuple or range of length <code>m</code>. It runs a quantum subprogram with smaller size on a subset of locations. While its mathematical definition is the same as the <a href="blocks.html#YaoBlocks.put-Tuple{Pair}"><code>put</code></a> block, while it is more suited for running a larger chunk of circuit.</p><p><strong>Examples</strong></p><p>Subroutine is equivalent to <a href="blocks.html#YaoBlocks.put-Tuple{Pair}"><code>put</code></a> a block on given position mathematically, but more efficient and convenient for large blocks.</p><pre><code class="language-julia-repl hljs">julia&gt; r = rand_state(3)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 3/3
    nlevel: 2

julia&gt; apply!(copy(r), subroutine(X, 1)) ≈ apply!(copy(r), put(1=&gt;X))
true</code></pre><p>It works for in-contigious locs as well</p><pre><code class="language-julia-repl hljs">julia&gt; r = rand_state(4)
ArrayReg{2, ComplexF64, Array...}
    active qubits: 4/4
    nlevel: 2

julia&gt; cc = subroutine(4, kron(X, Y), (1, 3))
nqubits: 4
Subroutine: (1, 3)
└─ kron
   ├─ 1=&gt;X
   └─ 2=&gt;Y

julia&gt; pp = chain(4, put(1=&gt;X), put(3=&gt;Y))
nqubits: 4
chain
├─ put on (1)
│  └─ X
└─ put on (3)
   └─ Y

julia&gt; apply!(copy(r), cc) ≈ apply!(copy(r), pp)
true</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/subroutine.jl#L28-L76">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.swap-Tuple{Int64, Int64, Int64}" href="#YaoBlocks.swap-Tuple{Int64, Int64, Int64}"><code>YaoBlocks.swap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap(n, loc1, loc2)</code></pre><p>Create a <code>n</code>-qubit <a href="man/@ref"><code>Swap</code></a> gate which swap <code>loc1</code> and <code>loc2</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; swap(4, 1, 2)
nqubits: 4
put on (1, 2)
└─ SWAP</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/put_block.jl#L128-L141">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.swap-Tuple{Int64, Int64}" href="#YaoBlocks.swap-Tuple{Int64, Int64}"><code>YaoBlocks.swap</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">swap(loc1, loc2) -&gt; f(n)</code></pre><p>Create a lambda that takes the total number of active qubits as input. Lazy curried version of <code>swap(n, loc1, loc2)</code>. See also <a href="man/@ref"><code>Swap</code></a>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; swap(1, 2)
(n -&gt; swap(n, 1, 2))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/put_block.jl#L144-L156">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.time_evolve-Tuple{AbstractBlock, Any}" href="#YaoBlocks.time_evolve-Tuple{AbstractBlock, Any}"><code>YaoBlocks.time_evolve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">time_evolve(H, dt[; tol=1e-7, check_hermicity=true])</code></pre><p>Create a <a href="blocks.html#YaoBlocks.TimeEvolution"><code>TimeEvolution</code></a> block with Hamiltonian <code>H</code> and time step <code>dt</code>. The <code>TimeEvolution</code> block will use Krylove based <code>expv</code> to calculate time propagation. <code>TimeEvolution</code> block can also be used for <a href="http://large.stanford.edu/courses/2008/ph372/behroozi2/">imaginary time evolution</a> if <code>dt</code> is complex. Let <span>$H$</span> be a hamiltonian and <span>$t$</span> be a time, the matrix representation of <code>time_evolve(H, t)</code> is <span>$e^{-iHt}$</span>.</p><p><strong>Arguments</strong></p><ul><li><code>H</code> the hamiltonian represented as an <code>AbstractBlock</code>.</li><li><code>dt</code>: the evolution duration (start time is zero).</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>tol::Real=1e-7</code>: error tolerance.</li><li><code>check_hermicity=true</code>: check hermicity or not.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; time_evolve(kron(2, 1=&gt;X, 2=&gt;X), 0.1)
Time Evolution Δt = 0.1, tol = 1.0e-7
kron
├─ 1=&gt;X
└─ 2=&gt;X</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/primitive/time_evolution.jl#L32-L61">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.u1ij!" href="#YaoBlocks.u1ij!"><code>YaoBlocks.u1ij!</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">u1ij!(target, i, j, a, b, c, d)</code></pre><p>single u1 matrix into a target matrix.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>For coo, we take an additional parameter     * ptr: starting position to store new data.</p></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/routines.jl#L8-L15">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.unitary_channel-Tuple{Any, AbstractVector}" href="#YaoBlocks.unitary_channel-Tuple{Any, AbstractVector}"><code>YaoBlocks.unitary_channel</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unitary_channel(operators, probs) -&gt; UnitaryChannel</code></pre><p>Returns a <a href="blocks.html#YaoBlocks.UnitaryChannel"><code>UnitaryChannel</code></a> instance, where `<code>operators</code> is a list of operators, <code>probs</code> is a real vector that sum up to 1. The unitary channel is defined as below</p><p class="math-container">\[\phi(\rho) = \sum_i p_i U_i ρ U_i^\dagger,\]</p><p>where <span>$\rho$</span> in a <a href="registers.html#YaoAPI.DensityMatrix"><code>DensityMatrix</code></a> as the register to apply on, <span>$p_i$</span> is the i-th element in <code>probs</code>, <code>U_i</code> is the i-th operator in <code>operators</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia-repl hljs">julia&gt; unitary_channel([X, Y, Z], [0.1, 0.2, 0.7])
nqubits: 1
unitary_channel
├─ [0.1] X
├─ [0.2] Y
└─ [0.7] Z</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/composite/unitary_channel.jl#L72-L94">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.unmat-Tuple{Val{2}, Int64, AbstractMatrix, Tuple{Vararg{T, N}} where {N, T}}" href="#YaoBlocks.unmat-Tuple{Val{2}, Int64, AbstractMatrix, Tuple{Vararg{T, N}} where {N, T}}"><code>YaoBlocks.unmat</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">unmat(::Val{D}, nbit::Int, U::AbstractMatrix, locs::NTuple) -&gt; AbstractMatrix</code></pre><p>Return the matrix representation of putting matrix at locs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/routines.jl#L104-L108">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="YaoBlocks.@yao_str-Tuple{String}" href="#YaoBlocks.@yao_str-Tuple{String}"><code>YaoBlocks.@yao_str</code></a> — <span class="docstring-category">Macro</span></header><section><div><pre><code class="language-julia hljs">@yao_str
yao&quot;...&quot;</code></pre><p>The mark up language for quantum circuit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/QuantumBFS/Yao.jl/blob/aba1047532f40a06c364e35ecd89110f9dd1c5d6/lib/YaoBlocks/src/treeutils/load.jl#L1-L6">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="registers.html">« Quantum Registers</a><a class="docs-footer-nextpage" href="symbolic.html">Symbolic Computation »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Sunday 12 June 2022 17:35">Sunday 12 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
